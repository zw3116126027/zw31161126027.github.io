[{"title":"HTML盒子模型","url":"/2022/04/28/html-he-zi-mo-xing/","content":"<h1 id=\"关于HTML盒子模型的笔记\"><a href=\"#关于HTML盒子模型的笔记\" class=\"headerlink\" title=\"关于HTML盒子模型的笔记\"></a>关于HTML盒子模型的笔记</h1><h3 id=\"样式图：\"><a href=\"#样式图：\" class=\"headerlink\" title=\"样式图：\"></a>样式图：</h3><p><img src=\"/2022/04/28/html-he-zi-mo-xing/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E9%A2%84%E8%A7%88.png\"></p>\n<p>建议：连接css文件(在css打代码更方便些)<br>  <figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;./css/master.css&quot;</span>&gt;</span>  <span class=\"comment\">&lt;!-- herf：实际文件地址--&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h2><ul>\n<li>浏览器默认样式</li>\n<li>所有元素都是矩形</li>\n<li>margin: 外边距</li>\n<li>border: 边框，有很多样式，直角、圆角、颜色等</li>\n<li>padding: 内边距</li>\n<li>content: 内容，就是本身的内容，比如一段话</li>\n</ul>\n<p>在浏览器默认所有的元素和边缘有空白是怎么回事呢？</p>\n<p><code>其实就是浏览器默认的边距样式，而且不一样的浏览器，样式也可能不一样，我们可以吧默认样式去掉。</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">* &#123;  <span class=\"comment\">/*默认通配符 匹配所有标签 */</span></span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;  <span class=\"comment\">/*去掉外边距*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"说一说盒子\"><a href=\"#说一说盒子\" class=\"headerlink\" title=\"说一说盒子:\"></a>说一说盒子:</h3><p>所有界面的元素都可以看出一个盒子，盒子模型就是包围内容的一个盒子。<br><img src=\"/2022/04/28/html-he-zi-mo-xing/1.png\"></p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;              <span class=\"comment\">/*盒子的大小，高宽也就是一个矩形*/</span></span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: aqua;    <span class=\"comment\">/*背景颜色*/</span></span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">30px</span>;             <span class=\"comment\">/*内边距*/</span></span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">300px</span>;             <span class=\"comment\">/*外边距*/</span></span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">20px</span> solid black;  <span class=\"comment\">/*边框样式为实线，颜色为黑色*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在设置了，<code>内边距</code>，<code>边框</code>，<code>外边距</code> 我们可以看出盒子似乎大了，不是一开始设置的300*150大小了，这是因为我们增加了内边距边框，但是为什么增加内边距边框,就导致盒子变大了呢？因为它默认的规则是，所有增加的边距边框都往外加！！！在内容高度宽度的基础上往外加！</p>\n<p>我们可以设置box-sizing:<br>一般默认的box-sizing为 content-box<br>我们设置为 border-box</p>\n<h3 id=\"预览：\"><a href=\"#预览：\" class=\"headerlink\" title=\"预览：\"></a>预览：</h3><p><img src=\"/2022/04/28/html-he-zi-mo-xing/2.png\"></p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自己的通俗理解:<br><code>也就是比如说，如果要建设一个房子,默认要装修就是在建好的房子里面装修，但是 未设置 box-sizing 就是反着来在初始房子大小往外扩建装修,但如果设置了box-sizing 为 border-box 就变成了在房子里面装修了，width:300px heigit:150 也就是基础房子的大小(盒子)</code></p>\n","categories":["HTML"],"tags":["HTML"]},{"title":"IDEA中使用maven下载速度很慢时解决办法","url":"/2022/07/03/idea-zhong-shi-yong-maven-xia-zai-su-du-hen-man-shi-jie-jue-ban-fa/","content":"<p><a href=\"https://blog.csdn.net/qq_37887131/article/details/89383051\">https://blog.csdn.net/qq_37887131/article/details/89383051</a></p>\n","categories":["IDEA"],"tags":["IDEA"]},{"title":"IDEA配置JDBC","url":"/2022/05/04/idea-pei-zhi-jdbc/","content":"<p><a href=\"https://blog.csdn.net/qq_34622844/article/details/102817852\">https://blog.csdn.net/qq_34622844/article/details/102817852</a></p>\n","categories":["Java"],"tags":["IDEA配置JDBC"]},{"title":"IO流","url":"/2022/05/26/io-liu/","content":"<h3 id=\"流是输入输出的方式\"><a href=\"#流是输入输出的方式\" class=\"headerlink\" title=\"流是输入输出的方式\"></a>流是输入输出的方式</h3><p>流是一维单向的,一维的</p>\n<p>stream</p>\n<h3 id=\"流的基础类\"><a href=\"#流的基础类\" class=\"headerlink\" title=\"流的基础类\"></a>流的基础类</h3><ul>\n<li>InputStream</li>\n<li>OutputStream</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IOtest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] buffer =<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> System.in.read(buffer);  <span class=\"comment\">//读到了多少东西</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buffer,<span class=\"number\">0</span>,len);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;读到了&quot;</span>+len+<span class=\"string\">&quot;字节&quot;</span>);</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;s的长度是：&quot;</span>+s.length());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只能处理单个字节，单个字节的读，单个字节的写</p>\n<h3 id=\"流过滤器\"><a href=\"#流过滤器\" class=\"headerlink\" title=\"流过滤器\"></a>流过滤器</h3><ul>\n<li>以一个介质流对象为基础层层构建过滤器，最终形成的流对象能在数据的输入输出过程中，逐层使用过滤器的方式来读写数据</li>\n</ul>\n","categories":["Java"],"tags":["java"]},{"title":"Java多线程","url":"/2022/03/31/java-duo-xian-cheng/","content":"<h1 id=\"线程创建\"><a href=\"#线程创建\" class=\"headerlink\" title=\"线程创建\"></a>线程创建</h1><p>Thread 、Runnable、Callable</p>\n<p>类              接口              接口</p>\n<h1 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h1><ul>\n<li><p>子类继承Thread类具备多线程能力</p>\n</li>\n<li><p>启动线程：子类对象.start()<br><font color=\"red\">不建议使用：避免OOP单继承局限性</font></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我在看代码！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        test1 test2=<span class=\"keyword\">new</span> <span class=\"title class_\">test1</span>();</span><br><span class=\"line\">        test2.start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我在学习多线程！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"Thread类的有关方法\"><a href=\"#Thread类的有关方法\" class=\"headerlink\" title=\"Thread类的有关方法\"></a>Thread类的有关方法</h1><ul>\n<li><p><font color=\"red\">void start():</font>启动线程，并执行对象的run()方法</p>\n</li>\n<li><p><font color=\"red\">run():</font>线程在被调度时执行的操作</p>\n</li>\n<li><p><font color=\"red\">String getName():</font>返回线程的名称</p>\n</li>\n<li><p><font color=\"red\">void setName(String name):</font>设置该线程名称</p>\n</li>\n<li><p><font color=\"red\">static Thread currentThread(): </font>返回当前线程。在Thread子类中就 是this，通常用于主线程和Runnable实现类</p>\n</li>\n<li><p><font color=\"red\">static void yield()：</font>线程让步</p>\n<ul>\n<li><blockquote>\n<p>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</p>\n<p>若队列中没有同优先级的线程，忽略此方法</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><font color=\"red\">join() ：</font>当某个程序执行流中调用其他线程的 join() 方法时，调用线程将 被阻塞，直到 join() 方法加入的 join 线程执行完为止</p>\n</li>\n<li><p><font color=\"red\">static void sleep(long millis)：</font>(指定时间:毫秒)</p>\n<ul>\n<li><blockquote>\n<p>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后 重排队。</p>\n<p>抛出InterruptedException异常</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>stop():</strong> 强制线程生命期结束，不推荐使用</p>\n</li>\n<li><p><strong>boolean isAlive()：</strong>返回boolean，判断线程是否还活着</p>\n</li>\n</ul>\n<h1 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h1><ul>\n<li><p>实现接口Runnable具有多线程能力</p>\n</li>\n<li><p>启动线程：传入目标对象+Thread对象.start()<br><font color=\"red\">推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使</font></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test1</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我在看代码！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        test1 test2=<span class=\"keyword\">new</span> <span class=\"title class_\">test1</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2).start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我在学习多线程！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"多线程并发问题\"><a href=\"#多线程并发问题\" class=\"headerlink\" title=\"多线程并发问题\"></a>多线程并发问题</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test1</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;  <span class=\"comment\">//调用Runnable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> ticketNums=<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ticketNums&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;--&gt;&quot;</span>+ticketNums--+<span class=\"string\">&quot;票&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"comment\">//获取多线程名字   Thread.currentThread().getName</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        test1 t1=<span class=\"keyword\">new</span> <span class=\"title class_\">test1</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(t1,<span class=\"string\">&quot;张三&quot;</span>).start();   <span class=\"comment\">//多线程名字</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(t1,<span class=\"string\">&quot;李四&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(t1,<span class=\"string\">&quot;黄牛&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"龟兔赛跑\"><a href=\"#龟兔赛跑\" class=\"headerlink\" title=\"龟兔赛跑\"></a>龟兔赛跑</h1></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test1</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String winner;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;  <span class=\"comment\">//模拟兔子休息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Thread.currentThread().getName().equals(<span class=\"string\">&quot;兔子&quot;</span>)&amp;&amp; i%<span class=\"number\">10</span>==<span class=\"number\">0</span>)&#123;   <span class=\"comment\">//10步睡眠停顿</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> flag=gameOver(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;--&gt;跑了&quot;</span>+i+<span class=\"string\">&quot;步&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">gameOver</span><span class=\"params\">(<span class=\"type\">int</span> steps)</span>&#123;  <span class=\"comment\">//判断是否完成比赛</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (winner!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (steps&gt;=<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                winner = Thread.currentThread().getName();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;winner is &quot;</span>+winner);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        test1 t1=<span class=\"keyword\">new</span> <span class=\"title class_\">test1</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(t1,<span class=\"string\">&quot;兔子&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(t1,<span class=\"string\">&quot;乌龟&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Callable接口-了解即可-扩充\"><a href=\"#Callable接口-了解即可-扩充\" class=\"headerlink\" title=\"Callable接口(了解即可)扩充\"></a>Callable接口(了解即可)扩充</h1><ol>\n<li><p>实现Callable接口，需要返回类型</p>\n</li>\n<li><p>重写call方法，需要抛出异常</p>\n</li>\n<li><p>创建目标对象  如：t1</p>\n</li>\n<li><p>创建执行服务：ExecutorService ser &#x3D; Executors.newFixedThreadPool(1);</p>\n</li>\n<li><p>提交执行：Future<Boolean> result1 &#x3D; ser.submit(t1);  &#x2F;&#x2F; t1为目标对象</Boolean></p>\n</li>\n<li><p>获取结果：boolean r1 &#x3D; result1.get()</p>\n</li>\n<li><p>关闭服务：ser.shutdownNow();</p>\n<p><code>演示：利用callable改造下载图片案例</code></p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.io.FileUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.testng.annotations.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/22</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">callable的好处</span></span><br><span class=\"line\"><span class=\"comment\">1. 可以定义返回值</span></span><br><span class=\"line\"><span class=\"comment\">2. 可以抛出异常</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;Boolean&gt; &#123;   <span class=\"comment\">//设置返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">test</span><span class=\"params\">(String url, String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Boolean <span class=\"title function_\">call</span><span class=\"params\">()</span>  &#123;</span><br><span class=\"line\">        webDownloader webDownloader1=<span class=\"keyword\">new</span> <span class=\"title class_\">webDownloader</span>();</span><br><span class=\"line\">        webDownloader1.downloader(url,name);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;下载了文件名为：&quot;</span>+name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        test t1=<span class=\"keyword\">new</span> <span class=\"title class_\">test</span>(<span class=\"string\">&quot;https://blog-zw.top/2022/04/30/%E5%9C%A8Linux%E9%87%8C%E5%AE%89%E8%A3%85mysql/1.png&quot;</span>,<span class=\"string\">&quot;1.jpg&quot;</span>);</span><br><span class=\"line\">        test t2=<span class=\"keyword\">new</span> <span class=\"title class_\">test</span>(<span class=\"string\">&quot;https://blog-zw.top/2022/04/30/%E5%9C%A8Linux%E9%87%8C%E5%AE%89%E8%A3%85mysql/1.png&quot;</span>,<span class=\"string\">&quot;2.jpg&quot;</span>);</span><br><span class=\"line\">        test t3=<span class=\"keyword\">new</span> <span class=\"title class_\">test</span>(<span class=\"string\">&quot;https://blog-zw.top/2022/04/30/%E5%9C%A8Linux%E9%87%8C%E5%AE%89%E8%A3%85mysql/1.png&quot;</span>,<span class=\"string\">&quot;3.jpg&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建执行服务  线程池   池子里有3个线程</span></span><br><span class=\"line\">        ExecutorService ser= Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//提交执行</span></span><br><span class=\"line\">        Future&lt;Boolean&gt; r1=ser.submit(t1);</span><br><span class=\"line\">        Future&lt;Boolean&gt; r2=ser.submit(t2);</span><br><span class=\"line\">        Future&lt;Boolean&gt; r3=ser.submit(t3);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        <span class=\"comment\">//获取结果</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> rs1=r1.get();</span><br><span class=\"line\">        <span class=\"type\">boolean</span> rs2=r2.get();</span><br><span class=\"line\">        <span class=\"type\">boolean</span> rs3=r3.get();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//打印返回结果</span></span><br><span class=\"line\">\t\tSystem.out.println(rs1);</span><br><span class=\"line\">        System.out.println(rs2);</span><br><span class=\"line\">        System.out.println(rs3);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//关闭服务</span></span><br><span class=\"line\">        ser.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">webDownloader</span>&#123;  <span class=\"comment\">//下载</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">downloader</span><span class=\"params\">(String url,String name)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                FileUtils.copyURLToFile(<span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(url),<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(name));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;io异常，downloader方法出现异常&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Lamda表达式\"><a href=\"#Lamda表达式\" class=\"headerlink\" title=\"Lamda表达式\"></a>Lamda表达式</h1><ol>\n<li><p>希腊字母表中排序第十一位的字母，英文名称为Lambda</p>\n</li>\n<li><p>避免匿名内部类定义过多</p>\n</li>\n<li><p>其实质属于函数式编程的概念</p>\n</li>\n</ol>\n<p>为什么要使用lambda表达式？</p>\n<pre><code>* 避免匿名内部类定义过多\n* 可以让你的代码看起来很简洁\n* 去掉了一堆没有意义的代码，只留下核心的逻辑。\n</code></pre>\n   <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/22</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">like2</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ilike</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lamda</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;I like lamdad-&gt;静态内部类&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ilike</span> <span class=\"variable\">like</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">like</span>();   <span class=\"comment\">//接口new 外部类</span></span><br><span class=\"line\">            like.lamda();              <span class=\"comment\">//对象调用方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">            like = <span class=\"keyword\">new</span> <span class=\"title class_\">like2</span>();         <span class=\"comment\">// 静态内部类 new 对象</span></span><br><span class=\"line\">            like.lamda();              <span class=\"comment\">// 把静态内部类，赋给like对象，就不用创建新对象了，</span></span><br><span class=\"line\">            <span class=\"comment\">// like2 zw = new like2(); // 也可以这样创建一个对象，上面的就是覆盖了对象</span></span><br><span class=\"line\">            <span class=\"comment\">// zw.lamda();</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">class</span> <span class=\"title class_\">like3</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ilike</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lamda</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;I like lamdad-&gt;局部内部类&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            like = <span class=\"keyword\">new</span> <span class=\"title class_\">like3</span>();</span><br><span class=\"line\">            like.lamda();</span><br><span class=\"line\"></span><br><span class=\"line\">            like = <span class=\"keyword\">new</span> <span class=\"title class_\">ilike</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lamda</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;I like lamdad-&gt;匿名内部类&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            like.lamda();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">ilike</span> <span class=\"variable\">zw</span> <span class=\"operator\">=</span> () -&gt; &#123;  <span class=\"comment\">// lamda表示简化</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;I like lamd-&gt;lamda表达式&quot;</span>);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            zw.lamda();</span><br><span class=\"line\"></span><br><span class=\"line\">            zw = () -&gt; &#123;        <span class=\"comment\">// 简化1：</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;I like lamdba-&gt;简化 类型 lamdab表达式，&quot;</span>);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            zw.lamda();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*zw = a -&gt; &#123;        // 简化2：  在有参数的情况下 可以简化括号</span></span><br><span class=\"line\"><span class=\"comment\">                System.out.println(&quot;I like lamdba-&gt;简化lamdba表达式&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;;*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">            zw = () -&gt;       <span class=\"comment\">// 简化3：   只有一条语句情况下可以简化花括号</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;I like lamdba-&gt;简化 类型和花括号 lamdba表达式，&quot;</span>);</span><br><span class=\"line\">            zw.lamda();</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            总结：</span></span><br><span class=\"line\"><span class=\"comment\">               1.lamdba表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹</span></span><br><span class=\"line\"><span class=\"comment\">               2. 前提是接口是函数式接口</span></span><br><span class=\"line\"><span class=\"comment\">               3. 多个参数可以去掉参数类型</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ilike</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lamda</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">like</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ilike</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lamda</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;I like lamdad-&gt;外部类&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"静态代理类\"><a href=\"#静态代理类\" class=\"headerlink\" title=\"静态代理类\"></a>静态代理类</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    静态代理模式总结：</span></span><br><span class=\"line\"><span class=\"comment\">    真实对象和代理对象都要实现同一个接口</span></span><br><span class=\"line\"><span class=\"comment\">    代理对象要代理真实的角色</span></span><br><span class=\"line\"><span class=\"comment\">    好处：</span></span><br><span class=\"line\"><span class=\"comment\">    代理对象可以做很多真实对象做不了的事情(也就布置现场和结婚)</span></span><br><span class=\"line\"><span class=\"comment\">    真实对象专注做自己的事情</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    这句话说出来就明白了：婚礼公司相当于thread，结婚的人相当于实现runnable接口的类。</span></span><br><span class=\"line\"><span class=\"comment\">    用thread代替接口实现类做一些东西。</span></span><br><span class=\"line\"><span class=\"comment\">    就是把Thread作为代理类使用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">jintaidaili</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        You you=<span class=\"keyword\">new</span> <span class=\"title class_\">You</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;System.out.println(<span class=\"string\">&quot;我爱你&quot;</span>);&#125;).start();   <span class=\"comment\">//Lamdba表达式</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">WedddingCompany</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">You</span>()).HappyMarry();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">WedddingCompany</span> <span class=\"variable\">wedddingCompany</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WedddingCompany</span>(you);</span><br><span class=\"line\">        wedddingCompany.HappyMarry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数式接口，结婚</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span>  <span class=\"title class_\">Marry</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">HappyMarry</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//真实角色，你去结婚</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">You</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Marry</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">HappyMarry</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;zw要结婚了，超开心！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//代理角色,帮助你结婚</span></span><br><span class=\"line\"><span class=\"comment\">//传入一个对象进行结婚</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WedddingCompany</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Marry</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//代理谁-》真实角色</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  Marry target;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">WedddingCompany</span><span class=\"params\">(Marry target)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target=target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">HappyMarry</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        before();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target.HappyMarry();  <span class=\"comment\">//这就是真实对象</span></span><br><span class=\"line\">        after();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">after</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;结婚之后，收尾款&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;结婚之前,布置现场&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h1><h2 id=\"线程方法\"><a href=\"#线程方法\" class=\"headerlink\" title=\"线程方法\"></a>线程方法</h2><table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">setPriority(int newPriority)</td>\n<td align=\"left\">更改线程的优先级</td>\n</tr>\n<tr>\n<td align=\"left\">static void sleep(long millis)</td>\n<td align=\"left\">在指定的毫秒数内让当前正在执行的线程休眠</td>\n</tr>\n<tr>\n<td align=\"left\">void join()</td>\n<td align=\"left\">等待该线程终止</td>\n</tr>\n<tr>\n<td align=\"left\">static void yield()</td>\n<td align=\"left\">暂停当前正在执行的线程对象，并执行其他线程 (礼让)</td>\n</tr>\n<tr>\n<td align=\"left\">void interrupt()</td>\n<td align=\"left\">中断线程，别用这个方式</td>\n</tr>\n<tr>\n<td align=\"left\">boolean isAive()</td>\n<td align=\"left\">测试线程是否处于活动状态</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test2</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.线程中定义线程体使用的标识</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (flag)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;run....Thread&quot;</span>+i++);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//2.线程体使用该标识</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//3.设置一个公开的方法停止线程，转标识位</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">test2</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">test2</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(t1).start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;main&quot;</span>+i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==<span class=\"number\">900</span>)&#123;</span><br><span class=\"line\">                t1.stop();   <span class=\"comment\">//停止子线程</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;线程该停止了&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐线程自己停下来</p>\n<p>建议使用一个标志位进行终止变量当 flag&#x3D;false,则终止线程运行</p>\n<p>以上代码停止的是子线程</p>\n<h1 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h1><p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类 及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的<strong>五种状态</strong>：</p>\n<ul>\n<li><font color=\"red\">新建：</font>当一个<strong>Thread</strong>类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>\n<li><font color=\"red\">就绪：</font>处于新建状态的线程被<strong>start()<strong>后，将进入线程队列等待</strong>CPU</strong>时间片，此时它已 具备了运行的条件，只是没分配到CPU资源</li>\n<li><font color=\"red\">运行：</font>当就绪的线程被调度并获得<strong>CPU</strong>资源时,便进入运行状态， **run()**方法定义了线 程的操作和功能</li>\n<li><font color=\"red\">阻塞：</font>在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 <strong>CPU</strong> 并临时中 止自己的执行，进入阻塞状态</li>\n<li><font color=\"red\">死亡：</font> 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>\n</ul>\n<h1 id=\"线程休眠-sleep\"><a href=\"#线程休眠-sleep\" class=\"headerlink\" title=\"线程休眠_sleep\"></a>线程休眠_sleep</h1><p>Thread.sleep(1000);</p>\n<ul>\n<li>sleep(时间)指定当前线程阻塞的毫秒数；</li>\n<li>sleep存在异常interruptedException;   &#x2F;&#x2F;需要抛出</li>\n<li>sleep时间到达后线程进入就绪状态；</li>\n<li>sleep可以模拟网络延时，倒计时等。</li>\n<li>每个对象都有一个锁,sleep不会释放锁；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.SimpleDateFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">duoxiancDaojishi</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//模拟倒计时</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tenDown</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            System.out.println(num--);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打印当前系统时间，前一秒</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Date</span> <span class=\"variable\">starTime</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(System.currentTimeMillis());</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;HH:mm:ss&quot;</span>).format(starTime));</span><br><span class=\"line\">                starTime = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(System.currentTimeMillis());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"线程礼让\"><a href=\"#线程礼让\" class=\"headerlink\" title=\"线程礼让\"></a>线程礼让</h1><p>Thread.yield();   </p>\n<ul>\n<li><p>礼让线程，让当前正在执行的线程暂停，但不堵塞</p>\n</li>\n<li><p>将线程从运行状态转为就绪状态</p>\n</li>\n<li><p>让cpu重新调度，礼让不一定成功！看cpu心情</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/27</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">duoxiancYieid</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MyYield</span> <span class=\"variable\">myYield</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyYield</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(myYield,<span class=\"string\">&quot;a&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(myYield,<span class=\"string\">&quot;b&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyYield</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;线程开始执行&quot;</span>);</span><br><span class=\"line\">        Thread.yield();    <span class=\"comment\">//礼让   (不一定成功)</span></span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;线程停止执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从运行到就绪状态，就是礼让，还是有抢夺CPU资源的机会的</p>\n</li>\n</ul>\n<h1 id=\"Join\"><a href=\"#Join\" class=\"headerlink\" title=\"Join\"></a>Join</h1><p>​    thread.join()   </p>\n<ul>\n<li>Join合并线程，待线程执行完成后，再执行其他线程，其他线程阻塞</li>\n<li>可以想象成插队</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/27</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//测试Join方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">duoxiancJoin</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程vip来了&quot;</span>+i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">duoxiancJoin</span> <span class=\"variable\">testJoin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">duoxiancJoin</span>();</span><br><span class=\"line\">        Thread thread= <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(testJoin);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//start()要放到if里面，不然在主线程启动时，vip线程也在执行中</span></span><br><span class=\"line\">                thread.start();</span><br><span class=\"line\">                thread.join();   <span class=\"comment\">//插队</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;main&quot;</span>+i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"线程状态观测\"><a href=\"#线程状态观测\" class=\"headerlink\" title=\"线程状态观测\"></a>线程状态观测</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">thread.getState()   线程状态观测</span><br><span class=\"line\"></span><br><span class=\"line\">枚举 Thread.State</span><br><span class=\"line\">线程状态。线程可以处于下列状态之一： </span><br><span class=\"line\"></span><br><span class=\"line\">NEW</span><br><span class=\"line\">至今尚未启动的线程处于这种状态。 </span><br><span class=\"line\">RUNNABLE</span><br><span class=\"line\">正在 Java 虚拟机中执行的线程处于这种状态。 </span><br><span class=\"line\">BLOCKED</span><br><span class=\"line\">受阻塞并等待某个监视器锁的线程处于这种状态。 </span><br><span class=\"line\">WAITING</span><br><span class=\"line\">无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。 </span><br><span class=\"line\">TIMED_WAITING</span><br><span class=\"line\">等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。 </span><br><span class=\"line\">TERMINATED</span><br><span class=\"line\">已退出的线程处于这种状态。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">duoxiancState</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">     Thread thread= <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                 Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">             &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                 e.printStackTrace();</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;////////&quot;</span>);    <span class=\"comment\">//结束打印</span></span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//观察状态</span></span><br><span class=\"line\">        Thread.<span class=\"type\">State</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> thread.getState();</span><br><span class=\"line\">        System.out.println(state);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//观察启动后</span></span><br><span class=\"line\">        thread.start();   <span class=\"comment\">//启动</span></span><br><span class=\"line\">        state=thread.getState();</span><br><span class=\"line\">        System.out.println(state);  <span class=\"comment\">//Run</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (state!=Thread.State.TERMINATED)&#123;   <span class=\"comment\">//只要线程不终止</span></span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">100</span>);    <span class=\"comment\">//100毫秒刷新</span></span><br><span class=\"line\">            state=thread.getState();   <span class=\"comment\">//更新状态</span></span><br><span class=\"line\">            System.out.println(state);   <span class=\"comment\">//输出状态</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//线程中断或者结束，一旦进入死亡状态，就不能再次启动</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/03/31/java-duo-xian-cheng/1.png\"></p>\n<h1 id=\"线程的优先级\"><a href=\"#线程的优先级\" class=\"headerlink\" title=\"线程的优先级\"></a>线程的优先级</h1><ul>\n<li><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</p>\n</li>\n<li><p>线程的优先级用数字表示，范围从1~10.</p>\n<ol>\n<li>Thread.MIN_PRIORITY &#x3D; 1;</li>\n<li>Thread.MAX_PRIOPITY &#x3D; 10;</li>\n<li>Thread.NORM_PRIOPITY &#x3D; 5;</li>\n</ol>\n</li>\n<li><p>使用以下方式改变或获取优先级</p>\n<ul>\n<li>getPriority.setPriority(int XXX)</li>\n</ul>\n<p><code>优先级的设定建议在start()调度前</code></p>\n<p><code>优先级低只是意味着调度的概率低.并不是优先级低就不会调用了.这都是看CPU的调度</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/29</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">duoxiancYouxianji</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//getPriority  返回线程的优先级</span></span><br><span class=\"line\">        <span class=\"comment\">//setPriority  更改线程的优先级</span></span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority()); <span class=\"comment\">//主线程main的优先级</span></span><br><span class=\"line\">        <span class=\"type\">Mypriority</span> <span class=\"variable\">mypriority</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Mypriority</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(mypriority);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(mypriority);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(mypriority);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(mypriority);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(mypriority);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t6</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(mypriority);</span><br><span class=\"line\"></span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        t2.setPriority(<span class=\"number\">1</span>);    <span class=\"comment\">//更改线程优先级</span></span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        t3.setPriority(<span class=\"number\">4</span>);</span><br><span class=\"line\">        t3.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        t4.setPriority(Thread.MAX_PRIORITY);</span><br><span class=\"line\">        t4.start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        t5.setPriority(-1);      //报错</span></span><br><span class=\"line\"><span class=\"comment\">//        t5.start();</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        t6.setPriority(11);    //报错    默认线程是  5   0-10   10为最高级</span></span><br><span class=\"line\"><span class=\"comment\">//        t6.start();、</span></span><br><span class=\"line\">        <span class=\"comment\">//     优先级低只是意味着调度的概率低.并不是优先级低就不会调用了.这都是看CPU的调度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span>  <span class=\"title class_\">Mypriority</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h1><ul>\n<li>默认是false表示用户线程，正常的线程都是用户线程</li>\n<li>线程分为<font color=\"red\">用户线程</font>和<font color=\"red\">守护线程</font></li>\n<li>虚拟机必须确保用户线程执行完毕</li>\n<li>虚拟机不用等待守护线程执行完毕</li>\n<li>如：后台记录操作日志，监控内存，垃圾回收等待..</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> duoxianc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/29</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">duoxiancShouhu</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">God</span> <span class=\"variable\">god</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">God</span>();</span><br><span class=\"line\">        youI you= <span class=\"keyword\">new</span> <span class=\"title class_\">youI</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(god);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"literal\">true</span>);  <span class=\"comment\">//默认是false表示用户线程，正常的线程都是用户线程</span></span><br><span class=\"line\"></span><br><span class=\"line\">        thread.start();     <span class=\"comment\">//守护线程启动</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(you).start();   <span class=\"comment\">//你启动</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">God</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//守护线程 守护着你</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;上帝保佑着你&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">youI</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;你一生都开心的活着&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;-====goofbye! world&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"线程同步机制（重点）\"><a href=\"#线程同步机制（重点）\" class=\"headerlink\" title=\"线程同步机制（重点）\"></a>线程同步机制（重点）</h1></li>\n<li><p>处理多线程问题时，<font color=\"red\">多个线程访问同一个对象(并发)</font>，并且某些线程还想修改这个对象，这个时候我们就需要线程同步. <font color=\"red\">线程同步其实就是一种等待</font>，多个需要同时访问此对象的线程进入<font color=\"red\">这个对象的等待池</font>形成队列，等待前面线程使用完毕，下一个线程再使用。</p>\n</li>\n<li><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入<font color=\"red\">锁机制synchronized</font>,当一个线程获得对象的排它锁，独占资源，其他线程必须等待</p>\n</li>\n<li><p>一个线程持有锁会导致其他所有需要此锁的线程挂起</p>\n</li>\n<li><p>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题</p>\n</li>\n<li><p>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题</p>\n<p><code>形成条件：队列+锁</code></p>\n</li>\n</ul>\n<h1 id=\"三大不安全案例\"><a href=\"#三大不安全案例\" class=\"headerlink\" title=\"三大不安全案例\"></a>三大不安全案例</h1><h2 id=\"买票\"><a href=\"#买票\" class=\"headerlink\" title=\"买票\"></a>买票</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/29</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: syn</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不安全的买票</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UnBuyTicket</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">BuyTicket</span> <span class=\"variable\">station</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">BuyTicket</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(station,<span class=\"string\">&quot;zw&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(station,<span class=\"string\">&quot;lwx&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(station,<span class=\"string\">&quot;黄牛党&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BuyTicket</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">ticketNum</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span><span class=\"literal\">true</span>;   <span class=\"comment\">//外部停止方式</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//买票</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (flag)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                buy();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ticketNum&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;拿到&quot;</span>+ticketNum--);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"取钱\"><a href=\"#取钱\" class=\"headerlink\" title=\"取钱\"></a>取钱</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不安全的取钱</span></span><br><span class=\"line\"><span class=\"comment\">//两个人去银行取钱</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UNsafeBank</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Account</span> <span class=\"variable\">account</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Account</span>(<span class=\"number\">100</span>,<span class=\"string\">&quot;基金&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Drawing</span> <span class=\"variable\">zw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Drawing</span>(account,<span class=\"number\">50</span>,<span class=\"string\">&quot;你&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Drawing</span> <span class=\"variable\">lwx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Drawing</span>(account,<span class=\"number\">100</span>,<span class=\"string\">&quot;girlFriend&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        zw.start();</span><br><span class=\"line\">        lwx.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//账户</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Account</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> money;   <span class=\"comment\">//余额</span></span><br><span class=\"line\">    String name;  <span class=\"comment\">//卡名</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Account</span><span class=\"params\">(<span class=\"type\">int</span> money, String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.money = money;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//银行</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Drawing</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Account account;  <span class=\"comment\">//账户</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> drawingMoney;   <span class=\"comment\">//取了多少钱</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> nowMoney;   <span class=\"comment\">//现在手里有多少钱</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Drawing</span><span class=\"params\">(Account account,<span class=\"type\">int</span> drawingMoney,String name)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);   <span class=\"comment\">//把取钱的名字，调给父类 Thread  相当于给线程取名字</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.account=account;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.drawingMoney=drawingMoney;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//取钱</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (account.money-drawingMoney&lt;<span class=\"number\">0</span>)&#123;    <span class=\"comment\">//账户的钱 减去 取的钱</span></span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;钱不够取不了&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//sleep可以放大问题的发生性</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);     <span class=\"comment\">//延时 1秒</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//卡内余额= 余额 -你取的钱</span></span><br><span class=\"line\">        account.money=account.money-drawingMoney;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//你手里的钱</span></span><br><span class=\"line\">        nowMoney=nowMoney+drawingMoney;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(account.name+<span class=\"string\">&quot;余额为：&quot;</span>+account.money);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//继承 Thread 调用.this 也就相当于  Thread.currentThread().getName();</span></span><br><span class=\"line\">        System.out.println(<span class=\"built_in\">this</span>.getName()+<span class=\"string\">&quot;手里的钱：&quot;</span>+nowMoney);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程不安全\"><a href=\"#线程不安全\" class=\"headerlink\" title=\"线程不安全\"></a>线程不安全</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/29</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: syn</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线程不安全的集合</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UnsafeList</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();   <span class=\"comment\">//ArrayList 线程不安全</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                list.add(Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//原因比如说：两个线程同一瞬间，操作了同一个位置，把两个数组添加到了同一个位置，就把它覆盖掉了，然后元素就会少</span></span><br><span class=\"line\">        <span class=\"comment\">//少的元素就是这么来的</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">3000</span>);   <span class=\"comment\">//等待结果，休眠等待线程跑完</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(list.size());   <span class=\"comment\">//</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"同步方法和同步块\"><a href=\"#同步方法和同步块\" class=\"headerlink\" title=\"同步方法和同步块\"></a>同步方法和同步块</h1><p><code>锁的对象就是变化的量，需要增删改的对象</code></p>\n<h2 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h2><ul>\n<li><p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需<br>要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：<br>synchronized方法和synchronized块</p>\n<ul>\n<li><blockquote>\n<p>同步方法：public synchronized void method(int args){}</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>synchronized)方法控制对 “对像”的访问，每个对象对应一把锁，每个<br>synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞<br>方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获<br>得这个锁，继续执行</p>\n<ul>\n<li><blockquote>\n<p>缺陷：若将一个大的方法声明为synchronized将会影响效率</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>方法里面需要修改的内容才需要锁，锁的太多，浪费资源</p>\n</li>\n</ul>\n<h2 id=\"同步块\"><a href=\"#同步块\" class=\"headerlink\" title=\"同步块\"></a>同步块</h2><ul>\n<li><p>同步块：synchronized<font color=\"red\">(Obj){}</font></p>\n</li>\n<li><p><font color=\"red\">Obj </font>称为<strong>同步监视器</strong></p>\n<ul>\n<li>Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器</li>\n<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this,就是这个对象本身，或者是 class</li>\n</ul>\n</li>\n<li><p>同步监视器的执行过程</p>\n<ol>\n<li><p>第一个线程访问，锁定同步监视器，执行其中代码.</p>\n</li>\n<li><p>第二个线程访问，发现同步监视器被锁定，无法访问.</p>\n</li>\n<li><p>第一个线程访问完毕,解锁同步监视器.</p>\n</li>\n<li><p>第二个线程访问.发现同步监视器没有锁，然后锁定并访问</p>\n</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///////////////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">//不安全的买票</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;   <span class=\"comment\">//同步方法  锁的 this</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ticketNum&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;拿到&quot;</span>+ticketNum--);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//////////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">//取钱</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (account)&#123;   <span class=\"comment\">//把账户锁了  哪个类的属性发生变化，就锁哪个类</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (account.money-drawingMoney&lt;<span class=\"number\">0</span>)&#123;    <span class=\"comment\">//账户的钱 减去 取的钱</span></span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;钱不够取不了&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//sleep可以放大问题的发生性</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);     <span class=\"comment\">//延时 1秒</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//卡内余额= 余额 -你取的钱</span></span><br><span class=\"line\">            account.money=account.money-drawingMoney;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//你手里的钱</span></span><br><span class=\"line\">            nowMoney=nowMoney+drawingMoney;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(account.name+<span class=\"string\">&quot;余额为：&quot;</span>+account.money);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//继承 Thread 调用.this 也就相当于  Thread.currentThread().getName();</span></span><br><span class=\"line\">            System.out.println(<span class=\"built_in\">this</span>.getName()+<span class=\"string\">&quot;手里的钱：&quot;</span>+nowMoney);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//////////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">//线程不安全的集合</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UnsafeList</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();   <span class=\"comment\">//ArrayList 线程不安全</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (list)&#123;</span><br><span class=\"line\">                    list.add(Thread.currentThread().getName());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//原因比如说：两个线程同一瞬间，操作了同一个位置，把两个数组添加到了同一个位置，就把它覆盖掉了，然后元素就会少</span></span><br><span class=\"line\">        <span class=\"comment\">//少的元素就是这么来的</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);   <span class=\"comment\">//等待结果，休眠等待线程跑完   加上同步块，必须sleep，要不然主线程会先输出</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(list.size());   <span class=\"comment\">//</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而<br>导致两个或者多个线程都在等待对方释放资源，都停止执行的情形.某一个同步块<br>同时拥有“<font color=\"red\">两个以上对象的锁</font>”时，就可能会发生“死锁”的问题。</p>\n<ul>\n<li>产生死锁的四个必要条件：<ol>\n<li>互斥条件：一个资源每次只能被一个进程使用。</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>\n</ol>\n</li>\n<li><strong>上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件</strong><br><strong>就可以避免死锁发生</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/30</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: Lock</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        a a1=<span class=\"keyword\">new</span> <span class=\"title class_\">a</span>(<span class=\"number\">0</span>,<span class=\"string\">&quot;lwx&quot;</span>);</span><br><span class=\"line\">        a a2=<span class=\"keyword\">new</span> <span class=\"title class_\">a</span>(<span class=\"number\">1</span>,<span class=\"string\">&quot;zw&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        a1.start();</span><br><span class=\"line\">        a2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Zw</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lwx</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">a</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            activity();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Zw zw= <span class=\"keyword\">new</span> <span class=\"title class_\">Zw</span>();</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"type\">Lwx</span> <span class=\"variable\">lwx</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Lwx</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> num;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">a</span><span class=\"params\">(<span class=\"type\">int</span> num, String name)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.num = num;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">activity</span><span class=\"params\">()</span>&#123;   <span class=\"comment\">//死锁</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (zw)&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"built_in\">this</span>.name+<span class=\"string\">&quot;吃饭&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (lwx)&#123;    <span class=\"comment\">// 放到 if 外面就不会出现死锁</span></span><br><span class=\"line\">                        System.out.println(<span class=\"built_in\">this</span>.name+<span class=\"string\">&quot;打游戏&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lwx)&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"built_in\">this</span>.name+<span class=\"string\">&quot;打游戏&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (zw)&#123;     <span class=\"comment\">//放到 if 外面就不会出现死锁</span></span><br><span class=\"line\">                        System.out.println(<span class=\"built_in\">this</span>.name+<span class=\"string\">&quot;吃饭&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"lock锁\"><a href=\"#lock锁\" class=\"headerlink\" title=\"lock锁\"></a>lock锁</h1><ul>\n<li>从JDK5.0开始，Java提供了更强大的线程同步机制一一通过显式定义同步锁对<br>象来实现同步。同步锁使用L0ck对象充当</li>\n<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。<br>锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开<br>始访问共享资源之前应先获得Lock对象</li>\n<li>ReentrantLock类实现了Lock,它拥有与synchronized相同的并发性和内存语<br>义，在实现线程安全的控制中，比较常用的是ReentrantLock,可以显式加锁、释<br>放锁。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        lock.lock();   <span class=\"comment\">//加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//保证线程安全的代码</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();  <span class=\"comment\">//解锁</span></span><br><span class=\"line\">            <span class=\"comment\">//如果同步代码有异常，要将unlock()写入finally语句块</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/30</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: Lock</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        TestLock2 a1=<span class=\"keyword\">new</span> <span class=\"title class_\">TestLock2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(a1).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(a1).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestLock2</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ticket</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        buy();   <span class=\"comment\">//调用buy方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buy</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock.lock();   <span class=\"comment\">//加锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ticket &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    System.out.println(ticket--);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">finally</span>&#123;  <span class=\"comment\">//如果同步代码有异常，要将unlock()写入finally语句块</span></span><br><span class=\"line\">                lock.unlock();   <span class=\"comment\">//解锁</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"synchriized-与-Lock-的对比\"><a href=\"#synchriized-与-Lock-的对比\" class=\"headerlink\" title=\"synchriized 与 Lock 的对比\"></a>synchriized 与 Lock 的对比</h1><ul>\n<li><strong>Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)synchronized是隐式锁，出了</strong><br><strong>作用域自动释放</strong></li>\n<li><strong>Lock只有代码块锁，synchronized有代码块锁和方法锁</strong></li>\n<li><strong>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展</strong><br><strong>性（提供更多的子类）</strong></li>\n<li><strong>优先使用顺序：</strong><ul>\n<li><strong>Lock&gt;同步代码块(已经进入了方法体，分配了相应资源)&gt;同步方法（在方</strong><br><strong>法体之外）</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"线程协作\"><a href=\"#线程协作\" class=\"headerlink\" title=\"线程协作\"></a>线程协作</h1><h2 id=\"生产者消费者模式\"><a href=\"#生产者消费者模式\" class=\"headerlink\" title=\"生产者消费者模式\"></a>生产者消费者模式</h2><h3 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h3><p>应用场景：生产者和消费者问题</p>\n<ul>\n<li>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将<br>仓库中产品取走消费.</li>\n<li>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到<br>仓库中的产品被消费者取走为止.</li>\n<li>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，<br>直到仓库中再次放入产品为止.</li>\n</ul>\n<h3 id=\"线程通信-分析\"><a href=\"#线程通信-分析\" class=\"headerlink\" title=\"线程通信-分析\"></a>线程通信-分析</h3><p><strong>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之</strong><br><strong>间相互依赖，互为条件。</strong></p>\n<ul>\n<li>对于生产者，没有生产，产品之前，要通知消费者等待。而生产了产品之后，又<br>需要马上通知消费者消费</li>\n<li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品<br>以供消费。</li>\n<li>在生产者消费者问题中，仅有synchronized,是不够的<ul>\n<li>synchronized可阻止并发更新同一个共享资源，实现了同步</li>\n<li>synchronized不能用来实现不同线程之间的消息传递（通信）</li>\n</ul>\n</li>\n<li><strong>java提供了几个方法解决线程之间的通信问题</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>wait()</td>\n<td>表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</td>\n</tr>\n<tr>\n<td>wait(long timeout)</td>\n<td>指定等待的毫秒数</td>\n</tr>\n<tr>\n<td>notify()</td>\n<td>唤醒一个处于等待状态的线程</td>\n</tr>\n<tr>\n<td>notifyAll()</td>\n<td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td>\n</tr>\n</tbody></table>\n<p><font color=\"red\">注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常lllegalMonitorStateException</font></p>\n<h3 id=\"解决方式-1\"><a href=\"#解决方式-1\" class=\"headerlink\" title=\"解决方式 1\"></a>解决方式 1</h3><p>并发协作模型”生产者&#x2F;消费者模式“–&gt;管程法</p>\n<ul>\n<li>生产者：负责生产数据的模块(可能是方法，对象，线程，进程);</li>\n<li>消费者：负责处理数据的模块(可能是方法，对象，线程，进程)；</li>\n<li>缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区</li>\n</ul>\n<p><strong>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/30</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试：生产者消费者模型--&gt;利用缓冲区解决：管程法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//生产者 ，消费者，产品，缓冲区</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestPC</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">synContainer</span> <span class=\"variable\">container</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">synContainer</span>();  <span class=\"comment\">//缓存区</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Productor</span>(container).start();     <span class=\"comment\">//启动生产者</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>(container).start();      <span class=\"comment\">//消费者</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//生产者</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Productor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">    synContainer container;          <span class=\"comment\">//传入缓冲区对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Productor</span><span class=\"params\">(synContainer container)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.container=container;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            container.push(<span class=\"keyword\">new</span> <span class=\"title class_\">Cicken</span>(i));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产了&quot;</span>+i+<span class=\"string\">&quot;只鸡&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//消费者</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">    synContainer container;       <span class=\"comment\">//传入缓冲区对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Consumer</span><span class=\"params\">(synContainer container)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.container=container;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费了--&gt;&quot;</span>+container.pop().id+<span class=\"string\">&quot;只鸡&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//产品</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>  <span class=\"title class_\">Cicken</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;  <span class=\"comment\">//产品编号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Cicken</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缓冲区</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>  <span class=\"title class_\">synContainer</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//产品容器</span></span><br><span class=\"line\">    Cicken[] cickens =<span class=\"keyword\">new</span> <span class=\"title class_\">Cicken</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//生产者放入</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">synchronized</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(Cicken cicken)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count==<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//通知消费者消费  等待</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果没有满，我们就需要丢入产品</span></span><br><span class=\"line\">        cickens[count]=cicken;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.notify();</span><br><span class=\"line\">        <span class=\"comment\">//可以通知消费者消费了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Cicken <span class=\"title function_\">pop</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (count==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//等待生产者生产，消费者等待</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果可以消费</span></span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        Cicken chicken=cickens[count];</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.notify();</span><br><span class=\"line\">        <span class=\"comment\">//吃完了，通知生产者生产</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> chicken;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//消费者消费产品</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解决方式-2\"><a href=\"#解决方式-2\" class=\"headerlink\" title=\"解决方式 2\"></a>解决方式 2</h3><p>并发协作模型”生产者&#x2F;消费者模式“–&gt;信号灯</p>\n<p>利用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h3 id=\"使用线程池\"><a href=\"#使用线程池\" class=\"headerlink\" title=\"使用线程池\"></a>使用线程池</h3>","categories":["Java"],"tags":["Java"]},{"title":"Java容易忘记的","url":"/2022/04/16/java-rong-yi-wang-ji-de/","content":"<h3 id=\"什么是继承\"><a href=\"#什么是继承\" class=\"headerlink\" title=\"什么是继承:\"></a>什么是继承:</h3><p>将具有<code>相同属性</code>和<code>方法</code>的类中相同属性和方法提取出，构建一个新类，这个新类就是父类，<code>然后由父类再构建子类，子类继承父类的属性和方法，使得子类对象具有父类的特征和行为</code></p>\n<hr>\n<h2 id=\"类变量、类方法与static关键字\"><a href=\"#类变量、类方法与static关键字\" class=\"headerlink\" title=\"类变量、类方法与static关键字:\"></a>类变量、类方法与static关键字:</h2><blockquote>\n<p>static修饰的变量和方法可以通过类名和对象名访问，<code>而不用static修饰的变量和方法只能通过对象名访问。</code></p>\n</blockquote>\n<ul>\n<li>类变量或静态常量：static修饰的属性称为类属性（类变量）<br>如：<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">zhangshan</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br><span class=\"line\">        Student.play();   <span class=\"comment\">//类的属性 直接用类名调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">play</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;打游戏&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"方法名的重载和重写\"><a href=\"#方法名的重载和重写\" class=\"headerlink\" title=\"方法名的重载和重写\"></a>方法名的重载和重写</h2><h3 id=\"方法的重载：指同一个类中多个方法：\"><a href=\"#方法的重载：指同一个类中多个方法：\" class=\"headerlink\" title=\"方法的重载：指同一个类中多个方法：\"></a>方法的重载：指同一个类中多个方法：</h3><ul>\n<li><blockquote>\n<p>方法名相同</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>参数列表不同（个数、顺序、类型三者只要有一项不同）</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>与返回值、访问修饰符无关</p>\n</blockquote>\n</li>\n</ul>\n<p><code>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</code></p>\n<h2 id=\"综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。\"><a href=\"#综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。\" class=\"headerlink\" title=\"综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。\"></a>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</h2><h2 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写:\"></a>重写:</h2><ol>\n<li><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>\n</li>\n<li><p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>\n</li>\n<li><p>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。<br>构造方法无法被重写</p>\n<h2 id=\"综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。\"><a href=\"#综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。\" class=\"headerlink\" title=\"综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。\"></a>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</h2></li>\n</ol>\n<h2 id=\"重载和重写的区别\"><a href=\"#重载和重写的区别\" class=\"headerlink\" title=\"重载和重写的区别\"></a>重载和重写的区别</h2><ul>\n<li><blockquote>\n<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>\n</blockquote>\n<h3 id=\"方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂-Java-讲义》-）：\"><a href=\"#方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂-Java-讲义》-）：\" class=\"headerlink\" title=\"方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》 ）：\"></a><strong>方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》 ）：</strong></h3></li>\n<li><p>“两同”即方法名相同、形参列表相同；</p>\n</li>\n<li><p>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</p>\n</li>\n<li><p>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</p>\n</li>\n<li><blockquote>\n<p>关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"extends关键字\"><a href=\"#extends关键字\" class=\"headerlink\" title=\"extends关键字\"></a><strong>extends关键字</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Pet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name; <span class=\"comment\">//昵称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> health;  <span class=\"comment\">//健康值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> love;    <span class=\"comment\">//亲密值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name+<span class=\"string\">&#x27;，&#x27;</span>+health+<span class=\"string\">&#x27;,&#x27;</span>+love;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Penguin</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Pet</span> &#123;   <span class=\"comment\">//extends 继承关键字</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">nale</span> <span class=\"operator\">=</span><span class=\"string\">&quot;Q仔&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">fenale</span> <span class=\"operator\">=</span><span class=\"string\">&quot;Q妹&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>有些父类成员不能继承：</strong></p>\n<ul>\n<li><code>private成员</code> </li>\n<li><code>子类与父类不在同包，使用默认访问权限的成员</code></li>\n<li><code>构造方法</code></li>\n</ul>\n<p><strong>继承特性：</strong></p>\n<ul>\n<li>传递性:B类继承A类，C类继承B类，C类也继承A类的属性和方法。</li>\n<li>单根性，一个子类只能继承一个父类。</li>\n</ul>\n<hr>\n<h2 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a><strong>super关键字</strong></h2><p>子类访问父类的成员使用super。</p>\n<ul>\n<li><code>super():调用父类的构造方法。</code></li>\n<li><code>super.name:访问父类的属性。</code></li>\n<li><code>super.toString():访问父类的方法</code></li>\n</ul>\n<hr>\n<h2 id=\"方法的重写\"><a href=\"#方法的重写\" class=\"headerlink\" title=\"方法的重写\"></a><strong>方法的重写</strong></h2><p>在继承关系中，子类会自动继承父类中定义的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。</p>\n<ul>\n<li>子类方法与父类方法具有相同的名字。</li>\n<li>参数列表与父类方法相同。</li>\n<li>返回值类型与父类方法相同。</li>\n<li>子类方法访问权限不能比父类更严格。</li>\n<li>抛出的异常<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Penguin</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Pet</span> &#123;  <span class=\"comment\">//Penguin子类重写toString()</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">nale</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Q仔&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">fenale</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Q妹&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String sex;   <span class=\"comment\">//性别</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span>&#123;   <span class=\"comment\">//Penguin子类重写toString()</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.toString(); <span class=\"comment\">//toString():访问父类的方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> info+<span class=\"string\">&quot;,&quot;</span>+sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"抽象类、抽象方法和abstract关键字\"><a href=\"#抽象类、抽象方法和abstract关键字\" class=\"headerlink\" title=\"抽象类、抽象方法和abstract关键字\"></a><strong>抽象类、抽象方法和abstract关键字</strong></h2><h3 id=\"1-抽象类\"><a href=\"#1-抽象类\" class=\"headerlink\" title=\"1. 抽象类\"></a>1. 抽象类</h3><ul>\n<li>在继承关系中，去实例化一个父类没有意义，<code>它的特征和方法无法确定，可以使用抽象类来限制父类被实例化，抽象类是不能被实例化的。</code><br>如：<blockquote>\n<p>Pet ww &#x3D; new Pet(); &#x2F;&#x2F;实例化父类没有意义</p>\n</blockquote>\n</li>\n<li>抽象类用关键字abstract来修饰。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Pet</span> &#123;   <span class=\"comment\">//抽象类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name; <span class=\"comment\">//昵称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> health;  <span class=\"comment\">//健康值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> love;    <span class=\"comment\">//亲密值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Penguin</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Pet</span> &#123;  <span class=\"comment\">//企鹅类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Pet</span> <span class=\"variable\">ww</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Pet</span>();   <span class=\"comment\">//语法错误，抽象类无法实例化</span></span><br><span class=\"line\">    <span class=\"type\">Pet</span> <span class=\"variable\">zw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Penguin</span>(); <span class=\"comment\">//正确</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-抽象方法\"><a href=\"#2-抽象方法\" class=\"headerlink\" title=\"2. 抽象方法\"></a>2. 抽象方法</h3>父类的play方法，<code>每个子类实现步骤都不一样，即方法体没有实际意义的语句</code>，像这样的方法可以写成抽象方法。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Penguin</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Pet</span> &#123;  <span class=\"comment\">//子类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">play</span><span class=\"params\">()</span>&#123; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Pet</span> &#123;   <span class=\"comment\">//父类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">play</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><code>抽象方法用abstract关键字修饰。</code></li>\n<li><code>抽象方法没有方法体。</code></li>\n<li><code>抽象方法必须在抽象类里。</code></li>\n<li><code>抽象方法必须在子类中被实现。</code></li>\n</ul>\n<hr>\n<h2 id=\"final关键字\"><a href=\"#final关键字\" class=\"headerlink\" title=\"final关键字\"></a><strong>final关键字</strong></h2><p><code>final关键字修饰的变量的值是最终的值，即不能修改它的值—常量。</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">nale</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Q仔&quot;</span>;   <span class=\"comment\">//final 修饰变量的最终值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">fenale</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Q妹&quot;</span>;  <span class=\"comment\">//final 修饰变量的最终值</span></span><br></pre></td></tr></table></figure>\n<p><code>final关键字修饰的类为最终的子类—不能被继承。</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Penguin</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Pet</span>  &#123;   <span class=\"comment\">//最终只类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>1、final修饰的类不可以被继承，但可以继承其他的类。</p>\n<p>2、final修饰的方法子类可以继承但是不能重写。</p>\n<p>3、子类重写父类的非final方法可以加上final。</p>\n<p>4、被final修饰的基本数据类型的变量可以看作是常量，赋值后不能改变。</p>\n<p>5、被final修饰的引用数据类型变量的引用内存地址值不能改变，可以改变引用数据类型变量的属性值。</p>\n<p>6、被final修饰的成员变量必须在对象创建完成前进行赋值，可以直接赋值，如果没有直接赋值则需要用构造方法进行赋值，如果有多个构造方法则多个构造方法都要为其赋值，但是不能用set方法赋值。</p>\n<p>7、成员变量在堆内存中是有默认值的，final固定的是成员变量的手动赋值不是内存中的默认值。</p>\n<p>8、被final修饰的静态成员变量只能直接赋值或者通过静态代码块赋值。</p>\n<hr>\n<h2 id=\"多态性\"><a href=\"#多态性\" class=\"headerlink\" title=\"多态性\"></a><strong>多态性</strong></h2><ol>\n<li>对象的多态性：父类的引用指向子类的对象（子类的对象赋给父类的引用）</li>\n<li>多态的使用，虚拟方法调用有了对象的多态性后,我们在编译期，只能调用父类声明的方法，但在运行期，我们实际指向的是子类重写父类方法。<br><code>总结：编译，看左边；运行,看右边。</code><br>如：<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Pet</span> <span class=\"variable\">qq</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Penguin</span>();  <span class=\"comment\">//对象的多态性：父类的引用指向子类的对象</span></span><br><span class=\"line\"><span class=\"type\">Pet</span> <span class=\"variable\">ww</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Pet</span>();</span><br></pre></td></tr></table></figure></li>\n<li>多态性的使用前提：<code>只适用于方法，不适用于属性（属性不会被覆盖和重写）</code><br>如：<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Pet qq=<span class=\"keyword\">new</span> <span class=\"title class_\">Penguin</span>();</span><br><span class=\"line\">System.out.println(qq.j);   <span class=\"comment\">//调用父类的变量</span></span><br></pre></td></tr></table></figure></li>\n<li>“不要犯傻，如果它不是晚绑定，它就不是多态”</li>\n</ol>\n<h1 id=\"复习\"><a href=\"#复习\" class=\"headerlink\" title=\"复习\"></a>复习</h1><h3 id=\"abstract-抽象的\"><a href=\"#abstract-抽象的\" class=\"headerlink\" title=\"abstract 抽象的\"></a>abstract 抽象的</h3><ol>\n<li>可以用来修饰：类、方法</li>\n<li>具体的</li>\n</ol>\n<p>abstract修饰类：抽象类</p>\n<ul>\n<li><blockquote>\n<p>不能实例化</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>抽象类一定有构造器</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>都会提供抽象类的子类</p>\n</blockquote>\n</li>\n</ul>\n<p>abstract修饰方法：抽象方法</p>\n<ul>\n<li><blockquote>\n<p>抽象方法只方法声明，没方法体</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>包含抽象方法的类，一定是个抽象类。反之，抽象类中可以没有抽象方法的。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>若子类重写了父类中所的抽象方法后，此子类可实例化</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>若子类没重写父类中的所的抽象方法，则子类也是一个抽象类，需要abstract修饰</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"3\">\n<li>注意点：</li>\n</ol>\n<ul>\n<li><blockquote>\n<ol>\n<li>abstract不能用来修饰：属性、构造器等结构</li>\n</ol>\n</blockquote>\n</li>\n<li><blockquote>\n<ol start=\"2\">\n<li>abstract不能用来修饰私方法、静态方法、final的方法、final的类</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n","categories":["Java"],"tags":["java"]},{"title":"Linux实用命令","url":"/2022/04/19/linux-shi-yong-de-ming-ling/","content":"<h2 id=\"pwd-指令\"><a href=\"#pwd-指令\" class=\"headerlink\" title=\"pwd 指令\"></a><strong>pwd 指令</strong></h2><p><code>显示当前工作目录的绝对路径</code></p>\n<h2 id=\"ls-指令\"><a href=\"#ls-指令\" class=\"headerlink\" title=\"ls 指令\"></a><strong>ls 指令</strong></h2><h3 id=\"常用选项\"><a href=\"#常用选项\" class=\"headerlink\" title=\"常用选项\"></a>常用选项</h3><blockquote>\n<p><font color=\"#FF0000\"> -a  </font>——<em>显示当前目录所有的文件和目录，包括隐藏的</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\"> -l  </font>——<em>以列表的方式显示信息</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\"> -h  </font>——<em>显示文件大小时，以 k , m, G单位显示</em></p>\n</blockquote>\n<h2 id=\"cd-指令\"><a href=\"#cd-指令\" class=\"headerlink\" title=\"cd 指令\"></a><strong>cd 指令</strong></h2><h3 id=\"常用参数\"><a href=\"#常用参数\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h3><blockquote>\n<p><font color=\"#FF0000\"> cd ~  </font>——<em>回到自己的家目录</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\"> cd ..  </font>——<em>回到当前目录的上一级目录</em></p>\n</blockquote>\n<h2 id=\"mkdir指令\"><a href=\"#mkdir指令\" class=\"headerlink\" title=\"mkdir指令\"></a><strong>mkdir指令</strong></h2><h3 id=\"常用参数-1\"><a href=\"#常用参数-1\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h3><blockquote>\n<p><font color=\"#FF0000\"> mkdir &#x2F;home&#x2F;zw </font>——<em>创建一个目录</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\"> mkdir -p &#x2F;home&#x2F;zw </font>——<em>如果目录不存在的就新创建</em>一个。 </p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\"> mkdir -m 777 &#x2F;home&#x2F;zw</font>——<em>建立目录时，同时设置目录权限。</em></p>\n</blockquote>\n<h2 id=\"touch指令\"><a href=\"#touch指令\" class=\"headerlink\" title=\"touch指令\"></a><strong>touch指令</strong></h2><h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><blockquote>\n<p><font color=\"#FF0000\"> touch hello.txt </font>——<em>创建一个空文件 hello.txt</em></p>\n</blockquote>\n<h2 id=\"cp指令-copy-拷贝\"><a href=\"#cp指令-copy-拷贝\" class=\"headerlink\" title=\"cp指令[copy 拷贝]\"></a><strong>cp指令[copy 拷贝]</strong></h2><h3 id=\"常用参数-2\"><a href=\"#常用参数-2\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h3><h4 id=\"cp-选项-source【源】-dest【目的文件】\"><a href=\"#cp-选项-source【源】-dest【目的文件】\" class=\"headerlink\" title=\"cp [选项] source【源】 dest【目的文件】\"></a>cp [选项] source【源】 dest【目的文件】</h4><blockquote>\n<p><font color=\"#FF0000\"> cp -r &#x2F;home&#x2F;zw&#x2F;hello.txt &#x2F;home&#x2F;jj</font>——<em>递归复制整个文件夹,将hello.txt 拷贝到jj目录下</em></p>\n</blockquote>\n<h2 id=\"rm指令\"><a href=\"#rm指令\" class=\"headerlink\" title=\"rm指令\"></a><strong>rm指令</strong></h2><h3 id=\"常用参数-3\"><a href=\"#常用参数-3\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h3><blockquote>\n<p><font color=\"#FF0000\">rm &#x2F;home&#x2F;zw&#x2F;hello.txt</font>——<em>[选项]  要删除的文件或目录</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\">-r</font>——<em>递归删除整个文件夹</em> </p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\">-f</font>——<em>强制删除不提示</em></p>\n</blockquote>\n<h2 id=\"mv指令\"><a href=\"#mv指令\" class=\"headerlink\" title=\"mv指令\"></a><strong>mv指令</strong></h2><h3 id=\"基本语法-1\"><a href=\"#基本语法-1\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><blockquote>\n<p><font color=\"#FF0000\">mv &#x2F;home&#x2F;zw&#x2F;Hello</font>——<em>(功能描述：重命名)</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\">mv &#x2F;home&#x2F;zw&#x2F;Hello &#x2F;home&#x2F;jj</font>——<em>(功能描述：移动文件或目录)</em></p>\n</blockquote>\n<h2 id=\"cat指令\"><a href=\"#cat指令\" class=\"headerlink\" title=\"cat指令\"></a><strong>cat指令</strong></h2><h3 id=\"基本语法-2\"><a href=\"#基本语法-2\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><blockquote>\n<p><font color=\"#FF0000\">cat &#x2F;home&#x2F;zw&#x2F;Hello.txt</font>——<em>(功能描述：查看文件内容)</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\">cat -n &#x2F;ect&#x2F;profile </font>——<em>(功能描述：显示文件内容，并显示行号)</em></p>\n</blockquote>\n<h3 id=\"使用细节\"><a href=\"#使用细节\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h3><pre><code>   cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 | more\ncat  xxx.txt | more  (把cat xxx.txt 输出结果交给 more 处理)\n</code></pre>\n<h2 id=\"more指令\"><a href=\"#more指令\" class=\"headerlink\" title=\"more指令\"></a><strong>more指令</strong></h2><p><code>介绍：more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键.</code></p>\n<h3 id=\"基本语法-3\"><a href=\"#基本语法-3\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><blockquote>\n<p><font color=\"#FF0000\">more &#x2F;etc&#x2F;profile<br> </font>——<em>(功能描述：采用more查看文件 )</em></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">功能说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">空白键 (space)</td>\n<td align=\"left\">代表向下翻一页；</td>\n</tr>\n<tr>\n<td align=\"left\">Enter</td>\n<td align=\"left\">代表向下翻『一行』；</td>\n</tr>\n<tr>\n<td align=\"left\">q</td>\n<td align=\"left\">代表立刻离开 more ，不再显示该文件内容。</td>\n</tr>\n<tr>\n<td align=\"left\">Ctrl+F</td>\n<td align=\"left\">向下滚动一屏</td>\n</tr>\n<tr>\n<td align=\"left\">Ctrl+B</td>\n<td align=\"left\">返回上一屏</td>\n</tr>\n<tr>\n<td align=\"left\">&#x3D;</td>\n<td align=\"left\">输出当前行的行号</td>\n</tr>\n<tr>\n<td align=\"left\">:f</td>\n<td align=\"left\">输出文件名和当前行的行号</td>\n</tr>\n</tbody></table>\n<h2 id=\"less指令\"><a href=\"#less指令\" class=\"headerlink\" title=\"less指令\"></a><strong>less指令</strong></h2><p><code>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示</code>需要加载内容，<font color=\"#FF0000\">对于显示大型文件具有较高的效率。</font></p>\n<h3 id=\"基本语法-4\"><a href=\"#基本语法-4\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><blockquote>\n<p><font color=\"#FF0000\">less &#x2F;etc&#x2F;profile<br> </font>——<em>(功能描述：采用more查看文件 )</em></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">功能说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">空白键 (space)</td>\n<td align=\"left\">代表向下翻一页；</td>\n</tr>\n<tr>\n<td align=\"left\">[pagedown]</td>\n<td align=\"left\">向下翻动一页</td>\n</tr>\n<tr>\n<td align=\"left\">[pageup]</td>\n<td align=\"left\">向上翻动一页；</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;字串</td>\n<td align=\"left\">向下搜寻『字串』的功能；n：向下查找；N：向上查找；</td>\n</tr>\n<tr>\n<td align=\"left\">?字串</td>\n<td align=\"left\">向上搜寻『字串』的功能；n：向上查找；N：向下查找；</td>\n</tr>\n<tr>\n<td align=\"left\">&#x3D;</td>\n<td align=\"left\">输出当前行的行号</td>\n</tr>\n<tr>\n<td align=\"left\">q</td>\n<td align=\"left\">离开 less 这个程序；</td>\n</tr>\n</tbody></table>\n<h2 id=\"echo指令\"><a href=\"#echo指令\" class=\"headerlink\" title=\"echo指令\"></a><strong>echo指令</strong></h2><p><code>echo命令的功能是在终端窗口显示器上显示一段文字，一般起到一个提示的作用。</code></p>\n<p>基本语法</p>\n<blockquote>\n<p><font color=\"#FF0000\">echo ‘That you are a pig is a fact ‘<br> </font>——<em>(功能描述：终端窗口显示器上显示一段文字)</em><br><font color=\"#FF0000\">echo $HOME<br> </font>——<em>(功能描述：显示输出 当前用户的登录子目录)</em></p>\n</blockquote>\n<h2 id=\"head指令\"><a href=\"#head指令\" class=\"headerlink\" title=\"head指令\"></a><strong>head指令</strong></h2><p> <code>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容 基本语法 </code></p>\n<h3 id=\"基本语法-5\"><a href=\"#基本语法-5\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><blockquote>\n<p><font color=\"#FF0000\">head &#x2F;home&#x2F;Hello.txt<br> </font>——<em>(功能描述：查看文件头10行内容)</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\">head -n 5 &#x2F;home&#x2F;Hello.txt<br> </font>——<em>(查看文件头5行内容，5可以是任意行数)</em></p>\n</blockquote>\n<h2 id=\"tail指令\"><a href=\"#tail指令\" class=\"headerlink\" title=\"tail指令\"></a><strong>tail指令</strong></h2><h3 id=\"基本语法-6\"><a href=\"#基本语法-6\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><blockquote>\n<p><font color=\"#FF0000\">tail &#x2F;home&#x2F;Hello.txt<br> </font>——<em>(功能描述：查看文件头10行内容)</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\">tail -n 5 &#x2F;home&#x2F;Hello.txt<br> </font>——<em>(查看文件头5行内容，5可以是任意行数)</em></p>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF0000\">head -f 5 &#x2F;home&#x2F;Hello.txt<br> </font>——<em>(实时追踪该文档的所有更新)</em></p>\n</blockquote>\n","categories":["Linux"],"tags":["Linux"]},{"title":"Scala基础笔记","url":"/2022/06/10/scala-ji-chu-bi-ji/","content":"<h1 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h1><p><a href=\"http://distfiles.macports.org/\">http://distfiles.macports.org/</a></p>\n<p><code>镜像下载，Ctrl+F搜索scala下载</code></p>\n<p>这里选择 **<font color=\"red\">scala-2.12.11</font>**进行下载</p>\n<h2 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SCALA_HOME:</span><br><span class=\"line\">D:\\scala\\scala-2.12.11</span><br><span class=\"line\">Path:</span><br><span class=\"line\">%SCALA_HOME%\\bin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><ul>\n<li><p>scalac HelloScala.scala    </p>\n</li>\n<li><p>scala HelloScala</p>\n</li>\n</ul>\n<p><code>和java一样，编译运行</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">HelloScala</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args:<span class=\"type\">Array</span>[<span class=\"type\">String</span>]):<span class=\"type\">Unit</span> =&#123;</span><br><span class=\"line\">        print(<span class=\"string\">&quot;hello scala&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在IDEA在线安装插件\"><a href=\"#在IDEA在线安装插件\" class=\"headerlink\" title=\"在IDEA在线安装插件\"></a>在IDEA在线安装插件</h2><p><code>在IDEA中运行需要安装插件！！！</code></p>\n<ul>\n<li>在IDEA软件中搜索插件框里面输入 <strong>Scala</strong>-&gt;点击 <strong>Install</strong>-&gt;点击 <strong>ok</strong>-&gt;点击 <strong>apply</strong>，最后重启 IDEA。</li>\n</ul>\n<h1 id=\"Scala六大特性\"><a href=\"#Scala六大特性\" class=\"headerlink\" title=\"Scala六大特性\"></a>Scala六大特性</h1><h3 id=\"1-无缝-JAVA-互操作\"><a href=\"#1-无缝-JAVA-互操作\" class=\"headerlink\" title=\"1. 无缝 JAVA 互操作\"></a>1. 无缝 JAVA 互操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Scala 在 JVM 上运行，因此可以自由混合 Java 和 Scala 堆栈以实现完全无缝集成。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-类型推断-自动推测类型-var\"><a href=\"#2-类型推断-自动推测类型-var\" class=\"headerlink\" title=\"2. 类型推断(自动推测类型 var)\"></a>2. 类型推断(自动推测类型 var)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">所以类型系统感觉不是那么静态。不要为类型系统工作。让类型系统为您工作！</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-并发和分布（Actor）\"><a href=\"#3-并发和分布（Actor）\" class=\"headerlink\" title=\"3. 并发和分布（Actor）\"></a>3. 并发和分布（Actor）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">对集合使用数据并行操作，使用参与者进行并发和分发，或使用期货进行异步编程。</span><br><span class=\"line\"></span><br><span class=\"line\">使用scala语言，去进行并发，以及分布式场景下的开发时，它有着得天独厚的优势</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-性状\"><a href=\"#4-性状\" class=\"headerlink\" title=\"4. 性状\"></a>4. 性状</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">将 Java 样式接口的灵活性与类的强大功能相结合。考虑原则性的多重继承。</span><br><span class=\"line\"></span><br><span class=\"line\">java当中结合接口以及抽象类的一个结合器，多继承，类似java中interfaces和abstract结合</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-模式匹配-switch\"><a href=\"#5-模式匹配-switch\" class=\"headerlink\" title=\"5. 模式匹配(switch)\"></a>5. 模式匹配(switch)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">匹配类层次结构、序列、常量等。</span><br><span class=\"line\"></span><br><span class=\"line\">类似Java中的switch ...case</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-高阶函数\"><a href=\"#6-高阶函数\" class=\"headerlink\" title=\"6. 高阶函数\"></a>6. 高阶函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">函数是一流的对象。在保证类型安全的情况下编写它们。在任何地方使用它们，将它们传递给任何东西。</span><br><span class=\"line\"></span><br><span class=\"line\">传递函数</span><br><span class=\"line\">String name = &quot;zw&quot;  //静态</span><br><span class=\"line\">n=1,n=&quot;1&quot;          //动态</span><br><span class=\"line\"></span><br><span class=\"line\">一句话总结：Scala是一门以jvm为运行环境的静态类型编程语言，具备面向对象及函数式编程的特性。</span><br></pre></td></tr></table></figure>\n\n<p><code>所有的main方法要在，object中被调用</code></p>\n<h1 id=\"Scala基础\"><a href=\"#Scala基础\" class=\"headerlink\" title=\"Scala基础\"></a>Scala基础</h1><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><strong>Scala 与 Java有着相同的数据类型，在Scala中数据类型都是对象，也就是说scala没有java中的原生类型。</strong></p>\n<p><strong>Scala数据类型分为两大类 AnyVal(值类型) 和 AnyRef(引用类型)， 注意：不管是AnyVal还是AnyRef 都是对象。</strong></p>\n<p><img src=\"/2022/06/10/scala-ji-chu-bi-ji/1.png\"></p>\n<p><img src=\"/2022/06/10/scala-ji-chu-bi-ji/2.png\"></p>\n<p>比较特殊的None,是Option的两个子类之一，另一个是Some,用于安全的函数返回值</p>\n<p>scala推荐在可能返回空的方法使用Option[X]作为返回类型，如果有值就返回Some[X],否则返回None</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span></span>(key : <span class=\"type\">A</span>): <span class=\"type\">Option</span>[<span class=\"type\">B</span>] =&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (contains(key))</span><br><span class=\"line\">\t\t<span class=\"type\">Some</span>(getValue(key))</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"type\">None</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Nil表示长度为0的List</p>\n<h3 id=\"Scala中val与var的区别\"><a href=\"#Scala中val与var的区别\" class=\"headerlink\" title=\"Scala中val与var的区别\"></a><a href=\"https://so.csdn.net/so/search?q=Scala&spm=1001.2101.3001.7020\">Scala</a>中val与var的区别</h3><ol>\n<li>val代表value，val修饰的变量，相当于java中的final</li>\n<li>var代表variable，普通变量，可变变量，但是这个可变是有限制的，在scala中，任何变量都必须初始化，初始化后，这个变量的类型也就确定了（类型不可再改变），因此即使是var，也只能在同类型间进行重新赋值，修改值等，不允许跨类修改、</li>\n</ol>\n<h3 id=\"scala变量和常量以及类对象的创建-伴生类-伴生对象\"><a href=\"#scala变量和常量以及类对象的创建-伴生类-伴生对象\" class=\"headerlink\" title=\"scala变量和常量以及类对象的创建 伴生类 伴生对象\"></a>scala变量和常量以及类对象的创建 伴生类 伴生对象</h3><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.bigdata.chapter01</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Auther:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * @Date: 2022/6/21</span></span><br><span class=\"line\"><span class=\"comment\"> * @Description: com.bigdata.chapter01</span></span><br><span class=\"line\"><span class=\"comment\"> * @Version:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1.一行的结尾可以省略分号，如果说一行中有多个语句那么可以使用分号进行隔开</span></span><br><span class=\"line\"><span class=\"comment\">    2.var修饰变量，val修饰常量</span></span><br><span class=\"line\"><span class=\"comment\">    3.class默认实现了getter setter方法</span></span><br><span class=\"line\"><span class=\"comment\">    4.class中如果有参数的传入，那么这个构造器就是这个类的默认构造器</span></span><br><span class=\"line\"><span class=\"comment\">    5.重写构造器，必须调用类默认的构造器</span></span><br><span class=\"line\"><span class=\"comment\">    6.class在被new对象的时候，除了方法内部不执行，其他地方的代码都会被执行//按先后顺序来的</span></span><br><span class=\"line\"><span class=\"comment\">    7.object里面不能传递参数，object里面的属性和方法都是静态（类似java中static修饰的东西）类似于java中的工具类（类名，方法）</span></span><br><span class=\"line\"><span class=\"comment\">    8.伴生类和伴生对象:在一个scala文件中，如果class和object名字一样，则互为伴生类和伴生对象，他们可以直接访问互相的私有成员变量</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">xname:<span class=\"type\">String</span>,xage:<span class=\"type\">Int</span></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">val</span> name=xname</span><br><span class=\"line\">   <span class=\"keyword\">val</span> age=xage</span><br><span class=\"line\">   <span class=\"keyword\">var</span> money=<span class=\"number\">100</span></span><br><span class=\"line\">  println(<span class=\"number\">111</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(xname:<span class=\"type\">String</span>,xage:<span class=\"type\">Int</span>,xmoney:<span class=\"type\">Int</span>)&#123;    <span class=\"comment\">//重写构造器必须调用类默认的构造器</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>(xname,xage)</span><br><span class=\"line\">      money=xmoney</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  println(<span class=\"number\">222</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span></span>()=&#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;你好哦&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  println(<span class=\"number\">333</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    println(<span class=\"number\">444</span>)</span><br><span class=\"line\">    println(<span class=\"number\">555</span>)</span><br><span class=\"line\">    println(<span class=\"number\">666</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">HelloWorld</span> </span>&#123;  <span class=\"comment\">//在ovject对象，在对象下，属性，方法，代码块，都是静态</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> height=<span class=\"number\">180</span></span><br><span class=\"line\">  <span class=\"comment\">//public static void main(String[] args)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> person = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">&quot;郑炜&quot;</span>,<span class=\"number\">18</span>,<span class=\"number\">50</span>)</span><br><span class=\"line\">      println(person.name+<span class=\"string\">&quot;:&quot;</span>+person.age+<span class=\"string\">&quot;:&quot;</span>+person.money)</span><br><span class=\"line\">    person.test()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if  else\"></a>if  else</h3><p>同 java一样的语法结构，单，双，多分支这样几种结构</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * StdIn键盘标准输入 scala.io包下的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> age = <span class=\"type\">StdIn</span>.readInt()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (age &gt;= <span class=\"number\">18</span> &amp;&amp; age &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;成年&quot;</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &gt; <span class=\"number\">0</span> &amp;&amp; age &lt; <span class=\"number\">18</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;未成年&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;????&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"for-while-do…while\"><a href=\"#for-while-do…while\" class=\"headerlink\" title=\"for,while,do…while\"></a>for,while,do…while</h3><ol>\n<li>to 和until的用法（不带步长，带步长的区别）</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * to和until </span></span><br><span class=\"line\"><span class=\"comment\"> * 1 to 10 返回1到10的Range数组，包含10</span></span><br><span class=\"line\"><span class=\"comment\"> * 1 until 10 返回1到10的Range数组，不包含10</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">println(<span class=\"number\">1</span> to <span class=\"number\">10</span>) <span class=\"comment\">//打印1,2,3,4,5,6,7,8,9,10</span></span><br><span class=\"line\">println(<span class=\"number\">1</span> to (<span class=\"number\">10</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">println(<span class=\"number\">1</span> to (<span class=\"number\">10</span>,<span class=\"number\">2</span>)) <span class=\"comment\">//步长为2，从1开始打印 1，3，5，7，9</span></span><br><span class=\"line\">println(<span class=\"number\">1.</span>to(<span class=\"number\">10</span>,<span class=\"number\">2</span>)) <span class=\"comment\">//与上面等价</span></span><br><span class=\"line\"></span><br><span class=\"line\">println(<span class=\"number\">1</span> until <span class=\"number\">10</span>) <span class=\"comment\">//不包含最后一个数,1,2,3,4,5,6,7,8,9</span></span><br><span class=\"line\">println(<span class=\"number\">1</span> until(<span class=\"number\">10</span>))<span class=\"comment\">//与上面等价</span></span><br><span class=\"line\">print(<span class=\"number\">1</span> until(<span class=\"number\">10</span>,<span class=\"number\">3</span>)) <span class=\"comment\">//步长为3，从1开始打印，1，4，7</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>创建for循环</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * for 循环</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  println(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建多层for循环</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以分号隔开，构成多层for循环</span></span><br><span class=\"line\"><span class=\"comment\">//scala中 不能写count++ count-- 只能写count+</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span>; j &lt;- <span class=\"number\">1</span> until <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;i=&quot;</span>+ i +<span class=\"string\">&quot;, j=&quot;</span>+j)</span><br><span class=\"line\">  count += <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println(count)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例子： 打印小九九</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">1</span> to <span class=\"number\">9</span> ; j &lt;- <span class=\"number\">1</span> to i)&#123;    <span class=\"comment\">//后面内嵌循环 j随着i变化而变化</span></span><br><span class=\"line\">      print(j + <span class=\"string\">&quot;*&quot;</span> + i + <span class=\"string\">&quot;=&quot;</span> + (i * j) + <span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(j == i)&#123;</span><br><span class=\"line\">        println()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>*<span class=\"number\">1</span>=<span class=\"number\">1</span>\t</span><br><span class=\"line\"><span class=\"number\">2</span>*<span class=\"number\">1</span>=<span class=\"number\">2</span>\t<span class=\"number\">2</span>*<span class=\"number\">2</span>=<span class=\"number\">4</span>\t</span><br><span class=\"line\"><span class=\"number\">3</span>*<span class=\"number\">1</span>=<span class=\"number\">3</span>\t<span class=\"number\">3</span>*<span class=\"number\">2</span>=<span class=\"number\">6</span>\t<span class=\"number\">3</span>*<span class=\"number\">3</span>=<span class=\"number\">9</span>\t</span><br><span class=\"line\"><span class=\"number\">4</span>*<span class=\"number\">1</span>=<span class=\"number\">4</span>\t<span class=\"number\">4</span>*<span class=\"number\">2</span>=<span class=\"number\">8</span>\t<span class=\"number\">4</span>*<span class=\"number\">3</span>=<span class=\"number\">12</span>\t<span class=\"number\">4</span>*<span class=\"number\">4</span>=<span class=\"number\">16</span>\t</span><br><span class=\"line\"><span class=\"number\">5</span>*<span class=\"number\">1</span>=<span class=\"number\">5</span>\t<span class=\"number\">5</span>*<span class=\"number\">2</span>=<span class=\"number\">10</span>\t<span class=\"number\">5</span>*<span class=\"number\">3</span>=<span class=\"number\">15</span>\t<span class=\"number\">5</span>*<span class=\"number\">4</span>=<span class=\"number\">20</span>\t<span class=\"number\">5</span>*<span class=\"number\">5</span>=<span class=\"number\">25</span>\t</span><br><span class=\"line\"><span class=\"number\">6</span>*<span class=\"number\">1</span>=<span class=\"number\">6</span>\t<span class=\"number\">6</span>*<span class=\"number\">2</span>=<span class=\"number\">12</span>\t<span class=\"number\">6</span>*<span class=\"number\">3</span>=<span class=\"number\">18</span>\t<span class=\"number\">6</span>*<span class=\"number\">4</span>=<span class=\"number\">24</span>\t<span class=\"number\">6</span>*<span class=\"number\">5</span>=<span class=\"number\">30</span>\t<span class=\"number\">6</span>*<span class=\"number\">6</span>=<span class=\"number\">36</span>\t</span><br><span class=\"line\"><span class=\"number\">7</span>*<span class=\"number\">1</span>=<span class=\"number\">7</span>\t<span class=\"number\">7</span>*<span class=\"number\">2</span>=<span class=\"number\">14</span>\t<span class=\"number\">7</span>*<span class=\"number\">3</span>=<span class=\"number\">21</span>\t<span class=\"number\">7</span>*<span class=\"number\">4</span>=<span class=\"number\">28</span>\t<span class=\"number\">7</span>*<span class=\"number\">5</span>=<span class=\"number\">35</span>\t<span class=\"number\">7</span>*<span class=\"number\">6</span>=<span class=\"number\">42</span>\t<span class=\"number\">7</span>*<span class=\"number\">7</span>=<span class=\"number\">49</span>\t</span><br><span class=\"line\"><span class=\"number\">8</span>*<span class=\"number\">1</span>=<span class=\"number\">8</span>\t<span class=\"number\">8</span>*<span class=\"number\">2</span>=<span class=\"number\">16</span>\t<span class=\"number\">8</span>*<span class=\"number\">3</span>=<span class=\"number\">24</span>\t<span class=\"number\">8</span>*<span class=\"number\">4</span>=<span class=\"number\">32</span>\t<span class=\"number\">8</span>*<span class=\"number\">5</span>=<span class=\"number\">40</span>\t<span class=\"number\">8</span>*<span class=\"number\">6</span>=<span class=\"number\">48</span>\t<span class=\"number\">8</span>*<span class=\"number\">7</span>=<span class=\"number\">56</span>\t<span class=\"number\">8</span>*<span class=\"number\">8</span>=<span class=\"number\">64</span>\t</span><br><span class=\"line\"><span class=\"number\">9</span>*<span class=\"number\">1</span>=<span class=\"number\">9</span>\t<span class=\"number\">9</span>*<span class=\"number\">2</span>=<span class=\"number\">18</span>\t<span class=\"number\">9</span>*<span class=\"number\">3</span>=<span class=\"number\">27</span>\t<span class=\"number\">9</span>*<span class=\"number\">4</span>=<span class=\"number\">36</span>\t<span class=\"number\">9</span>*<span class=\"number\">5</span>=<span class=\"number\">45</span>\t<span class=\"number\">9</span>*<span class=\"number\">6</span>=<span class=\"number\">54</span>\t<span class=\"number\">9</span>*<span class=\"number\">7</span>=<span class=\"number\">63</span>\t<span class=\"number\">9</span>*<span class=\"number\">8</span>=<span class=\"number\">72</span>\t<span class=\"number\">9</span>*<span class=\"number\">9</span>=<span class=\"number\">81</span>\t</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>for 循环中可以加条件判断，分号隔开</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以在for循环中加入条件判断</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i&lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span> ;<span class=\"keyword\">if</span> (i%<span class=\"number\">2</span>) == <span class=\"number\">0</span> ;<span class=\"keyword\">if</span> (i == <span class=\"number\">4</span>) )&#123;</span><br><span class=\"line\">  println(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala中不能使用 count++ ， count– 只能使用 count &#x3D; count+1 ， count +&#x3D; 1</p>\n</li>\n<li><p>for循环用yield 关键字返回一个集合（ for {子句} yield {变量或表达式} ，原来的集合不会被改变，只会通过你的for&#x2F;yield构建出一个新的集合。）</p>\n</li>\n<li><p>while循环(两种方式)， while(){}，do {}while()</p>\n</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将for中的符合条件的元素通过yield关键字返回成一个集合</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> list = <span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span> ; <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">5</span> )) <span class=\"keyword\">yield</span> i</span><br><span class=\"line\"><span class=\"keyword\">for</span>( w &lt;- list )&#123;</span><br><span class=\"line\">  println(w) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * while 循环</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(index &lt; <span class=\"number\">10</span> )&#123;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;第&quot;</span>+index+<span class=\"string\">&quot;次while 循环&quot;</span>)</span><br><span class=\"line\">  index += <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  index = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">  index +=<span class=\"number\">1</span></span><br><span class=\"line\">  println(<span class=\"string\">&quot;第&quot;</span>+index+<span class=\"string\">&quot;次do while 循环&quot;</span>) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(index &lt;<span class=\"number\">10</span> )</span><br></pre></td></tr></table></figure>\n<h1 id=\"Scala函数\"><a href=\"#Scala函数\" class=\"headerlink\" title=\"Scala函数\"></a>Scala函数</h1><p>有参函数</p>\n<p>无参函数</p>\n<h3 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h3><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.bigdata.chapter01</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Auther:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * @Date: 2022/6/21</span></span><br><span class=\"line\"><span class=\"comment\"> * @Description: com.bigdata.chapter01</span></span><br><span class=\"line\"><span class=\"comment\"> * @Version:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1.return关键字可以省略，scala自动将函数的最后一行的值作为函数的返回值</span></span><br><span class=\"line\"><span class=\"comment\">    2.&#123;&#125;只有一句语句时，可以省略&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">    3.函数可以省略返回类型(显式)，会进行类型自动推断，(隐式) 。 显示调用return时不能省略返回类型</span></span><br><span class=\"line\"><span class=\"comment\">    4.= 可以省略，如果省略掉了，函数会自动将返回值丢弃，一般用在无返回值的函数中省略</span></span><br><span class=\"line\"><span class=\"comment\">    5.方法的参数是使用val定义的，即方法内只能使用参数而不能修改参数值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">test2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMax</span></span>(a:<span class=\"type\">Int</span>,b:<span class=\"type\">Int</span>)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//a=20   不能修改参数值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(a&gt;b)</span><br><span class=\"line\">        a</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        b</span><br><span class=\"line\">         <span class=\"comment\">//最后一行什么类型就推断成什么类型</span></span><br><span class=\"line\">      println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    getMax(<span class=\"number\">1</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意点：</p>\n<ol>\n<li><p>Scala 使用 def 关键字告诉编译器这是一个方法。</p>\n</li>\n<li><p>我们可以通过在参数后面加一个冒号和类型来显式地指定返回类型。</p>\n</li>\n<li><p>方法可以写返回值的类型也可以不写，会自动推断，有时候不能省略，必须写，比如在递归函数中或者函数的返回值是函数类型的时候。</p>\n</li>\n<li><p>Scala 中函数有返回值时，可以写 return ，也可以不写 return ，不写 return 时会把函数中最后一行当做结果返回。当写 return 时，必须要写函数的返回类型。如果返回值可以一行搞定，可以将 {} 省略不写</p>\n</li>\n<li><p>传递给方法的参数可以在方法中使用，并且 scala 规定方法的传过来的参数为 val 的，不是 var的。</p>\n</li>\n<li><p>如果去掉方法体前面的等号，那么这个方法返回类型必定是 Unit 的。这种说法无论方法体里面什么逻辑都成立， scala 可以把任意类型转换为 Unit 。假设，函数里面的逻辑最后返回了一个string ，那么这个返回值会被转换成 Unit ，原本逻辑的值会被丢弃。</p>\n</li>\n</ol>\n<h3 id=\"递归函数，默认值，可变参数\"><a href=\"#递归函数，默认值，可变参数\" class=\"headerlink\" title=\"递归函数，默认值，可变参数\"></a>递归函数，默认值，可变参数</h3><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">test2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    递归函数：关键点在于递归的定义，终止条件(栈溢出)</span></span><br><span class=\"line\"><span class=\"comment\">    5*4*3..</span></span><br><span class=\"line\"><span class=\"comment\">    递归函数不能省略方法的返回类型(也就是等号旁边的：int)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"comment\">//    def zw(a:Int):Int=&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      if(a==1)</span></span><br><span class=\"line\"><span class=\"comment\">//         a</span></span><br><span class=\"line\"><span class=\"comment\">//      else</span></span><br><span class=\"line\"><span class=\"comment\">//        a*zw(a-1)   //自己调用自己  5*4*3*2*1</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    println(zw(5))</span></span><br><span class=\"line\"><span class=\"comment\">//    #############################################</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     *   默认值注意：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.默认值的函数中，如果传入的参数个数与函数定义相同，则传入的数值会覆盖默认值</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.如果不想覆盖默认值，传入的参数个数小于定义的函数的参数，则需要指定参数名称</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"comment\">//      def f2(a:Int=5,b:Int=10)=&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        a+b</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//      println(f2())    // 15</span></span><br><span class=\"line\"><span class=\"comment\">//      println(f2(50,100))  //150</span></span><br><span class=\"line\"><span class=\"comment\">//      println(f2(100))     // 110</span></span><br><span class=\"line\"><span class=\"comment\">//      println(f2(b = 100)) //105</span></span><br><span class=\"line\"><span class=\"comment\">//    #############################################</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    可变参数个数函数</span></span><br><span class=\"line\"><span class=\"comment\">    java中写法 int ...a</span></span><br><span class=\"line\"><span class=\"comment\">    注意：多个参数逗号分开</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"comment\">//    def getSum(a:Int*)=&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      var sum=0</span></span><br><span class=\"line\"><span class=\"comment\">//      for(i&lt;-a)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        sum+=i</span></span><br><span class=\"line\"><span class=\"comment\">//      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//       sum</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    println(&quot;可变参数结果：&quot;+getSum(1,2,3,4,5,6))</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><p>一共有如下三种：</p>\n<ol>\n<li>有参匿名函数</li>\n<li>无参匿名函数</li>\n<li>有返回值的匿名函数<ul>\n<li>可以将匿名函数返回给val定义的值</li>\n<li>匿名函数不能显式声明函数的返回类型</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 匿名函数  (参数)=&gt;&#123;方法体&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.有参数匿名函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.无参数匿名函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 3.有返回值的匿名函数</span></span><br><span class=\"line\"><span class=\"comment\">    匿名函数 =&gt; 和高阶函数结合使用</span></span><br><span class=\"line\"><span class=\"comment\">    没有名字的函数</span></span><br><span class=\"line\"><span class=\"comment\">    val定义变量接收匿名函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意：</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以将匿名函数返回给定义的一个变量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//有参数匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> value1 = (a : <span class=\"type\">Int</span>) =&gt; &#123;</span><br><span class=\"line\">   println(a) &#125;</span><br><span class=\"line\">value1(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//无参数匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> value2 = ()=&gt;&#123;</span><br><span class=\"line\">   println(<span class=\"string\">&quot;我爱中国&quot;</span>) &#125;</span><br><span class=\"line\">value2()</span><br><span class=\"line\"><span class=\"comment\">//有返回值的匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> value3 = (a:<span class=\"type\">Int</span>,b:<span class=\"type\">Int</span>) =&gt;&#123;</span><br><span class=\"line\">   a+b &#125;</span><br><span class=\"line\">println(value3(<span class=\"number\">4</span>,<span class=\"number\">4</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌套函数-偏应用函数\"><a href=\"#嵌套函数-偏应用函数\" class=\"headerlink\" title=\"嵌套函数+偏应用函数\"></a>嵌套函数+偏应用函数</h3><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 嵌套函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：嵌套函数求5的阶乘</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zw</span></span>(num:<span class=\"type\">Int</span>)=&#123;   </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jie</span></span>(a:<span class=\"type\">Int</span>):<span class=\"type\">Int</span>=&#123;   <span class=\"comment\">//阶乘</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> sum=a</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a==<span class=\"number\">1</span>)</span><br><span class=\"line\">         <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">          sum*jie(a<span class=\"number\">-1</span>)   <span class=\"comment\">//递归</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      jie(num)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(zw(<span class=\"number\">5</span>))</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"偏应用函数\"><a href=\"#偏应用函数\" class=\"headerlink\" title=\"偏应用函数\"></a>偏应用函数</h3><p>偏应用函数是一种表达式，不需要提供函数需要的所有参数，只需要提供部分，或不提供所需参数。如下场景中，一个参数是完全相同，另一个参数不同，在这样一个情况之下，我们可以使用偏应用函数来进行优化。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.<span class=\"type\">Date</span>   <span class=\"comment\">//java日期包</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 偏应用函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以理解为一个表达式，让你不需要提供所有的参数，仅仅提供部分即可，找到变与不变，绑定不变值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(date :<span class=\"type\">Date</span>, s :<span class=\"type\">String</span>)= &#123;</span><br><span class=\"line\">   println(<span class=\"string\">&quot;date is &quot;</span>+ date +<span class=\"string\">&quot;,log is &quot;</span>+ s) &#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> date = <span class=\"keyword\">new</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\">log(date ,<span class=\"string\">&quot;log1&quot;</span>)</span><br><span class=\"line\">log(date ,<span class=\"string\">&quot;log2&quot;</span>)</span><br><span class=\"line\">log(date ,<span class=\"string\">&quot;log3&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//想要调用log，以上变化的是第二个参数，可以用偏应用函数处理</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> logWithDate = log(date,_:<span class=\"type\">String</span>)   <span class=\"comment\">//下划线冒号  _: 是变化参数</span></span><br><span class=\"line\">logWithDate(<span class=\"string\">&quot;log11&quot;</span>)</span><br><span class=\"line\">logWithDate(<span class=\"string\">&quot;log22&quot;</span>)</span><br><span class=\"line\">logWithDate(<span class=\"string\">&quot;log33&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>​    函数的参数是函数，或者函数的返回类型是函数，或者函数的参数和函数的返回类型是函数的函数。</p>\n<ol>\n<li><p>函数的参数是函数</p>\n</li>\n<li><p>函数的返回是函数</p>\n</li>\n<li><p>函数的参数和函数的返回是函数</p>\n</li>\n</ol>\n<h4 id=\"高阶函数-函数的参数是函数\"><a href=\"#高阶函数-函数的参数是函数\" class=\"headerlink\" title=\"高阶函数(函数的参数是函数)\"></a>高阶函数(函数的参数是函数)</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f7</span></span>(a:<span class=\"type\">Int</span>,f:(<span class=\"type\">Int</span>,<span class=\"type\">Int</span>)=&gt;<span class=\"type\">Int</span>): <span class=\"type\">Int</span> =&#123;   <span class=\"comment\">//把函数当参数传入</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = f(<span class=\"number\">1</span>, <span class=\"number\">2</span>)   <span class=\"comment\">//使用函数参数</span></span><br><span class=\"line\">    a*result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f8</span></span>(a:<span class=\"type\">Int</span>,b:<span class=\"type\">Int</span>):<span class=\"type\">Int</span>=a+b</span><br><span class=\"line\"></span><br><span class=\"line\">println(f7(<span class=\"number\">5</span>, f8))   <span class=\"comment\">//  result=15</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"高阶函数-函数的返回是函数\"><a href=\"#高阶函数-函数的返回是函数\" class=\"headerlink\" title=\"高阶函数(函数的返回是函数)\"></a>高阶函数(函数的返回是函数)</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数返回类型是函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f9</span></span>(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>): (<span class=\"type\">String</span>, <span class=\"type\">String</span>) =&gt; <span class=\"type\">String</span> =&#123;   <span class=\"comment\">//返回类型为函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f10</span></span>(c: <span class=\"type\">String</span>, d: <span class=\"type\">String</span>):<span class=\"type\">String</span>=&#123;</span><br><span class=\"line\">  a + <span class=\"string\">&quot; &quot;</span> + b + <span class=\"string\">&quot; &quot;</span> + c + <span class=\"string\">&quot; &quot;</span> + d</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  f10   <span class=\"comment\">//返回出去</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> z: <span class=\"type\">String</span> = <span class=\"string\">&quot;list&quot;</span>   <span class=\"comment\">//String</span></span><br><span class=\"line\"><span class=\"comment\">//ctrl+alt+v</span></span><br><span class=\"line\"><span class=\"comment\">//val function1= f9(1, 2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//alt+enter   显示变量类型 快捷键</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> function: (<span class=\"type\">String</span>, <span class=\"type\">String</span>) =&gt; <span class=\"type\">String</span> = f9(<span class=\"number\">1</span>, <span class=\"number\">2</span>)  <span class=\"comment\">//使用f9函数 返回结果为函数</span></span><br><span class=\"line\">println(function(<span class=\"string\">&quot;xin&quot;</span>,<span class=\"string\">&quot;xin&quot;</span>))       <span class=\"comment\">//使用返回的f10函数  返回结果为 字符串</span></span><br><span class=\"line\">println(f9(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"string\">&quot;xin&quot;</span>,<span class=\"string\">&quot;xin&quot;</span>))       <span class=\"comment\">//简化 前一个形参返回函数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"高阶函数-函数的参数和函数的返回是函数\"><a href=\"#高阶函数-函数的参数和函数的返回是函数\" class=\"headerlink\" title=\"高阶函数(函数的参数和函数的返回是函数)\"></a>高阶函数(函数的参数和函数的返回是函数)</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    参数为函数，返回值为函数的函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f11</span></span>(f:(<span class=\"type\">Int</span>,<span class=\"type\">Int</span>)=&gt;<span class=\"type\">Int</span>):(<span class=\"type\">Int</span>,<span class=\"type\">Int</span>)=&gt;<span class=\"type\">Int</span>=&#123;  <span class=\"comment\">//传入参数为函数，返回值为函数的函数</span></span><br><span class=\"line\">        f     <span class=\"comment\">//返回f函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   <span class=\"keyword\">val</span> zw= f11((a:<span class=\"type\">Int</span>,b:<span class=\"type\">Int</span>)=&gt;&#123;a+b&#125;)   <span class=\"comment\">//也可以使用变量来接收 返回的函数</span></span><br><span class=\"line\">    println(zw(<span class=\"number\">100</span>, <span class=\"number\">200</span>))              <span class=\"comment\">//使用返回的函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    println(f11((a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>) =&gt; &#123;a + b&#125;)(<span class=\"number\">100</span>, <span class=\"number\">200</span>))  <span class=\"comment\">//传入匿名函数，返回函数，使用函数   </span></span><br><span class=\"line\">    </span><br><span class=\"line\">                                <span class=\"comment\">//以上这句话还可以写成这样</span></span><br><span class=\"line\">    println(f11(_*_)(<span class=\"number\">100</span>,<span class=\"number\">3</span>))   <span class=\"comment\">//简化 如果函数的参数在方法体中只使用了一次 那么可以写成_表示，也可以把* 改为+ 运算符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"柯里化函数\"><a href=\"#柯里化函数\" class=\"headerlink\" title=\"柯里化函数\"></a>柯里化函数</h3><p>柯里化–颗粒化，将参数变成颗粒散落简而言之就是将参数拆拆拆。函数柯里化基本是在做这么一件事情：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。如果写成公式文字就是这样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fn(a,b,c,d)=&gt;fn(a)(b)(c)(d)；</span><br><span class=\"line\">fn(a,b,c,d)=&gt;fn(a，b)(c)(d)；</span><br><span class=\"line\">fn(a,b,c,d)=&gt;fn(a)(b，c，d)；</span><br></pre></td></tr></table></figure>\n\n<p>可以理解为高阶函数的简化。和我们文档中上面的函数的返回类是函数的例子进行比较。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//def fun7(a :Int,b:Int,c:Int,d:Int) = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// a+b+c+d</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//println(fun7(1,2,3,4))</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 柯里化函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun7</span></span>(a :<span class=\"type\">Int</span>,b:<span class=\"type\">Int</span>)(c:<span class=\"type\">Int</span>,d:<span class=\"type\">Int</span>) = &#123;</span><br><span class=\"line\">   a+b+c+d &#125;</span><br><span class=\"line\">println(fun7(<span class=\"number\">1</span>,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>))<span class=\"comment\">//执行完1+2得出3之后继续往下作为函数执行3+3+4最终求出结果10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Scala字符串\"><a href=\"#Scala字符串\" class=\"headerlink\" title=\"Scala字符串\"></a>Scala字符串</h2><h4 id=\"scala中操作符与方法的等价性\"><a href=\"#scala中操作符与方法的等价性\" class=\"headerlink\" title=\"scala中操作符与方法的等价性\"></a>scala中操作符与方法的等价性</h4><h4 id=\"StringBuilder-可变\"><a href=\"#StringBuilder-可变\" class=\"headerlink\" title=\"StringBuilder 可变\"></a>StringBuilder 可变</h4><h4 id=\"string-操作方法举例\"><a href=\"#string-操作方法举例\" class=\"headerlink\" title=\"string 操作方法举例\"></a>string 操作方法举例</h4><h4 id=\"scala中操作符与方法的等价性-1\"><a href=\"#scala中操作符与方法的等价性-1\" class=\"headerlink\" title=\"scala中操作符与方法的等价性\"></a><strong>scala中操作符与方法的等价性</strong></h4><ul>\n<li>比较：equals</li>\n<li>比较忽略大小写：equalsIgnoreCase</li>\n<li>indexOf:如果字符串中有传入的assci码对应的值，返回下标</li>\n</ul>\n<p><strong>scala中操作符即方法、方法即操作符。scala中操作符其实是普通方法调用的另一种表现形式，运算符的使用其实就是隐含地调用对应的方法。</strong>    </p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Auther:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * @Date: 2022/6/22</span></span><br><span class=\"line\"><span class=\"comment\"> * @Description: com.bigdata.chapter01</span></span><br><span class=\"line\"><span class=\"comment\"> * @Version:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">test2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> str: <span class=\"type\">String</span> = <span class=\"string\">&quot;abcd&quot;</span></span><br><span class=\"line\">    println(str.indexOf(<span class=\"string\">&quot;a&quot;</span>))   <span class=\"comment\">//0  下标</span></span><br><span class=\"line\">    println(str.indexOf(<span class=\"number\">99</span>))    <span class=\"comment\">//返回下标2 c</span></span><br><span class=\"line\">    <span class=\"comment\">//如果字符串中有传入的assci码对应的值，返回下标</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> str2=<span class=\"string\">&quot;ABCD&quot;</span></span><br><span class=\"line\">    println(str==str)</span><br><span class=\"line\">    println(str.compareToIgnoreCase(str2))   <span class=\"comment\">//忽略大小写比较 true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> stringBuilder = <span class=\"keyword\">new</span> <span class=\"type\">StringBuilder</span></span><br><span class=\"line\">    stringBuilder.append(<span class=\"string\">&quot;abc&quot;</span>)          <span class=\"comment\">//添加append</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      stringBuilder.++=(&quot;d&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">      stringBuilder++=&quot;d&quot;      //等价的</span></span><br><span class=\"line\"><span class=\"comment\">      stringbuilder对象可以+=char类型不能+=String类型，普通的+只有char类型追加在后面</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    stringBuilder++=<span class=\"string\">&quot;e&quot;</span></span><br><span class=\"line\">    stringBuilder+=&#x27;f&#x27;</span><br><span class=\"line\">    stringBuilder+&#x27;f&#x27;</span><br><span class=\"line\">    println(stringBuilder)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> x=<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> y=<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> num1=x+y;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> num2=x.+(y);    <span class=\"comment\">// 在scala中所有的操作符其实都是在调用函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    println(<span class=\"string\">&quot;num1 =&quot;</span>+num1)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;num2 =&quot;</span>+num2)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><p><a href=\"https://blog.csdn.net/m0_46657040/article/details/108581730\">https://blog.csdn.net/m0_46657040/article/details/108581730</a></p>\n<p>Scala提供了一套很好的集合实现，提供了一些集合类型的抽象。Scala 集合分为可变的和不可变的集合。<br>可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。而不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变。</p>\n<h3 id=\"Array数组\"><a href=\"#Array数组\" class=\"headerlink\" title=\"Array数组\"></a>Array数组</h3><p>数组分为<strong>不可变长数组（Array）</strong> 和<strong>可变长数组（ArrayBuffer）</strong> 。 如字面意思，前者长度不可变， 已经写死了， 后者长度可变。注:只是长度不可变， 但是对应角标元素可变</p>\n<h4 id=\"创建数组\"><a href=\"#创建数组\" class=\"headerlink\" title=\"创建数组\"></a>创建数组</h4><p><code>Array数组的第一个元素索引为0，最后一个元素的索引为元素总数（数组长度）减1。</code></p>\n<p><code>在IDEA中显示变量类型可以按 Alt+Enter 显示变量类型</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建数组两种方式：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.指定长度创建：new Array[Any](3)</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.直接Array初始化赋值创建</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建类型为 Int 长度为3的数组</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> arr1: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Int</span>](<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//创建String 类型的数组，直接初始化赋值</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> arr2: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] =<span class=\"type\">Array</span>[<span class=\"type\">String</span>](<span class=\"string\">&quot;s100&quot;</span>,<span class=\"string\">&quot;s200&quot;</span>,<span class=\"string\">&quot;s300&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">arr1(<span class=\"number\">0</span>) = <span class=\"number\">100</span></span><br><span class=\"line\">arr1(<span class=\"number\">1</span>) = <span class=\"number\">200</span></span><br><span class=\"line\">arr1(<span class=\"number\">2</span>) = <span class=\"number\">300</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 数组遍历：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> zw: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] =<span class=\"type\">Array</span>[<span class=\"type\">Int</span>](<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i&lt;<span class=\"number\">-0</span> until  zw.length)  </span><br><span class=\"line\">\tprint(i)</span><br><span class=\"line\"> <span class=\"comment\">//for(i&lt;-zw)</span></span><br><span class=\"line\"> <span class=\"comment\">//zw.foreach(i=&gt;&#123;print(i)&#125;)</span></span><br><span class=\"line\"> <span class=\"comment\">//zw.foreach(print(_))</span></span><br><span class=\"line\"> <span class=\"comment\">//zw.foreach(print）</span></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建多维数组\"><a href=\"#创建多维数组\" class=\"headerlink\" title=\"创建多维数组\"></a>创建多维数组</h4><p>多维数组一个数组中的值可以是另一个数组，另一个数组的值也可以是一个数组。矩阵与表格是我们常见的二维数组。</p>\n<p>多维数组的声明：<br>**var 数组名 &#x3D; Array.ofDim[元素类型]**（第一维的长度，第二维的长度，……）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   创建多维数组和遍历  以下为二维数组</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">   <span class=\"comment\">//第一种创建二维数组(3行3列)</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> matrix=<span class=\"type\">Array</span>[<span class=\"type\">Array</span>[<span class=\"type\">Int</span>]](<span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>),<span class=\"type\">Array</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>),<span class=\"type\">Array</span>(<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//第二种创建二维数组(3行3列)</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> arr = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Array</span>[<span class=\"type\">String</span>]](<span class=\"number\">3</span>)</span><br><span class=\"line\">   arr(<span class=\"number\">0</span>)=<span class=\"type\">Array</span>(<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">   arr(<span class=\"number\">1</span>)=<span class=\"type\">Array</span>(<span class=\"string\">&quot;4&quot;</span>,<span class=\"string\">&quot;5&quot;</span>,<span class=\"string\">&quot;6&quot;</span>)</span><br><span class=\"line\">   arr(<span class=\"number\">2</span>)=<span class=\"type\">Array</span>(<span class=\"string\">&quot;7&quot;</span>,<span class=\"string\">&quot;8&quot;</span>,<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//第三种创建 var 数组名 = Array.ofDim[元素类型]（第一维的长度，第二维的长度，……）</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> zw=<span class=\"type\">Array</span>.ofDim[<span class=\"type\">Int</span>](<span class=\"number\">3</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i&lt;<span class=\"number\">-0</span> to <span class=\"number\">2</span>;j&lt;<span class=\"number\">-0</span> to <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">     <span class=\"comment\">//循环赋值</span></span><br><span class=\"line\">     zw(i)(j) = (i + <span class=\"number\">1</span>) * <span class=\"number\">10</span> + (j + <span class=\"number\">1</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   zw(<span class=\"number\">0</span>)(<span class=\"number\">1</span>)=<span class=\"number\">520</span>  <span class=\"comment\">//arr1 0行0列 修改值</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 二维数组循环打印：</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"comment\">//1.嵌套for循环打印</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(a&lt;-zw)&#123;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>(b&lt;-a) &#123;</span><br><span class=\"line\">       print(b+<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     println()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//2.foreach  匿名</span></span><br><span class=\"line\">   println(<span class=\"string\">&quot;----分割----&quot;</span>)</span><br><span class=\"line\">   matrix.foreach(z=&gt;&#123;</span><br><span class=\"line\">     z.foreach(a=&gt;</span><br><span class=\"line\">       print(a)</span><br><span class=\"line\">     )</span><br><span class=\"line\">     println()</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   <span class=\"comment\">//3.foreach  最简写法</span></span><br><span class=\"line\">   println(<span class=\"string\">&quot;----分割----&quot;</span>)</span><br><span class=\"line\">   matrix.foreach(arr=&gt; &#123;</span><br><span class=\"line\">     arr.foreach(print)</span><br><span class=\"line\">     println()</span><br><span class=\"line\">   &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组中常用方法举例\"><a href=\"#数组中常用方法举例\" class=\"headerlink\" title=\"数组中常用方法举例\"></a>数组中常用方法举例</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     Array一部分方法:</span></span><br><span class=\"line\"><span class=\"comment\">     1.合并数组:</span></span><br><span class=\"line\"><span class=\"comment\">     def concat[T]( xss: Array[T]* ): Array[T]</span></span><br><span class=\"line\"><span class=\"comment\">     2.填充函数：返回数组，长度为第一个参数指定，同时每个元素使用第二个参数进行填充:</span></span><br><span class=\"line\"><span class=\"comment\">     def fill[T]( n: Int )(elem: =&gt; T): Array[T]</span></span><br><span class=\"line\"><span class=\"comment\">     3.填充函数：返回二维数组，长度为第一个参数指定，同时每个元素使用第二个参数进行填充。</span></span><br><span class=\"line\"><span class=\"comment\">     def fill[T]( n1: Int, n2: Int )( elem: =&gt; T ): Array[Array[T]]</span></span><br><span class=\"line\"><span class=\"comment\">     4.创建区间数组：创建指定区间内的数组，step 为每个元素间的步长:</span></span><br><span class=\"line\"><span class=\"comment\">     def range( start: Int, end: Int, step: Int ): Array[Int]</span></span><br><span class=\"line\"><span class=\"comment\">     5.返回指定长度的数组:返回指定长度数组，每个数组元素为指定函数的返回值，默认从 0 开始:</span></span><br><span class=\"line\"><span class=\"comment\">     def tabulate[T]( n: Int )(f: (Int)=&gt; T): Array[T]</span></span><br><span class=\"line\"><span class=\"comment\">     6.返回指定长度的数组:返回指定长度的二维数组，每个数组元素为指定函数的返回值，默认从 0 开始:</span></span><br><span class=\"line\"><span class=\"comment\">     def tabulate[T]( n1: Int, n2: Int )( f: (Int, Int ) =&gt; T): Array[Array[T]]</span></span><br><span class=\"line\"><span class=\"comment\">     7.返回指定长度的数组:返回指定长度数组，每个数组元素为指定函数的返回值。</span></span><br><span class=\"line\"><span class=\"comment\">     与tablulate不同之处在于同，iterate可以指定函数参数的初始值：</span></span><br><span class=\"line\"><span class=\"comment\">     def iterate[T]( start: T, len: Int )( f: (T) =&gt; T ): Array[T]</span></span><br><span class=\"line\"><span class=\"comment\">     8.复制数组：复制一个数组到另一个数组上 相等于 Java&#x27;s System.arraycopy(src, srcPos, dest, destPos, length)</span></span><br><span class=\"line\"><span class=\"comment\">     def copy( src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int ): Unit</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> array1: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//concat</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array2: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>.concat(array, array1)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;concat：&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (x &lt;- array2)</span><br><span class=\"line\">      print(x + <span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//fill一维数组：</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array3 = <span class=\"type\">Array</span>.fill(<span class=\"number\">2</span>)(<span class=\"string\">&quot;Hello scala&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;fill一维数组：&quot;</span>)</span><br><span class=\"line\">    array3.foreach(print)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//fill二维数组：</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array4 = <span class=\"type\">Array</span>.fill(<span class=\"number\">2</span>, <span class=\"number\">3</span>)(<span class=\"number\">100</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;fill二维数组：&quot;</span>)</span><br><span class=\"line\">    array4.foreach(x =&gt; &#123;</span><br><span class=\"line\">      x.foreach(x =&gt; &#123;</span><br><span class=\"line\">        print(x + <span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      println()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//range</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array5: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>.range(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">2</span>) <span class=\"comment\">//10到20步长为2 返回类型为数组</span></span><br><span class=\"line\">    println(<span class=\"string\">&quot;range：&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (x &lt;- array5)</span><br><span class=\"line\">      print(x + <span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//tabulate[T]( n: Int )(f: (Int)) 返回为一维数组</span></span><br><span class=\"line\">    <span class=\"comment\">//第一个参数为数组长度，第二个参数为匿名函数  x+5 这里的匿名函数参数x 默认为0 x+100就变成从100开始+1</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array6: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>.tabulate(<span class=\"number\">6</span>)(x =&gt; x + <span class=\"number\">11</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;tabulate一维数组：&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (x &lt;- array6)</span><br><span class=\"line\">      print(x + <span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//tabulate[T]( n1: Int, n2: Int )( f: (Int, Int )</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回为二维数组 2行3列</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array7 = <span class=\"type\">Array</span>.tabulate(<span class=\"number\">2</span>, <span class=\"number\">3</span>)((z, w) =&gt; (z + <span class=\"number\">1</span>) * <span class=\"number\">10</span> + (w + <span class=\"number\">1</span>))</span><br><span class=\"line\">    println(<span class=\"string\">&quot;tabulate二维数组：&quot;</span>)</span><br><span class=\"line\">    array7.foreach(x =&gt; &#123;</span><br><span class=\"line\">      x.foreach(x =&gt; &#123;</span><br><span class=\"line\">        print(x + <span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      println()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//copy</span></span><br><span class=\"line\">    println(<span class=\"string\">&quot;copy：&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> array8 = <span class=\"type\">Array</span>.range(<span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">1</span>) <span class=\"comment\">//10,11,12,13,14</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array9 = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Int</span>](<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将array8从第2个元素开始，复制3个元素到array9的第0个元素后面</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (x &lt;- array8)</span><br><span class=\"line\">      print(x + <span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">    <span class=\"type\">Array</span>.copy(array8, <span class=\"number\">2</span>, array9, <span class=\"number\">0</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    println()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (x &lt;- array9)</span><br><span class=\"line\">      print(x + <span class=\"string\">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可变长度数组\"><a href=\"#可变长度数组\" class=\"headerlink\" title=\"可变长度数组\"></a>可变长度数组</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">可变长度数组：</span></span><br><span class=\"line\"><span class=\"comment\">可变和不可变区别就在于长度。scala中默认都是不可变的，想要使用可变的话需要导包</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> arr =<span class=\"type\">ArrayBuffer</span>[<span class=\"type\">String</span>](<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>)     <span class=\"comment\">//ArrayBuffer可变数组</span></span><br><span class=\"line\">arr.append(<span class=\"string\">&quot;d&quot;</span>,<span class=\"string\">&quot;e&quot;</span>,<span class=\"string\">&quot;f&quot;</span>)   <span class=\"comment\">//可以添加任意个元素</span></span><br><span class=\"line\">arr.+=(<span class=\"string\">&quot;end&quot;</span>)             <span class=\"comment\">//最后追加元素</span></span><br><span class=\"line\">arr.+=:(<span class=\"string\">&quot;start&quot;</span>)          <span class=\"comment\">//开头追加元素</span></span><br><span class=\"line\">arr.foreach(println)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并Array\"><a href=\"#合并Array\" class=\"headerlink\" title=\"合并Array\"></a>合并Array</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> zw=<span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> xin=<span class=\"type\">Array</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> result =<span class=\"type\">Array</span>.concat(zw,xin)</span><br><span class=\"line\">result.foreach(println)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"List列表-序列\"><a href=\"#List列表-序列\" class=\"headerlink\" title=\"List列表(序列)\"></a>List列表(序列)</h3><p>序列分为<strong>不可变长序列（List）</strong> 和<strong>可变长序列（ListBuffer）</strong>。不可变集合中添加新元素， 会生成一个新集合， 和不可变集合并不矛盾。给集合中添加元素一般都是从集合头部添加， 或者从集合尾部添加</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * List序列</span></span><br><span class=\"line\"><span class=\"comment\"> * 分为变长和不可变长序列，底层是链表</span></span><br><span class=\"line\"><span class=\"comment\"> * 特点：有序，可重复，增删快，查询慢</span></span><br><span class=\"line\"><span class=\"comment\"> * 不可变长序列：长度和角标都不可变</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Scala 列表类似于数组，它们所有元素的类型都相同，但是它们也有所不同：列表是不可变的，值一旦被定义了就不能改变，其次列表 具有递归的结构（也就是链接表结构）而数组不是。</code></p>\n<ul>\n<li>列表声明：列表的元素类型 T 可以写成 List[T]</li>\n<li>链接表式声明：构造列表的两个基本单位是 Nil 和 ::<ul>\n<li>::表示是链接</li>\n<li>Nil 表示为一个空列表</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"创建List\"><a href=\"#创建List\" class=\"headerlink\" title=\"创建List\"></a>创建List</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建List两种方式:</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.指定长度创建：new Array[Any](3)</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.直接Array初始化赋值创建</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> list1: <span class=\"type\">List</span>[<span class=\"type\">String</span>] =<span class=\"string\">&quot;Google&quot;</span>::(<span class=\"string\">&quot;Baidu&quot;</span>::(<span class=\"string\">&quot;Sina&quot;</span>::<span class=\"type\">Nil</span>))</span><br></pre></td></tr></table></figure>\n\n<p>不要忘记 Nil 是 长度为0的List</p>\n<h4 id=\"List的遍历\"><a href=\"#List的遍历\" class=\"headerlink\" title=\"List的遍历\"></a>List的遍历</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">val</span> list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] =<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i&lt;-list)   <span class=\"comment\">//1.</span></span><br><span class=\"line\">      println(i)</span><br><span class=\"line\">println(<span class=\"string\">&quot;#####&quot;</span>)</span><br><span class=\"line\">    list.foreach(i=&gt;&#123;  <span class=\"comment\">//2. </span></span><br><span class=\"line\">      println(i)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">println(<span class=\"string\">&quot;#####&quot;</span>)</span><br><span class=\"line\">    list.foreach(println)  <span class=\"comment\">//3.</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"List-方法举例\"><a href=\"#List-方法举例\" class=\"headerlink\" title=\"List 方法举例\"></a>List 方法举例</h4><p>List与数组相似，生成、连接List的方法与数组相同</p>\n<p>filter :过滤元素</p>\n<p>count :计算符合条件的元素个数</p>\n<p>map ：对元素操作 传一个逻辑</p>\n<p>flatmap ：压扁扁平,先map再flat</p>\n<p><img src=\"/2022/06/10/scala-ji-chu-bi-ji/3.png\"></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  Array一部分方法:</span></span><br><span class=\"line\"><span class=\"comment\">  1.filter过滤元素：返回列表满足谓词的所有元素</span></span><br><span class=\"line\"><span class=\"comment\">   def filter(p: (A) =&gt; Boolean): List[A]</span></span><br><span class=\"line\"><span class=\"comment\">  2.count计算符合条件的元素个数：</span></span><br><span class=\"line\"><span class=\"comment\">  def count(p: (A) =&gt; Boolean): Int</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//过滤 def filter(p: A =&gt; Boolean)  返回为布尔</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] =<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> zw: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = list.filter(x=&gt;&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(x&gt;<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  计算符合条件的元素个数</span></span><br><span class=\"line\">zw.foreach(println)</span><br><span class=\"line\"><span class=\"keyword\">val</span> xx: <span class=\"type\">Int</span> = list.count(x=&gt;&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(x&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">println(xx)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      方法： </span></span><br><span class=\"line\"><span class=\"comment\">      1.map 1 to 1</span></span><br><span class=\"line\"><span class=\"comment\">      2.flatMap     1 to N</span></span><br><span class=\"line\"><span class=\"comment\">    记住:map是将一个东西变成另一个东西！！！ 未改变</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">//map</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] =<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> zw = list.map(x=&gt;&#123;x*<span class=\"number\">2</span>&#125;)</span><br><span class=\"line\">    zw.foreach(println)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">List</span>(<span class=\"string\">&quot;Hello World&quot;</span>,<span class=\"string\">&quot;Hello BeiJing&quot;</span>,<span class=\"string\">&quot;Hello GanZhou&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = arr.map(x=&gt;&#123;x.split(<span class=\"string\">&quot; &quot;</span>)&#125;)</span><br><span class=\"line\">    result.foreach(x=&gt;&#123;x.foreach(println)&#125;)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将map结果，flat压平，最终形成1进多出</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> xin: <span class=\"type\">List</span>[<span class=\"type\">String</span>] =arr.flatMap(x=&gt;x.split(<span class=\"string\">&quot; &quot;</span>))   </span><br><span class=\"line\">    xin.foreach(println)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可变长度List\"><a href=\"#可变长度List\" class=\"headerlink\" title=\"可变长度List\"></a>可变长度List</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">ListBuffer</span></span><br><span class=\"line\"> <span class=\"keyword\">val</span> listBuffer = <span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>](<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">    listBuffer.append(<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>) <span class=\"comment\">//追加元素</span></span><br><span class=\"line\">    listBuffer.+=(<span class=\"number\">10</span>) <span class=\"comment\">//在后面追加元素</span></span><br><span class=\"line\">    listBuffer.+=:(<span class=\"number\">100</span>) <span class=\"comment\">//在开头追加元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">    println(<span class=\"string\">&quot;集合元素:&quot;</span>)</span><br><span class=\"line\">    listBuffer.foreach(x=&gt;&#123;</span><br><span class=\"line\">      print(x+<span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    listBuffer.remove(<span class=\"number\">3</span>) <span class=\"comment\">//移除集合第3个元素 即移除 3</span></span><br><span class=\"line\">    println(<span class=\"string\">&quot;移除集合第3个元素:&quot;</span>)</span><br><span class=\"line\">    listBuffer.foreach(x=&gt;&#123;</span><br><span class=\"line\">      print(x+<span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    println(<span class=\"string\">&quot;从集合第三个元素开始，移除3个元素:&quot;</span>)</span><br><span class=\"line\">    listBuffer.remove(<span class=\"number\">3</span>,<span class=\"number\">2</span>) <span class=\"comment\">//移除 4 5</span></span><br><span class=\"line\">    listBuffer.foreach(x=&gt;&#123;</span><br><span class=\"line\">      print(x+<span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    println()</span><br><span class=\"line\"></span><br><span class=\"line\">    println(<span class=\"string\">&quot;从集合第三个元素开始，插入3个元素:&quot;</span>)</span><br><span class=\"line\">    listBuffer.insert(<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>) <span class=\"comment\">//移除 4 5</span></span><br><span class=\"line\">    listBuffer.foreach(x=&gt;&#123;</span><br><span class=\"line\">      print(x+<span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并List\"><a href=\"#合并List\" class=\"headerlink\" title=\"合并List\"></a>合并List</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> zw=<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> xin=<span class=\"type\">List</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> result =<span class=\"type\">List</span>.concat(zw,xin)</span><br><span class=\"line\">result.foreach(println)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h3><p>也分为<strong>可变长</strong>和<strong>不可变长集合</strong>，特点:无序，不重复。元素虽然无放入顺序， 但是元素在set中的位置是由该元素的HashCode决定的， 其位置其实是固定的。</p>\n<p><code>可变Set和不可变Set都有添加或删除元素的操作，但是有一个非常大的差别。对不可变Set进行操作，会产生一个新的set，原来的set并没有改变，这与List一样。 而对可变Set进行操作，改变的是该Set本身，与ListBuffer类似。</code></p>\n<h4 id=\"创建Set\"><a href=\"#创建Set\" class=\"headerlink\" title=\"创建Set\"></a>创建Set</h4><p>注意： <code>set集合,是一个无序且不重复的元素集合!!!</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> set1 = <span class=\"type\">Set</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> set2 = <span class=\"type\">Set</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>) </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"遍历Set\"><a href=\"#遍历Set\" class=\"headerlink\" title=\"遍历Set\"></a>遍历Set</h4><p>同样两种方式 for ， foreach</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> set1=<span class=\"type\">Set</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> set2=<span class=\"type\">Set</span>(<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//set集合的创建以及遍历</span></span><br><span class=\"line\">set1.foreach(println)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i&lt;-set1)</span><br><span class=\"line\">      println(i)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Set方法举例\"><a href=\"#Set方法举例\" class=\"headerlink\" title=\"Set方法举例\"></a>Set方法举例</h4><ol>\n<li><p>交集： intersect , &amp;</p>\n</li>\n<li><p>差集： diff , &amp;~</p>\n</li>\n<li><p>子集： subsetOf</p>\n</li>\n<li><p>最大： max</p>\n</li>\n<li><p>最小： min</p>\n</li>\n<li><p>转成数组： toList</p>\n</li>\n<li><p>转成字符串： mkString</p>\n</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法举例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> set1=<span class=\"type\">Set</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> set2=<span class=\"type\">Set</span>(<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//交集:共有部分拿出来 返回新的set集合</span></span><br><span class=\"line\"><span class=\"comment\">//val set5=set1.&amp;(set2).foreach(println)    可使用 &amp;符号代替</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> set5=set1.intersect(set2).foreach(println)  <span class=\"comment\">//  result=3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//差集:共有的内容 去除 返回新的set集合</span></span><br><span class=\"line\"><span class=\"comment\">// val set4=set1.&amp;~(set2).foreach(println)   可使用 &amp;~符号代替</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> set4=set1.diff(set2).foreach(println)   <span class=\"comment\">//共有3 所以去除了 result=1 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//子集:测试一个集合是否是另一个集合的子集  是否包含在里面</span></span><br><span class=\"line\">println(set1.subsetOf(set2))  <span class=\"comment\">//  set1是否是set2的子集 false</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//最大值</span></span><br><span class=\"line\">println(set1.max)</span><br><span class=\"line\"><span class=\"comment\">//最小值</span></span><br><span class=\"line\">println(set1.min)  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//转成数组，list</span></span><br><span class=\"line\">set1.toArray.foreach&#123;println&#125;</span><br><span class=\"line\">println(<span class=\"string\">&quot;****&quot;</span>)</span><br><span class=\"line\">set1.toList.foreach&#123;println&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//mkString</span></span><br><span class=\"line\">println(set1.mkString)</span><br><span class=\"line\">println(set1.mkString(<span class=\"string\">&quot;\\t&quot;</span>)) <span class=\"comment\">//传参数 不传：去掉括号\\t分割  set转换为String</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可变长度Set\"><a href=\"#可变长度Set\" class=\"headerlink\" title=\"可变长度Set\"></a>可变长度Set</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Set</span> <span class=\"comment\">//可变的  需要导包！！！</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> set=<span class=\"type\">Set</span>[<span class=\"type\">Int</span>](<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)   </span><br><span class=\"line\">    set.add(<span class=\"number\">1</span>)    <span class=\"comment\">//add只能加一个元素</span></span><br><span class=\"line\">    set.+=(<span class=\"number\">6</span>,<span class=\"number\">7</span>)   <span class=\"comment\">//+=可以加很多元素</span></span><br><span class=\"line\">    set.foreach(println)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并Set\"><a href=\"#合并Set\" class=\"headerlink\" title=\"合并Set\"></a>合并Set</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> zw=<span class=\"type\">Set</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">   <span class=\"keyword\">var</span> xin=<span class=\"type\">Set</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">   <span class=\"keyword\">var</span> result: <span class=\"type\">Set</span>[<span class=\"type\">Int</span>] =zw.++(xin)</span><br><span class=\"line\">   println(result)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map映射\"><a href=\"#Map映射\" class=\"headerlink\" title=\"Map映射\"></a>Map映射</h3><ul>\n<li>Map(映射)是一种可迭代的键值对（key&#x2F;value）结构。所有的值都可以通过键来获取。</li>\n<li>Map 中的键都是唯一的，Map 也叫哈希表（Hash tables）。</li>\n<li>Map 有两种类型，可变与不可变，区别在于可变对象可以修改它，而不可变对象不可以。</li>\n<li>默认情况下 Scala 使用不可变 Map。如果你需要使用可变集合，你需要显式的引入 import scala.collection.mutable.Map 类。在 Scala 中 你可以同时使用可变与不可变 Map，不可变的直接使用 Map，可变的使用 mutable.Map。</li>\n</ul>\n<h4 id=\"创建Map\"><a href=\"#创建Map\" class=\"headerlink\" title=\"创建Map\"></a>创建Map</h4><ul>\n<li><p>Map(“name”-&gt;”kli”) 键 -&gt; 值的对应关系创建</p>\n</li>\n<li><p>Map((“money”,200)) 元组的形式（key，value）</p>\n<p> 创建 map 时，相同的 key 被后面的相同的 key 顶替掉，只保留一个。</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map: <span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">Any</span>] =<span class=\"type\">Map</span>(<span class=\"string\">&quot;name&quot;</span>-&gt;<span class=\"string\">&quot;kli&quot;</span>,(<span class=\"string\">&quot;money&quot;</span>,<span class=\"number\">200</span>))</span><br><span class=\"line\"><span class=\"comment\">//  两种创建方式</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Map基本操作\"><a href=\"#Map基本操作\" class=\"headerlink\" title=\"Map基本操作\"></a>Map基本操作</h4><ul>\n<li>keys：返回 Map 所有的键(key)</li>\n<li>values：返回 Map 所有的值(value)</li>\n<li>isEmpty：在 Map 为空时返回true</li>\n<li>+(key-&gt;value)：添加元素</li>\n<li>++ 运算符或 Map.++() ：来连接两个 Map，Map 合并时会移除重复的 key</li>\n</ul>\n<h4 id=\"获取Map的值\"><a href=\"#获取Map的值\" class=\"headerlink\" title=\"获取Map的值\"></a>获取Map的值</h4><ul>\n<li><strong>map.get(“name”).get</strong></li>\n<li><strong>map.get(<em>“name”</em>).getOrElse(“no value”)</strong> 此种方式如果 map 中没有对应项则赋值为getOrElse 里面的值。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">val</span> map: <span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">Any</span>] =<span class=\"type\">Map</span>(<span class=\"string\">&quot;name&quot;</span>-&gt;<span class=\"string\">&quot;kli&quot;</span>,(<span class=\"string\">&quot;money&quot;</span>,<span class=\"number\">200</span>))</span><br><span class=\"line\">println(map.get(<span class=\"string\">&quot;name&quot;</span>).get)</span><br><span class=\"line\">   println(map.get(<span class=\"string\">&quot;name&quot;</span>).getOrElse(<span class=\"string\">&quot;none&quot;</span>))</span><br><span class=\"line\">   <span class=\"comment\">//如果不确定key存不存在，则使用getOrElse更为稳当</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"遍历key-amp-value\"><a href=\"#遍历key-amp-value\" class=\"headerlink\" title=\"遍历key&amp;value\"></a>遍历key&amp;value</h4><p><code>x._1为：key   x._2为：value</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//map遍历</span></span><br><span class=\"line\">map.foreach(x=&gt;&#123;   <span class=\"comment\">// 1.</span></span><br><span class=\"line\">  \tprintln(map.get(x._1).get)  <span class=\"comment\">//使用key.get</span></span><br><span class=\"line\">    println(x._2)   <span class=\"comment\">//直接获取value</span></span><br><span class=\"line\">  <span class=\"comment\">//println(map.getOrElse(x._1,&quot;none&quot;))</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据key来遍历Map </span></span><br><span class=\"line\"><span class=\"keyword\">val</span> keys: <span class=\"type\">Iterable</span>[<span class=\"type\">String</span>] = map.keys</span><br><span class=\"line\">\tkeys.foreach(x=&gt; &#123;\t<span class=\"comment\">//这里的 x 为key 通过key找到值</span></span><br><span class=\"line\">  \t  println(map.get(x).get)</span><br><span class=\"line\">  <span class=\"comment\">//第一个get返回的为:Option Some(kli) 第二个get返回的为:key对应的值 </span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据value遍历Map 获取value</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> values: <span class=\"type\">Iterable</span>[<span class=\"type\">Any</span>] = map.values</span><br><span class=\"line\">    values.foreach(values=&gt;&#123;</span><br><span class=\"line\">      println(values)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并Map\"><a href=\"#合并Map\" class=\"headerlink\" title=\"合并Map\"></a>合并Map</h4><p>注意：map合并：相同的key值对应的value值会发生覆盖</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map1=<span class=\"type\">Map</span>(<span class=\"string\">&quot;name&quot;</span>-&gt;<span class=\"string\">&quot;kli&quot;</span>,<span class=\"string\">&quot;age&quot;</span>-&gt;<span class=\"number\">18</span>,(<span class=\"string\">&quot;monney&quot;</span>,<span class=\"number\">200</span>))</span><br><span class=\"line\"><span class=\"keyword\">val</span> map2=<span class=\"type\">Map</span>(<span class=\"string\">&quot;name&quot;</span>-&gt;<span class=\"string\">&quot;xin&quot;</span>,<span class=\"string\">&quot;age&quot;</span>-&gt;<span class=\"number\">19</span>,(<span class=\"string\">&quot;monney&quot;</span>,<span class=\"number\">100</span>))</span><br><span class=\"line\"><span class=\"keyword\">val</span> map3=map1.++(map2)  <span class=\"comment\">//map2 合并 map1 相同值发生覆盖</span></span><br><span class=\"line\"><span class=\"comment\">//val map3=map1.++:(map2)  加了 ： 相当于 map2.++(map1) 相反</span></span><br><span class=\"line\">map3.foreach(x=&gt;&#123;</span><br><span class=\"line\">  println(x._1+<span class=\"string\">&quot;:&quot;</span>+x._2)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Map方法\"><a href=\"#Map方法\" class=\"headerlink\" title=\"Map方法\"></a>Map方法</h4><ul>\n<li><p>filter :过滤，留下符合条件的记录</p>\n</li>\n<li><p>count :统计符合条件的记录数</p>\n</li>\n<li><p>contains ： map 中是否包含某个 key</p>\n</li>\n<li><p>exist ：符合条件的记录存在与否</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">val</span> map: <span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>] =<span class=\"type\">Map</span>(<span class=\"string\">&quot;age1&quot;</span>-&gt;<span class=\"number\">10</span>,(<span class=\"string\">&quot;age2&quot;</span>,<span class=\"number\">21</span>),(<span class=\"string\">&quot;age3&quot;</span>,<span class=\"number\">30</span>))</span><br><span class=\"line\"><span class=\"comment\">//过滤</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> map1 = map.filter(x =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x._2&gt;<span class=\"number\">20</span>)</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    map1.foreach(x=&gt;println(x))</span><br><span class=\"line\"><span class=\"comment\">//统计</span></span><br><span class=\"line\"> <span class=\"keyword\">val</span> result = map.count(x =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x._2&gt;<span class=\"number\">20</span>)</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    println(result)</span><br><span class=\"line\"><span class=\"comment\">// map 中是否包含某个 key</span></span><br><span class=\"line\">println(map.contains(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(map.contains(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\">      println(map.get(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      println(<span class=\"string\">&quot;none&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    println(map.getOrElse(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;no value&quot;</span>))</span><br><span class=\"line\"><span class=\"comment\">//exist</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> bool= map.exists(x =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(x._2&gt;<span class=\"number\">20</span>) &#123;   <span class=\"comment\">//判断符合逻辑就会停止遍历数据</span></span><br><span class=\"line\">        println(x._1)</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  println(bool)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可变长度Map\"><a href=\"#可变长度Map\" class=\"headerlink\" title=\"可变长度Map\"></a>可变长度Map</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Map</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> map: <span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">Any</span>] =<span class=\"type\">Map</span>(<span class=\"string\">&quot;age1&quot;</span>-&gt;<span class=\"string\">&quot;1&quot;</span>,(<span class=\"string\">&quot;age2&quot;</span>,<span class=\"number\">2</span>))</span><br><span class=\"line\">    <span class=\"comment\">//如果你想要添加一个原来的map中没有的value类型，要么就手动显示[String，Any]</span></span><br><span class=\"line\">    map+=(<span class=\"string\">&quot;age3&quot;</span>-&gt;<span class=\"number\">3</span>)     <span class=\"comment\">//单个添加</span></span><br><span class=\"line\">    map+=(<span class=\"string\">&quot;age4&quot;</span>-&gt;<span class=\"number\">4</span>,<span class=\"string\">&quot;age5&quot;</span>-&gt;<span class=\"number\">5</span>)<span class=\"comment\">//多个添加</span></span><br><span class=\"line\">    map.foreach(println)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;============&quot;</span>)</span><br><span class=\"line\">    map-=(<span class=\"string\">&quot;age4&quot;</span>)<span class=\"comment\">//删除直接针对key值。map.remove(&quot;age&quot;)</span></span><br><span class=\"line\">    map.remove(<span class=\"string\">&quot;age5&quot;</span>)</span><br><span class=\"line\">    map.foreach(println)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"元组-Tuple\"><a href=\"#元组-Tuple\" class=\"headerlink\" title=\"元组 Tuple\"></a>元组 Tuple</h3><ul>\n<li><p>元组与列表一样，元组也是不可变的，但与列表不同的是元组可以包含不同类型的元素。元组的值是通过将单个的值包含在圆括号中构成的。</p>\n</li>\n<li><p>是K&#x2F;V对偶的集合， 对偶是元组最简单的形式， 元组可以封装多个不同类型的值， 注意元组的角标是从1 开始的 。</p>\n</li>\n</ul>\n<h4 id=\"创建元组\"><a href=\"#创建元组\" class=\"headerlink\" title=\"创建元组\"></a>创建元组</h4><ul>\n<li><p>val tuple &#x3D; new Tuple(1)</p>\n</li>\n<li><p>val tuple2 &#x3D; Tuple2(1,2) ，也可以直接写成 val tuple3 &#x3D;(1,2,3)</p>\n</li>\n<li><p>取值用 ._X 可以获取元组中的值</p>\n</li>\n</ul>\n<p>注意：tuple最多支持<strong>22</strong>个参数。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建，最多支持22个</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> tuple = <span class=\"keyword\">new</span> <span class=\"type\">Tuple1</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> tuple2 = <span class=\"type\">Tuple2</span>(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> tuple3 = <span class=\"type\">Tuple3</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> tuple4 = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> tuple18 = <span class=\"type\">Tuple18</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>,<span class=\"number\">14</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>,<span class=\"number\">17</span>,<span class=\"number\">18</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> tuple22 = <span class=\"keyword\">new</span> <span class=\"type\">Tuple22</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>,<span class=\"number\">14</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>,<span class=\"number\">17</span>,<span class=\"number\">18</span>,<span class=\"number\">19</span>,<span class=\"number\">20</span>,<span class=\"number\">21</span>,<span class=\"number\">22</span>)</span><br><span class=\"line\">    <span class=\"comment\">//使用</span></span><br><span class=\"line\">    println(tuple2._1 + <span class=\"string\">&quot;\\t&quot;</span>+tuple2._2)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> t = <span class=\"type\">Tuple2</span>((<span class=\"number\">1</span>,<span class=\"number\">2</span>),(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>))</span><br><span class=\"line\">    println(t._1._2)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"元组简单的方法\"><a href=\"#元组简单的方法\" class=\"headerlink\" title=\"元组简单的方法\"></a>元组简单的方法</h4><pre><code>例如 swap ， toString 方法。注意 swap 的元素翻转只针对二元组。\n</code></pre>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//翻转，只针对二元组</span></span><br><span class=\"line\">println(tuple2.swap)</span><br><span class=\"line\"><span class=\"comment\">//toString</span></span><br><span class=\"line\">println(tuple3.toString())</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"遍历元组\"><a href=\"#遍历元组\" class=\"headerlink\" title=\"遍历元组\"></a>遍历元组</h4><p>虽然元组不是集合，但是在遍历使用时可以当作一个集合来用。</p>\n<p>通过 tuple.productIterator 得到迭代器，进而实现遍历。迭代器只能使用一次，下次还想遍历就需要构建一个新的 iterator 。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> tupleIterator = tuple22.productIterator</span><br><span class=\"line\"><span class=\"comment\">//    while(tupleIterator.hasNext)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      println(tupleIterator.next())</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">    tupleIterator.foreach(value =&gt;&#123;</span><br><span class=\"line\">      println(<span class=\"string\">&quot;value: &quot;</span>+ value)&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><ul>\n<li>Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法。</li>\n<li>迭代器 it 的两个基本操作是 next 和 hasNext。调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。调用 it.hasNext() 用于检测集合中是否还有元素。</li>\n<li>让迭代器 it 逐个返回所有元素最简单的方法是使用 while 循环。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set=<span class=\"type\">Set</span>(<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>)</span><br><span class=\"line\">   <span class=\"keyword\">var</span> it =set.toIterator;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(it.hasNext)&#123;</span><br><span class=\"line\">     println(it.next())</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//result=30 20 10</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"trait\"><a href=\"#trait\" class=\"headerlink\" title=\"trait\"></a>trait</h3><p><code>类似java中interfaces和abstract结合</code></p>\n<p>注意：</p>\n<ul>\n<li><p>继承的多个trait中如果有同名的方法和属性，必须要在类中使用 override 重新定义。</p>\n</li>\n<li><p>trait 中不可以传参数</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 在一个二维坐标系内，比较两个点是否是同一位置</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Equal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//比较相同</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isEqual</span></span>(x: <span class=\"type\">Any</span>): <span class=\"type\">Boolean</span>  <span class=\"comment\">//抽象</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//比较不同</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNotEqual</span></span>(x: <span class=\"type\">Any</span>) = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//感叹号 不等  ！取反</span></span><br><span class=\"line\">    !isEqual(x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>(<span class=\"params\">xx: <span class=\"type\">Int</span>, yy: <span class=\"type\">Int</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Equal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> x = xx</span><br><span class=\"line\">  <span class=\"keyword\">val</span> y = yy</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isEqual</span></span>(p: <span class=\"type\">Any</span>): <span class=\"type\">Boolean</span> = &#123;   <span class=\"comment\">//重写抽象 override</span></span><br><span class=\"line\">    <span class=\"comment\">//判断isInstanceOf,如果是该类的对象的话</span></span><br><span class=\"line\">    <span class=\"comment\">// 就是判断是不是一个类的对象然后再执行，if Point类的话就执行下一条</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.isInstanceOf[<span class=\"type\">Point</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> point = p.asInstanceOf[<span class=\"type\">Point</span>]</span><br><span class=\"line\">      <span class=\"comment\">//如果传进来的值，相等返回true</span></span><br><span class=\"line\">      xx == point.x &amp;&amp; yy == point.y</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test_trait</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> p1=<span class=\"keyword\">new</span> <span class=\"type\">Point</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> p2=<span class=\"keyword\">new</span> <span class=\"type\">Point</span>(<span class=\"number\">2</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\">//判断</span></span><br><span class=\"line\">    println(p1.isEqual(p2))     <span class=\"comment\">//是否相等</span></span><br><span class=\"line\">    println(p1.isNotEqual(p2))  <span class=\"comment\">//是否不相等</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模式匹配-match\"><a href=\"#模式匹配-match\" class=\"headerlink\" title=\"模式匹配 match\"></a>模式匹配 match</h3><p>Scala 提供了强大的模式匹配机制，应用也非常广泛。</p>\n<p>一个模式匹配包含了一系列备选项，每个都开始于关键字 case 。</p>\n<p>每个备选项都包含了一个模式及一到多个表达式。箭头符号 &#x3D;&gt; 隔开了模式和表达式。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test_Match</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> tuple4:(<span class=\"type\">Int</span>,<span class=\"type\">String</span>,<span class=\"type\">Float</span>,<span class=\"type\">Char</span>)=(<span class=\"number\">1</span>,<span class=\"string\">&quot;2&quot;</span>,<span class=\"number\">3.0</span>f,&#x27;d&#x27;)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> iterator=tuple4.productIterator</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(iterator.hasNext)&#123;</span><br><span class=\"line\">      test_Match(iterator.next())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 注意点：</span></span><br><span class=\"line\"><span class=\"comment\">   * 1.模式匹配不仅可以匹配值，还可以匹配类型</span></span><br><span class=\"line\"><span class=\"comment\">   * 2.模式匹配中，如果匹配到对应的类型或值，就不再继续往下匹配</span></span><br><span class=\"line\"><span class=\"comment\">   * 3.模式匹配中，都匹配不上时，会匹配到 case _ ，相当于default</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_Match</span></span>(x:<span class=\"type\">Any</span>): <span class=\"type\">Unit</span> =&#123;</span><br><span class=\"line\">    x <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//匹配类型</span></span><br><span class=\"line\">      <span class=\"comment\">//case _:String=&gt;println(&quot;mach String&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//匹配值</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>=&gt;println(<span class=\"string\">&quot;match int 1&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;2&quot;</span>=&gt;println(<span class=\"string\">&quot;match String 2&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">3.0</span>f=&gt;println(<span class=\"string\">&quot;match String 3.0&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> &#x27;d&#x27;=&gt;println(<span class=\"string\">&quot;match char d&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//没有匹配到</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> _=&gt;println(<span class=\"string\">&quot;no matching&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ul>\n<li><p>模式匹配不仅可以匹配值还可以匹配类型</p>\n</li>\n<li><p>从上到下顺序匹配，如果匹配到则不再往下匹配</p>\n</li>\n<li><p>都匹配不上时，会匹配到 case _ ,相当于 default</p>\n</li>\n<li><p>match 的最外面的 { } 可以去掉看成一个语句</p>\n</li>\n</ul>\n<h3 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h3><p>如果一个方法中没有 match 只有 case ，这个函数可以定义成 PartialFunction偏函数 。偏函数定义时，不能使用括号传参，默认定义 PartialFunction 中传入一个值，匹配上了对应的 case ,返回一个值，只能匹配同种类型。</p>\n<p>一个 case 语句就可以理解为是一段匿名函数。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一个函数中只有case 没有match ，可以定义成PartailFunction 偏函数</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Lesson_PartialFunction</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MyTest</span> </span>: <span class=\"type\">PartialFunction</span>[<span class=\"type\">String</span>,<span class=\"type\">String</span>] = &#123;</span><br><span class=\"line\">       <span class=\"keyword\">case</span> <span class=\"string\">&quot;scala&quot;</span> =&gt;&#123;<span class=\"string\">&quot;scala&quot;</span>&#125;</span><br><span class=\"line\">       <span class=\"keyword\">case</span> <span class=\"string\">&quot;hello&quot;</span> =&gt;&#123;<span class=\"string\">&quot;hello&quot;</span>&#125;</span><br><span class=\"line\">       <span class=\"keyword\">case</span> _ =&gt; &#123;<span class=\"string\">&quot;no match ...&quot;</span>&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">         println(<span class=\"type\">MyTest</span>(<span class=\"string\">&quot;scala&quot;</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 第二个例子</span></span><br><span class=\"line\"><span class=\"comment\">  * map和collect的区别。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">   <span class=\"keyword\">val</span> list1 = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"string\">&quot;seven&quot;</span>) map &#123;</span><br><span class=\"line\">       <span class=\"type\">MyTest</span></span><br><span class=\"line\">  &#125;<span class=\"comment\">//List(1, 3, 5, &quot;seven&quot;) map &#123; case i: Int =&gt; i + 1 &#125;</span></span><br><span class=\"line\">   list1.foreach(println)</span><br><span class=\"line\">   <span class=\"keyword\">val</span> list = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"string\">&quot;seven&quot;</span>) collect &#123;</span><br><span class=\"line\">       <span class=\"type\">MyTest</span></span><br><span class=\"line\">  &#125;<span class=\"comment\">//List(1, 3, 5, &quot;seven&quot;) collect &#123; case i: Int =&gt; i + 1 &#125;</span></span><br><span class=\"line\">   list.foreach(println) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MyTest</span></span>: <span class=\"type\">PartialFunction</span>[<span class=\"type\">Any</span>, <span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> i: <span class=\"type\">Int</span> =&gt; i + <span class=\"number\">1</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">println(<span class=\"type\">MyTest</span>(<span class=\"string\">&quot;scala&quot;</span>))</span><br><span class=\"line\">     <span class=\"comment\">//val list=List(1,3,5,&quot;seven&quot;).map&#123;case i:Int =&gt;i+i&#125;</span></span><br><span class=\"line\">     <span class=\"comment\">// 错误：偏函数类型都是要一致的  MatchError  collect可以</span></span><br><span class=\"line\">     <span class=\"keyword\">val</span> list=<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"string\">&quot;seven&quot;</span>).collect&#123;<span class=\"keyword\">case</span> i:<span class=\"type\">Int</span> =&gt;i+<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">     list.foreach(println)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MyTest</span></span>:<span class=\"type\">PartialFunction</span>[<span class=\"type\">String</span>,<span class=\"type\">String</span>] =&#123;</span><br><span class=\"line\">     <span class=\"keyword\">case</span> <span class=\"string\">&quot;Hello&quot;</span>=&gt;<span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">     <span class=\"keyword\">case</span> <span class=\"string\">&quot;scala&quot;</span>=&gt;<span class=\"string\">&quot;scala&quot;</span></span><br><span class=\"line\">     <span class=\"keyword\">case</span> _=&gt;<span class=\"string\">&quot;no matching&quot;</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"样例类\"><a href=\"#样例类\" class=\"headerlink\" title=\"样例类\"></a>样例类</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h4><p>​    使用了 case 关键字的类定义就是样例类 case classes ，样例类是种特殊的类。实现了类构造参数的 getter 方法（构造参数默认被声明为 val ），当构造参数是声明为 var 类型的，它将帮你实现setter 和 getter 方法。</p>\n<ul>\n<li><p>样例类默认帮你实现了 toString , equals ， copy 和 hashCode 等方法。</p>\n</li>\n<li><p>样例类可以 new , 也可以不用 new</p>\n</li>\n</ul>\n<h4 id=\"具体写法\"><a href=\"#具体写法\" class=\"headerlink\" title=\"具体写法\"></a>具体写法</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Auther:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * @Date: 2022/6/26</span></span><br><span class=\"line\"><span class=\"comment\"> * @Description: com.bigdata.chapter01</span></span><br><span class=\"line\"><span class=\"comment\"> * @Version:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//样例类默认帮你实现了 toString , equals ， copy 和 hashCode 等方法。</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Boy</span>(<span class=\"params\">name:<span class=\"type\">String</span>,age:<span class=\"type\">Int</span></span>)  <span class=\"comment\">//val</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test_CaseClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> boy =<span class=\"keyword\">new</span> <span class=\"type\">Boy</span>(<span class=\"string\">&quot;zw&quot;</span>,<span class=\"number\">18</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> boy2=<span class=\"type\">Boy</span>(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">18</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    println(boy)  <span class=\"comment\">//重写的toString方法</span></span><br><span class=\"line\">    println(boy.equals(boy2))  <span class=\"comment\">//重写equals</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list: <span class=\"type\">List</span>[<span class=\"type\">Boy</span>] =<span class=\"type\">List</span>(boy,boy2)  <span class=\"comment\">//把对象存进List</span></span><br><span class=\"line\">    list.foreach(x=&gt;&#123;</span><br><span class=\"line\">      <span class=\"comment\">//结合模式匹配</span></span><br><span class=\"line\">        x <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"type\">Boy</span>(<span class=\"string\">&quot;zw&quot;</span>,<span class=\"number\">18</span>)=&gt;println(<span class=\"string\">&quot;im zw&quot;</span>)      <span class=\"comment\">//具体的值</span></span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"type\">Boy</span>(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">18</span>)=&gt;println(<span class=\"string\">&quot;im zhangsan&quot;</span>)</span><br><span class=\"line\">          <span class=\"comment\">//这里想演示的是如果按之前 Int String flat char 类型匹配的话，要找到对应类型的equals方法</span></span><br><span class=\"line\">          <span class=\"comment\">//对于Boy,是具体的值，它属于Boy样例类，已经帮我们写好了，重写了equals方法</span></span><br><span class=\"line\">          <span class=\"comment\">//equals原理就是比较属性值，属性值一一对应就是一个相同的Boy</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">case</span> x:<span class=\"type\">Boy</span>=&gt;println(<span class=\"string\">&quot;boy&quot;</span>)                <span class=\"comment\">//具体类型</span></span><br><span class=\"line\">          <span class=\"keyword\">case</span> _=&gt;println(<span class=\"string\">&quot;no mach&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h1><ul>\n<li><p><a href=\"https://www.yuque.com/asange-3skzu/oxof64\">A三哥</a></p>\n</li>\n<li><p><a href=\"https://www.it610.com/article/1288174765441331200.htm\"><strong>Devin01213</strong></a></p>\n</li>\n<li><p>b站：湖南码歌</p>\n</li>\n</ul>\n","categories":["Scala"],"tags":["Scala"]},{"title":"Scrapy","url":"/2022/08/05/scrapy/","content":"<h1 id=\"Scrapy\"><a href=\"#Scrapy\" class=\"headerlink\" title=\"Scrapy\"></a>Scrapy</h1><h2 id=\"Scrapy是什么？\"><a href=\"#Scrapy是什么？\" class=\"headerlink\" title=\"Scrapy是什么？\"></a>Scrapy是什么？</h2><p> Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理 或存储历史数据等一系列的程序中。</p>\n<p>安装scrapy：<br><strong>pip install scrapy</strong></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">spiders</span><br><span class=\"line\">\t__init__.py</span><br><span class=\"line\">\t自定义的爬虫文件.py ‐‐‐》由我们自己创建，是实现爬虫核心功能的文件</span><br><span class=\"line\">__init__.py</span><br><span class=\"line\">items.py ‐‐‐》定义数据结构的地方，是一个继承自scrapy.Item的类</span><br><span class=\"line\">middlewares.py ‐‐‐》中间件 代理</span><br><span class=\"line\">pipelines.py ‐‐‐》管道文件，里面只有一个类，用于处理下载数据的后续处理默认是<span class=\"number\">300</span>优先级，值越小优先级越高（<span class=\"number\">1</span>‐<span class=\"number\">1000</span>）</span><br><span class=\"line\">settings.py ‐‐‐》配置文件 比如：是否遵守robots协议，User‐Agent定义等</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">注意：应在spiders文件夹内执</span><br><span class=\"line\"></span><br><span class=\"line\">创建项目：</span><br><span class=\"line\">scrapy startproject 项目名</span><br><span class=\"line\"></span><br><span class=\"line\">创建爬虫文件：</span><br><span class=\"line\">scrapy genspider 爬虫名 域名</span><br><span class=\"line\"></span><br><span class=\"line\">运行：</span><br><span class=\"line\">scrapy crawl 爬虫名</span><br></pre></td></tr></table></figure>\n\n<p>创建后目录大致页如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|-ProjectName              #项目文件夹</span><br><span class=\"line\"></span><br><span class=\"line\">   |-ProjectName           #项目目录</span><br><span class=\"line\">         |-spiders               </span><br><span class=\"line\">    </span><br><span class=\"line\">          |-__init__.py       #爬虫文件</span><br><span class=\"line\">    </span><br><span class=\"line\">          |-baidu.py          #自定义的爬虫文件 核心功能</span><br><span class=\"line\"></span><br><span class=\"line\">      |-items.py               #定义数据结构</span><br><span class=\"line\">    </span><br><span class=\"line\">      |-middlewares.py        #中间件</span><br><span class=\"line\">    </span><br><span class=\"line\">      |-pipelines.py          #数据处理</span><br><span class=\"line\">    </span><br><span class=\"line\">      |-settings.py            #全局配置</span><br><span class=\"line\"></span><br><span class=\"line\">   |-scrapy.cfg               #项目基本配置文件</span><br></pre></td></tr></table></figure>\n<h2 id=\"Scrapy架构\"><a href=\"#Scrapy架构\" class=\"headerlink\" title=\"Scrapy架构\"></a>Scrapy架构</h2><h3 id=\"Scrapy架构组成\"><a href=\"#Scrapy架构组成\" class=\"headerlink\" title=\"Scrapy架构组成\"></a>Scrapy架构组成</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）引擎 ‐‐‐》自动运行，无需关注，会自动组织所有的请求对象，分发给下载器</span><br><span class=\"line\">（2）下载器 ‐‐‐》从引擎处获取到请求对象后，请求数据</span><br><span class=\"line\">（3）spiders ‐‐‐》Spider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。 换句话说，Spider就是您定义爬取的动作及分析某个网页(或者是有些网页)的地方。</span><br><span class=\"line\">（4）调度器 ‐‐‐》有自己的调度规则，无需关注</span><br><span class=\"line\">（5）管道（Item pipeline） ‐‐‐》最终处理数据的管道，会预留接口供我们处理数据当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。</span><br><span class=\"line\">以下是item pipeline的一些典型应用：</span><br><span class=\"line\">1. 清理HTML数据</span><br><span class=\"line\">2. 验证爬取的数据(检查item包含某些字段)</span><br><span class=\"line\">3. 查重(并丢弃)</span><br><span class=\"line\">4. 将爬取结果保存到数据库中</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Scrapy工作原理\"><a href=\"#Scrapy工作原理\" class=\"headerlink\" title=\"Scrapy工作原理\"></a>Scrapy工作原理</h3><img src=\"/2022/08/05/scrapy/1.png\" style=\"zoom:80%;\">\n\n<img src=\"/2022/08/05/scrapy/2.png\" style=\"zoom:80%;\">\n\n<h2 id=\"全局配置文件settings-py\"><a href=\"#全局配置文件settings-py\" class=\"headerlink\" title=\"全局配置文件settings.py\"></a>全局配置文件settings.py</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">BOT_NAME = <span class=\"string\">&#x27;scrapy_baidu_091&#x27;</span>  <span class=\"comment\">#项目名</span></span><br><span class=\"line\">ROBOTSTXT_OBEY = <span class=\"literal\">False</span> \t\t   <span class=\"comment\">#是否遵循机器人协议</span></span><br><span class=\"line\">CONCURRENT_REQUESTS = <span class=\"number\">32</span>       <span class=\"comment\">#最大并发数</span></span><br><span class=\"line\">DOWNLOAD_DELAY = <span class=\"number\">3</span>   \t\t   <span class=\"comment\">#下载延迟时间</span></span><br><span class=\"line\">COOKIES_ENABLED = <span class=\"literal\">False</span>        <span class=\"comment\">#是否保存Cookies</span></span><br><span class=\"line\">DEFAULT_REQUEST_HEADERS = &#123;    <span class=\"comment\">#默认请求头</span></span><br><span class=\"line\">   <span class=\"string\">&#x27;Accept&#x27;</span>: <span class=\"string\">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class=\"line\">   <span class=\"string\">&#x27;Accept-Language&#x27;</span>: <span class=\"string\">&#x27;en&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ITEM_PIPELINES = &#123;             <span class=\"comment\">#项目管道，300为优先级，越低爬取的优先度越高</span></span><br><span class=\"line\">   <span class=\"string\">&#x27;scrapy_baidu_091.pipelines.ScrapyBaidu091Pipeline&#x27;</span>: <span class=\"number\">300</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"转载原文链接\"><a href=\"#转载原文链接\" class=\"headerlink\" title=\"转载原文链接\"></a>转载原文链接</h1><p><a href=\"https://www.cnblogs.com/value-code/p/8270037.html\">爬虫基本原理及requests,response详解</a></p>\n<p><a href=\"https://blog.csdn.net/ck784101777/article/details/104468780\">Scrapy爬虫框架，入门案例(非常详细)</a></p>\n","categories":["Python"],"tags":["python"]},{"title":"SparkCore","url":"/2022/06/29/sparkcore/","content":"<h1 id=\"第一章-Spark-概述\"><a href=\"#第一章-Spark-概述\" class=\"headerlink\" title=\"第一章 Spark 概述\"></a>第一章 Spark 概述</h1><p>Spark 是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。</p>\n<h3 id=\"Spark-or-Hadoop\"><a href=\"#Spark-or-Hadoop\" class=\"headerlink\" title=\"Spark or Hadoop\"></a>Spark or Hadoop</h3><p>Hadoop 的 MR 框架和 Spark 框架都是数据处理框架，那么我们在使用时如何选择呢？</p>\n<ul>\n<li><p><strong>Hadoop MapReduce 由于其设计初衷并不是为了满足循环迭代式数据流处理，因此在多并行运行的数据可复 用场景（如：机器学习、图挖掘算法、交互式数据挖掘算法）中存在诸多计算效率等问题</strong>。所以 Spark 应运而生， Spark 就是在传统的 MapReduce 计算框架的基础上，利用其计算过程的优化，从而大大加快了数据分析、挖掘的 运行和读写速度，并将计算单元缩小到更适合并行计算和重复使用的 RDD 计算模型。</p>\n</li>\n<li><p><strong>机器学习中 ALS、凸优化梯度下降等。这些都需要基于数据集或者数据集的衍生数据反复查询反复操作。MR 这种模式不太合适，即使多 MR 串行处理，性能和时间也是一个问题。数据的共享依赖于磁盘。另外一种是交互式 数据挖掘，MR 显然不擅长。而Spark 所基于的 scala 语言恰恰擅长函数的处理。</strong></p>\n</li>\n<li><p>Spark 是一个分布式数据快速分析项目。<strong>它的核心技术是弹性分布式数据集</strong>（Resilient Distributed Datasets），提供了比 MapReduce 丰富的模型，可以快速在内存中对数据集进行多次迭代，来支持复杂的数据挖 掘算法和图形计算算法。</p>\n</li>\n<li><p><strong>Spark 和Hadoop 的根本差异是多个作业之间的数据通信问题</strong> <strong>:</strong> <strong><font color=\"red\">Spark 多个作业之间数据通信是基于内存</font>， <font color=\"red\">而 Hadoop 是基于磁盘。</font></strong></p>\n</li>\n<li><p><strong><font color=\"red\">Spark Task 的启动时间快。Spark 采用 fork 线程的方式，而 Hadoop 采用创建新的进程的方式。</font></strong></p>\n</li>\n<li><p><strong><font color=\"red\">Spark 只有在 shuffle 的时候将数据写入磁盘，而 Hadoop 中多个 MR 作业之间的数据交互都要依赖于磁盘交互</font></strong></p>\n</li>\n<li><p><strong><font color=\"red\">Spark 的缓存机制比 HDFS 的缓存机制高效。</font></strong></p>\n</li>\n</ul>\n<h3 id=\"hadoop的一次性计算\"><a href=\"#hadoop的一次性计算\" class=\"headerlink\" title=\"hadoop的一次性计算\"></a>hadoop的一次性计算</h3><p>框架在处理数据的时候，会从存储设备中读取数据，进行逻辑操作，然后将处理的结果重新存储到介质中。</p>\n<p><img src=\"/2022/06/29/sparkcore/1.png\"></p>\n<p><code>上一次的计算结果给下一次使用，他们作业之间的关联靠的是磁盘交互，所以磁盘io,会非常影响性能</code></p>\n<p>经过上面的比较，我们可以看出在绝大多数的数据计算场景中，Spark 确实会比 MapReduce更有优势。<strong>但是 Spark 是基于内存的，所以在实际的生产环境中，由于内存的限制，可能会由于内存资源不够导致 Job 执行失败， 此时，MapReduce 其实是一个更好的选择，所以 Spark并不能完全替代 MR。</strong></p>\n<h1 id=\"第二章-Spark-快速上手\"><a href=\"#第二章-Spark-快速上手\" class=\"headerlink\" title=\"第二章 Spark 快速上手\"></a>第二章 Spark 快速上手</h1><p>在大数据早期的课程中我们已经学习了 MapReduce 框架的原理及基本使用，并了解了其底层数据处理的实现方式。接下来，就让咱们走进 Spark 的世界，了解一下它是如何带领我们完成数据处理的。</p>\n<h3 id=\"创建-Maven-项目\"><a href=\"#创建-Maven-项目\" class=\"headerlink\" title=\"创建 Maven 项目\"></a>创建 Maven 项目</h3><p><strong>创建Project</strong></p>\n<ul>\n<li>File-&gt;new-&gt;Project-&gt;Maven-&gt;名字如：<strong>Bigdata.zw</strong></li>\n<li>项目右键new-&gt;Module-&gt;Maven-&gt;名字如：<strong>spark-core</strong></li>\n</ul>\n<p><strong>安装Scala</strong></p>\n<p>如果电脑未安装scala就点击，<strong>File</strong>下的<strong>Project Setting</strong>s，选择<strong>Global Libraries</strong>，点击左上角的+号，选择<strong>Scala SDK</strong>，点击最左边按钮，<strong>Download</strong>进行选择版本下载，选择版本 <strong>2.12.11</strong></p>\n<p><strong>安装scala插件</strong></p>\n<p>IDEA里选择File下的setting，点击Plugin，在插件里面搜索Scala，可以下载Scala插件，然后按老师选择Scala的SDK，可以用插件直接选择Scala版本下载</p>\n<p><strong>添加框架支持</strong></p>\n<ul>\n<li>在创建的spark-core右键add frameworks support（添加框架支持）-&gt;选择scala</li>\n<li>在新建的sprak-core-&gt;src-&gt;main-&gt;java-&gt;右键-Package-&gt;名字如：<strong>com.zw.bigdata.spark.core</strong></li>\n<li>最后检测环境是否可以使用 右键package-&gt;new-&gt; scalaClass-&gt;Object <strong>创建scala程序运行hello</strong></li>\n</ul>\n<h3 id=\"增加依赖关系\"><a href=\"#增加依赖关系\" class=\"headerlink\" title=\"增加依赖关系\"></a>增加依赖关系</h3><p><strong>修改 Maven 项目中的 POM 文件，增加 Spark 框架的依赖关系。本课件基于 Spark3.0 版本，使用时请注意对应版本。</strong><font color=\"red\">要求hadoop版本也是3.0.0</font></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.spark<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spark-core_2.12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>复制代码到创建的<strong>spark-core</strong>(添加了scala框架支持的文件夹)的<strong>pom.xml</strong>  <font color=\"red\">project标签里</font>进行下载依赖</p>\n<p>添加依赖后，如果下载速度缓慢可使用教程对应的阿里云镜像进行下载：<a href=\"https://blog.csdn.net/qq_37887131/article/details/89383051\">https://blog.csdn.net/qq_37887131/article/details/89383051</a></p>\n<h3 id=\"WordCount案例\"><a href=\"#WordCount案例\" class=\"headerlink\" title=\"WordCount案例\"></a>WordCount案例</h3><h4 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a><center><font color=\"red\">具体流程</font></center></h4><p><img src=\"/2022/06/29/sparkcore/3.png\"></p>\n<h4 id=\"WordCount不同方法实现1\"><a href=\"#WordCount不同方法实现1\" class=\"headerlink\" title=\"WordCount不同方法实现1\"></a>WordCount不同方法实现1</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.rdd.<span class=\"type\">RDD</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;   <span class=\"comment\">//环境</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Auther:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * @Date: 2022/7/2</span></span><br><span class=\"line\"><span class=\"comment\"> * @Description: test</span></span><br><span class=\"line\"><span class=\"comment\"> * @Version:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Spark01_WorldCount</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Application</span></span><br><span class=\"line\">    <span class=\"comment\">//Spark框架</span></span><br><span class=\"line\">    <span class=\"comment\">// TODO 建立和Spark框架的连接</span></span><br><span class=\"line\">    <span class=\"comment\">//JDBC:Connection</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local&quot;</span>).setAppName(<span class=\"string\">&quot;WordCount&quot;</span>)  <span class=\"comment\">//Spark基础配置对象</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)   <span class=\"comment\">//环境对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//TODO 执行业务操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1.读取文件，获取一行一行的数据</span></span><br><span class=\"line\">    <span class=\"comment\">// hello world</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> lines: <span class=\"type\">RDD</span>[<span class=\"type\">String</span>] = sc.textFile(<span class=\"string\">&quot;datas&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.将一行数据进行拆分，形成一个一个的单词（分词）</span></span><br><span class=\"line\">    <span class=\"comment\">// 扁平化</span></span><br><span class=\"line\">    <span class=\"comment\">// “hello world”=&gt; hello,world,hello,world</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> words: <span class=\"type\">RDD</span>[<span class=\"type\">String</span>] = lines.flatMap(_.split(<span class=\"string\">&quot; &quot;</span>)) <span class=\"comment\">// 等价于 s=&gt;s.split(&quot; &quot;)</span></span><br><span class=\"line\">    <span class=\"comment\">//3.将数据根据单词进行分组，便于统计</span></span><br><span class=\"line\">    <span class=\"comment\">//  (hello,hello,hello)，(world,world)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> wordGroup: <span class=\"type\">RDD</span>[(<span class=\"type\">String</span>, <span class=\"type\">Iterable</span>[<span class=\"type\">String</span>])] = words.groupBy(word =&gt;word)</span><br><span class=\"line\">    <span class=\"comment\">//4.对分组后的数据进行转换</span></span><br><span class=\"line\">    <span class=\"comment\">//  (hello,hello,hello)，(world,world)</span></span><br><span class=\"line\">    <span class=\"comment\">//  (hello,3) ，(world,2)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> wordToCount: <span class=\"type\">RDD</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = wordGroup.map&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> (word,list)=&gt;&#123;</span><br><span class=\"line\">        (word,list.size)  <span class=\"comment\">//单词 数组的长度</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//5.将转换结果采集到控制台打印出来</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> array: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = wordToCount.collect()</span><br><span class=\"line\">    array.foreach(println)</span><br><span class=\"line\">    <span class=\"comment\">//TODO 关闭连接</span></span><br><span class=\"line\">    sc.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WorldCount不同方法实现2\"><a href=\"#WorldCount不同方法实现2\" class=\"headerlink\" title=\"WorldCount不同方法实现2\"></a>WorldCount不同方法实现2</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local&quot;</span>).setAppName(<span class=\"string\">&quot;WordCount&quot;</span>)  <span class=\"comment\">//Spark基础配置对象</span></span><br><span class=\"line\">      <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)   <span class=\"comment\">//环境对象</span></span><br><span class=\"line\">      <span class=\"keyword\">val</span> lines: <span class=\"type\">RDD</span>[<span class=\"type\">String</span>] = sc.textFile(<span class=\"string\">&quot;datas&quot;</span>)  <span class=\"comment\">//文件</span></span><br><span class=\"line\">      <span class=\"keyword\">val</span> words: <span class=\"type\">RDD</span>[<span class=\"type\">String</span>] = lines.flatMap(_.split(<span class=\"string\">&quot; &quot;</span>)) <span class=\"comment\">// 等价于 s=&gt;s.split(&quot; &quot;) 切分</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">val</span> wordToOne: <span class=\"type\">RDD</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] =words.map(</span><br><span class=\"line\">        word=&gt;(word,<span class=\"number\">1</span>)   <span class=\"comment\">//表示单词出现了一次 单词对应1</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">      <span class=\"keyword\">val</span> wordGroup: <span class=\"type\">RDD</span>[(<span class=\"type\">String</span>, <span class=\"type\">Iterable</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)])] = wordToOne.groupBy(</span><br><span class=\"line\">        t =&gt; t._1 <span class=\"comment\">//对 word 进行分组</span></span><br><span class=\"line\">     )</span><br><span class=\"line\">      <span class=\"keyword\">val</span> wordToCount=wordGroup.map&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> (word,list)=&gt;&#123;</span><br><span class=\"line\">            list.reduce(  <span class=\"comment\">//聚合计算</span></span><br><span class=\"line\">            (t1,t2)=&gt;&#123;</span><br><span class=\"line\">              (t1._1,t1._2+t2._2)  <span class=\"comment\">//hello 1+1   </span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> array=wordToCount.collect()</span><br><span class=\"line\">      array.foreach(println)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WorldCount不同方法实现3\"><a href=\"#WorldCount不同方法实现3\" class=\"headerlink\" title=\"WorldCount不同方法实现3\"></a>WorldCount不同方法实现3</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local&quot;</span>).setAppName(<span class=\"string\">&quot;WordCount&quot;</span>)  <span class=\"comment\">//Spark基础配置对象</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)   <span class=\"comment\">//环境对象</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> lines: <span class=\"type\">RDD</span>[<span class=\"type\">String</span>] = sc.textFile(<span class=\"string\">&quot;datas&quot;</span>)  <span class=\"comment\">//文件</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> words: <span class=\"type\">RDD</span>[<span class=\"type\">String</span>] = lines.flatMap(_.split(<span class=\"string\">&quot; &quot;</span>)) <span class=\"comment\">// 等价于 s=&gt;s.split(&quot; &quot;) 切分</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> wordToOne: <span class=\"type\">RDD</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] =words.map(</span><br><span class=\"line\">          word=&gt;(word,<span class=\"number\">1</span>)   <span class=\"comment\">//表示单词出现了一次 单词对应1</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">       <span class=\"comment\">//Spark框架提供了更多的功能，可以将分组和聚合使用一个方法实现</span></span><br><span class=\"line\">       <span class=\"comment\">//reduceByKey:相同的key的数据，可以对value进行reduce聚合</span></span><br><span class=\"line\">       <span class=\"comment\">//wordToOne.reduceByKey((x,y)=&gt;&#123;x+y&#125;)</span></span><br><span class=\"line\">       <span class=\"comment\">//wordToOne.reduceByKey((x,y)=&gt;x+y)</span></span><br><span class=\"line\">      <span class=\"comment\">//// 将转换结构后的数据按照相同的单词进行分组聚合</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> wordToCount=wordToOne.reduceByKey(_+_)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> array=wordToCount.collect()</span><br><span class=\"line\">        array.foreach(println)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://blog.csdn.net/qq_26442553/article/details/108362390\">具体方法</a></p>\n<h4 id=\"方便查看输出结果设置\"><a href=\"#方便查看输出结果设置\" class=\"headerlink\" title=\"方便查看输出结果设置\"></a>方便查看输出结果设置</h4><p>执行过程中，会产生大量的执行日志，如果为了能够更好的查看程序的执行结果，可以在项目的 resources 目录 中创建 log4j.properties 文件，并添加日志配置信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootCategory=ERROR, console</span><br><span class=\"line\">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.console.target=System.err</span><br><span class=\"line\">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.console.layout.ConversionPattern=%d&#123;yy/MM/dd HH:mm:ss&#125; %p %c&#123;1&#125;: %m%n</span><br><span class=\"line\">log4j.logger.org.apache.spark.repl.Main=ERROR</span><br><span class=\"line\"># Settings to quiet third party logs that are too verbose</span><br><span class=\"line\">log4j.logger.org.spark_project.jetty=ERROR</span><br><span class=\"line\">log4j.logger.org.spark_project.jetty.util.component.AbstractLifeCycle=ERROR</span><br><span class=\"line\">log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper=ERROR</span><br><span class=\"line\">log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter=ERROR</span><br><span class=\"line\">log4j.logger.org.apache.parquet=ERROR</span><br><span class=\"line\">log4j.logger.parquet=ERROR</span><br><span class=\"line\"># SPARK-9183: Settings to avoid annoying messages when looking up nonexistent UDFs in</span><br><span class=\"line\">SparkSQL with Hive support</span><br><span class=\"line\">log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler=FATAL</span><br><span class=\"line\">log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry=ERROR</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h4><p><strong>1.  <font color=\"red\">Failed to locate the winutils binary in the hadoop binary path</font></strong>     </p>\n<p> <strong><font color=\"red\">java.io.IOException:Could not locate executable null\\bin\\winutils.exe in the Hadoop binaries.</font></strong></p>\n<p><strong>解决：安装hadoop-3.0.0配置环境变量</strong>(zip)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">PATH:%HADOOP_HOME%\\bin</span><br><span class=\"line\">HADOOP_HOME: E:\\BigData\\hadoop-3.0.0</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.</strong>  <strong><font color=\"red\">Exception in thread “main” java.lang.ExceptionInInitializerError异常</font></strong></p>\n<p><strong>解决：SDK版本过高，进入项目，降低java版本，降为15即可</strong></p>\n<p><code>设置完重启IDEA</code></p>\n<h1 id=\"第三章-Spark运行环境\"><a href=\"#第三章-Spark运行环境\" class=\"headerlink\" title=\"第三章 Spark运行环境\"></a>第三章 Spark运行环境</h1><h4 id=\"Local\"><a href=\"#Local\" class=\"headerlink\" title=\"Local\"></a>Local</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sc.textFile(<span class=\"string\">&quot;../data/word.txt&quot;</span>).flatMap(_.split(<span class=\"string\">&quot; &quot;</span>)).map((_,<span class=\"number\">1</span>)).reduceByKey(_+_).collect</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>提交应用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bin/spark-submit \\</span><br><span class=\"line\">--class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">--master local[2] \\</span><br><span class=\"line\">./examples/jars/spark-examples_2.12-3.0.0.jar \\</span><br><span class=\"line\">10</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bin/spark-submit \\</span><br><span class=\"line\">--class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">--master spark://node01:7077 \\</span><br><span class=\"line\">./examples/jars/spark-examples_2.12-3.0.0.jar \\</span><br><span class=\"line\">10</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bin/spark-submit \\</span><br><span class=\"line\">--class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">--master yarn \\</span><br><span class=\"line\">--deploy-mode cluster \\</span><br><span class=\"line\">./examples/jars/spark-examples_2.12-3.0.0.jar \\</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第五章-Spark核心编程\"><a href=\"#第五章-Spark核心编程\" class=\"headerlink\" title=\"第五章 Spark核心编程\"></a>第五章 Spark核心编程</h1><h2 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h2><p><img src=\"/2022/06/29/sparkcore/5.png\"></p>\n<h2 id=\"RDD\"><a href=\"#RDD\" class=\"headerlink\" title=\"RDD\"></a>RDD</h2><h3 id=\"什么是RDD\"><a href=\"#什么是RDD\" class=\"headerlink\" title=\"什么是RDD\"></a>什么是RDD</h3><p>RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是 Spark 中最基本的<font color=\"red\">数据处理模型</font>。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合</p>\n<p><img src=\"/2022/06/29/sparkcore/4.png\"></p>\n<p><strong>RDD的数据处理方式类似于IO流，也有装饰者设计模式</strong></p>\n<p><strong>RDD的数据只有在调用collect方法时，才会真正执行业务逻辑操作。之前的封装全部都是功能的扩展</strong></p>\n<p><strong>RDD是不保存数据。但是IO可以临时保存一部分数据</strong></p>\n<p><img src=\"/2022/06/29/sparkcore/6.png\"></p>\n<ul>\n<li><p>弹性</p>\n<ul>\n<li>存储的弹性：内存与磁盘的自动切换；</li>\n</ul>\n</li>\n<li><p>容错的弹性：数据丢失可以自动恢复；</p>\n</li>\n<li><p>计算的弹性：计算出错重试机制；</p>\n</li>\n<li><p>分片的弹性：可根据需要重新分片</p>\n</li>\n<li><p>分布式：数据存储在大数据集群不同节点上。</p>\n</li>\n<li><p>数据集：RDD 封装了计算逻辑，并不保存数据</p>\n</li>\n<li><p>数据抽象：RDD 是一个抽象类，需要子类具体实现</p>\n</li>\n<li><p>不可变：RDD 封装了计算逻辑，是不可以改变的，想要改变，只能产生新的RDD，在新的RDD 里面封装计算逻辑</p>\n</li>\n<li><p>可分区、并行计算</p>\n</li>\n</ul>\n<h3 id=\"核心属性\"><a href=\"#核心属性\" class=\"headerlink\" title=\"核心属性\"></a>核心属性</h3><p>IDEA中查看RDD.scala源码方法：</p>\n<p><a href=\"https://blog.csdn.net/m0_56602092/article/details/119217924\">https://blog.csdn.net/m0_56602092/article/details/119217924</a></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Internally, each RDD is characterized by five main properties:</span></span><br><span class=\"line\"><span class=\"comment\">A list of partitions</span></span><br><span class=\"line\"><span class=\"comment\">A function for computing each split</span></span><br><span class=\"line\"><span class=\"comment\">A list of dependencies on other RDDs</span></span><br><span class=\"line\"><span class=\"comment\">Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)</span></span><br><span class=\"line\"><span class=\"comment\">Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分区列表\"><a href=\"#分区列表\" class=\"headerlink\" title=\"分区列表\"></a>分区列表</h4><p>RDD 数据结构中存在分区列表，用于<strong>执行任务时并行计算</strong>，是实现分布式计算的重要属性。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implemented by subclasses to return the set of partitions in this RDD. This method will only</span></span><br><span class=\"line\"><span class=\"comment\"> * be called once, so it is safe to implement a time-consuming computation in it.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The partitions in this array must satisfy the following property:</span></span><br><span class=\"line\"><span class=\"comment\"> *   `rdd.partitions.zipWithIndex.forall &#123; case (partition, index) =&gt; partition.index == index &#125;`</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPartitions</span></span>: <span class=\"type\">Array</span>[<span class=\"type\">Partition</span>]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分区计算函数\"><a href=\"#分区计算函数\" class=\"headerlink\" title=\"分区计算函数\"></a>分区计算函数</h4><p>Spark 在计算时，是<strong>使用分区函数对每一个分区进行计算</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * :: DeveloperApi ::</span></span><br><span class=\"line\"><span class=\"comment\"> * Implemented by subclasses to compute a given partition.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@DeveloperApi</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compute</span></span>(split: <span class=\"type\">Partition</span>, context: <span class=\"type\">TaskContext</span>): <span class=\"type\">Iterator</span>[<span class=\"type\">T</span>]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RDD-之间的依赖关系\"><a href=\"#RDD-之间的依赖关系\" class=\"headerlink\" title=\"RDD 之间的依赖关系\"></a>RDD 之间的依赖关系</h4><p>RDD 是计算模型的封装，当<strong>需求中需要将多个计算模型进行组合时，就需要将多个 RDD 建立依赖关系</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implemented by subclasses to return how this RDD depends on parent RDDs. This method will only</span></span><br><span class=\"line\"><span class=\"comment\"> * be called once, so it is safe to implement a time-consuming computation in it.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getDependencies</span></span>: <span class=\"type\">Seq</span>[<span class=\"type\">Dependency</span>[_]] = deps</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分区器（可选）\"><a href=\"#分区器（可选）\" class=\"headerlink\" title=\"分区器（可选）\"></a>分区器（可选）</h4><p>当数据为 KV 类型数据时，可以<strong>通过设定分区器自定义数据的分区</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Optionally overridden by subclasses to specify how they are partitioned. */</span></span><br><span class=\"line\"><span class=\"meta\">@transient</span> <span class=\"keyword\">val</span> partitioner: <span class=\"type\">Option</span>[<span class=\"type\">Partitioner</span>] = <span class=\"type\">None</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"首选位置（可选）\"><a href=\"#首选位置（可选）\" class=\"headerlink\" title=\"首选位置（可选）\"></a>首选位置（可选）</h4><p>计算数据时，<strong>可以根据计算节点的状态选择不同的节点位置进行计算</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Optionally overridden by subclasses to specify placement preferences.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPreferredLocations</span></span>(split: <span class=\"type\">Partition</span>): <span class=\"type\">Seq</span>[<span class=\"type\">String</span>] = <span class=\"type\">Nil</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/06/29/sparkcore/7.png\"></p>\n<h3 id=\"执行原理\"><a href=\"#执行原理\" class=\"headerlink\" title=\"执行原理\"></a>执行原理</h3><h3 id=\"基础编程\"><a href=\"#基础编程\" class=\"headerlink\" title=\"基础编程\"></a>基础编程</h3><p>RDD创建</p>\n<p>在 Spark 中创建RDD 的创建方式可以分为四种：</p>\n<h4 id=\"从集合（内存）中创建-RDD\"><a href=\"#从集合（内存）中创建-RDD\" class=\"headerlink\" title=\"从集合（内存）中创建 RDD\"></a>从集合（内存）中创建 RDD</h4><p>从集合中创建RDD，Spark主要提供了两个方法：parallelize 和 makeRDD</p>\n<p>从底层代码实现来讲，makeRDD 方法其实就是parallelize 方法</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//TODO 创建RDD</span></span><br><span class=\"line\">   <span class=\"comment\">//从内存中创建RDD,将内存中集合的数据作为处理的数据源</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> seq = <span class=\"type\">Seq</span>[<span class=\"type\">Int</span>](<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//parallelize:并行</span></span><br><span class=\"line\">   <span class=\"comment\">//val rdd=sc.parallelize(seq)</span></span><br><span class=\"line\">   <span class=\"comment\">//makeRDD方法在底层实现时就是调用了rdd对下的parallelize方法</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> rdd: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] =sc.makeRDD(seq)</span><br><span class=\"line\">   rdd.collect().foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//TODO 关闭环境</span></span><br><span class=\"line\">   sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><code>ctrl+P 提示函数所要用的参数</code></p>\n<h4 id=\"从外部存储（文件）创建RDD\"><a href=\"#从外部存储（文件）创建RDD\" class=\"headerlink\" title=\"从外部存储（文件）创建RDD\"></a>从外部存储（文件）创建RDD</h4><p>由外部存储系统的数据集创建RDD 包括：本地的文件系统，所有Hadoop 支持的数据集， 比如HDFS、HBase 等</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//TODO 创建RDD</span></span><br><span class=\"line\">   <span class=\"comment\">//从文件中创建RDD,将文件中的数据作为处理的数据源</span></span><br><span class=\"line\">   <span class=\"comment\">//path路径默认以当前环境的根路径作为基准。可以写绝对路径，或相对路径</span></span><br><span class=\"line\">   <span class=\"comment\">//path路径可以是文件的具体路径,也可以是目录名称</span></span><br><span class=\"line\">   <span class=\"comment\">// *是通配符 datas/1*.txt 可以匹配1开头的txt文件</span></span><br><span class=\"line\">   <span class=\"comment\">//path还可以是分布式存储系统路径:HDFS 如 hdfs://linux1:8020/test.txt</span></span><br><span class=\"line\">   <span class=\"comment\">//val rdd: RDD[String] = sc.textFile(&quot;datas/*&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//两种：</span></span><br><span class=\"line\">   <span class=\"comment\">//1.textFile: 以行为单位来读取数据，读取的数据都是字符串</span></span><br><span class=\"line\">   <span class=\"comment\">//2.wholeTextFiles: 以文件为单位读取数据</span></span><br><span class=\"line\">   <span class=\"comment\">// 读取的结果为元组，第一个元素表示路径，第二个元素表示文件内容</span></span><br><span class=\"line\"><span class=\"comment\">//val rdd = sc.textFile(&quot;datas//1.txt&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> rdd: <span class=\"type\">RDD</span>[(<span class=\"type\">String</span>, <span class=\"type\">String</span>)] = sc.wholeTextFiles(<span class=\"string\">&quot;datas&quot;</span>)</span><br><span class=\"line\">   rdd.collect().foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//TODO 关闭环境</span></span><br><span class=\"line\">   sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RDD-并行度与分区\"><a href=\"#RDD-并行度与分区\" class=\"headerlink\" title=\"RDD 并行度与分区\"></a>RDD 并行度与分区</h3><p>默认情况下，Spark 可以将一个作业切分多个任务后，发送给 Executor 节点并行计算，而能够并行计算的任务数量我们称之为并行度。这个数量可以在构建RDD 时指定。记住，这里的并行执行的任务数量，并不是指的切分任务的数量，不要混淆了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">sparkConf.set(<span class=\"string\">&quot;spark.default.parallelism&quot;</span>,<span class=\"string\">&quot;5&quot;</span>)  <span class=\"comment\">//设置 5个分区</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TODO 创建RDD</span></span><br><span class=\"line\"><span class=\"comment\">//RDD的并行度 &amp; 分区</span></span><br><span class=\"line\"><span class=\"comment\">//def makeRDD[T : ClassTag](seq: Seq[T], numSlices: Int = defaultParallelism): RDD[T]</span></span><br><span class=\"line\"><span class=\"comment\">// makeRDD方法可以传递第二个参数，这个参数表示分区的数量</span></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数是可以不传递的，那么makeRDD方法会使用默认值：defaultParallelism(默认并行度)</span></span><br><span class=\"line\"><span class=\"comment\">// scheduler.conf.getInt(&quot;spark.default.parallelism&quot;, totalCores)</span></span><br><span class=\"line\"><span class=\"comment\">// 会从配置的对象当中取配置的参数</span></span><br><span class=\"line\"><span class=\"comment\">// 如果没有配会取默认值 totalCores属性取值为当前环境最大可用核数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"comment\">// val rdd = sc.makeRDD(List(1,2,3,4),2) //设置为两个分区 </span></span><br><span class=\"line\"><span class=\"comment\">// 将处理的数据保存成分区文件  </span></span><br><span class=\"line\">rdd.saveAsTextFile(<span class=\"string\">&quot;output&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TODO 关闭环境</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><strong>分区数据分配-案例分析</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TODO 创建RDD</span></span><br><span class=\"line\"><span class=\"comment\">//1.数据以行为单位进行读取</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    分区大小=总字节/minPartitions；如果剩余大小&gt;分区大小10%,则新增一个分区  7/2=3...1</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">单个文件：1.txt</span></span><br><span class=\"line\"><span class=\"comment\">1234567@@  =》 012345678   @为回车和换行</span></span><br><span class=\"line\"><span class=\"comment\">89@@       =》 9101112</span></span><br><span class=\"line\"><span class=\"comment\">0          =》 13</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">[0,7]   =&gt; 1234567     对应偏移量这里其实8也被读到了(对应第一行数据012345678字符总数)，读取后不会重复读取一行</span></span><br><span class=\"line\"><span class=\"comment\">[7,14]  =&gt; 890</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">每个分区大小= 文件字节总/分区数量            如文件大小为 15  (1) [0-7]  (2)[7-14]    如果有余数就到最后 [15]</span></span><br><span class=\"line\"><span class=\"comment\">每行字符总数= 每行数据大小+回车换行两个偏移量   满足每个分区的大小就会被读取,没有就读下一行  一行数据读取后，不会重复读区一行</span></span><br><span class=\"line\"><span class=\"comment\">如果数据源为多个文件，那么计算分区时以文件为单位进行分区</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd=sc.textFile(<span class=\"string\">&quot;datas&quot;</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">rdd.saveAsTextFile(<span class=\"string\">&quot;output&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//TODO 关闭环境</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><strong>RDD方法&#x3D;&gt;RDD算子</strong></p>\n<p><strong>转换：</strong>功能的补充和封装，将旧的RDD包装成新的RDD  flatMap,map</p>\n<p><strong>行动：</strong>触发任务的调度和作业的执行 collect</p>\n<h2 id=\"RDD转化算子\"><a href=\"#RDD转化算子\" class=\"headerlink\" title=\"RDD转化算子\"></a>RDD转化算子</h2><h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><strong>函数签名：</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">map</span></span>[<span class=\"type\">U</span>: <span class=\"type\">ClassTag</span>](f: <span class=\"type\">T</span> =&gt; <span class=\"type\">U</span>): <span class=\"type\">RDD</span>[<span class=\"type\">U</span>]</span><br></pre></td></tr></table></figure>\n<p><strong>函数说明：</strong></p>\n<p>将处理的数据<font color=\"red\">逐条</font>进行映射转换，这里的转换可以是类型的转换，也可以是值的转换。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TODO 算子 -map</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"comment\">//1,2,3,4</span></span><br><span class=\"line\">    <span class=\"comment\">//2,4,6,8</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//转换函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mapFunction</span></span>(num:<span class=\"type\">Int</span>)=&#123;</span><br><span class=\"line\">         num*<span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//    val mapRDD: RDD[Int] =rdd.map(mapFunction)</span></span><br><span class=\"line\"><span class=\"comment\">//    val mapRDD: RDD[Int] =rdd.map((num:Int)=&gt;&#123;num*2&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">//    val mapRDD: RDD[Int] =rdd.map((num:Int)=&gt;num*2)</span></span><br><span class=\"line\"><span class=\"comment\">//    val mapRDD: RDD[Int] =rdd.map((num)=&gt;num*2)</span></span><br><span class=\"line\"><span class=\"comment\">//    val mapRDD: RDD[Int] =rdd.map(num=&gt;num*2)</span></span><br><span class=\"line\">      <span class=\"keyword\">val</span> mapRDD = rdd.map(_*<span class=\"number\">2</span>)</span><br><span class=\"line\">      mapRDD.collect().foreach(println)</span><br><span class=\"line\">\t  <span class=\"comment\">//结果：2，4，6，8</span></span><br><span class=\"line\">\t  sc.stop()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// TODO 算子 -map</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">&quot;datas/apache.log&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">val</span> makDRR = rdd.map &#123;</span><br><span class=\"line\">     line =&gt; &#123;</span><br><span class=\"line\">       <span class=\"keyword\">val</span> data = line.split(<span class=\"string\">&quot; &quot;</span>)   <span class=\"comment\">//利用空格拆分</span></span><br><span class=\"line\">       data(<span class=\"number\">6</span>)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   makDRR.collect().foreach(println)</span><br><span class=\"line\">   <span class=\"comment\">//结果：把.log 数据按空格拆分，取下标为六的数据</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><strong>map并行</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// TODO 算子 -map</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 1. rdd的计算一个分区内的数据是一个执行逻辑</span></span><br><span class=\"line\">   <span class=\"comment\">// 只有前面一个数据全部的逻辑执行完毕后，才会执行下一个数据</span></span><br><span class=\"line\">   <span class=\"comment\">// 分区内数据的执行是有序的</span></span><br><span class=\"line\">   <span class=\"comment\">// 2. 不同分区数据计算是无序的</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">var</span> mapRDD=rdd.map&#123;</span><br><span class=\"line\">     num=&gt;&#123;</span><br><span class=\"line\">       println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>+num)</span><br><span class=\"line\">       num</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> mapRDD1=mapRDD.map&#123;</span><br><span class=\"line\">     num=&gt;&#123;</span><br><span class=\"line\">       println(<span class=\"string\">&quot;#########&quot;</span>+num)</span><br><span class=\"line\">       num</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   mapRDD1.collect()</span><br><span class=\"line\"><span class=\"comment\">//结果：无规律的因为是并行</span></span><br><span class=\"line\">   sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mapPartitions\"><a href=\"#mapPartitions\" class=\"headerlink\" title=\"mapPartitions\"></a>mapPartitions</h3><p><strong>函数签名：</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mapPartitions</span></span>[<span class=\"type\">U</span>: </span><br><span class=\"line\">       <span class=\"type\">ClassTag</span>]( f: <span class=\"type\">Iterator</span>[<span class=\"type\">T</span>] =&gt;</span><br><span class=\"line\">       <span class=\"type\">Iterator</span>[<span class=\"type\">U</span>],</span><br><span class=\"line\">\t   preservesPartitioning: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>): <span class=\"type\">RDD</span>[<span class=\"type\">U</span>]</span><br></pre></td></tr></table></figure>\n<p><strong>函数说明：</strong></p>\n<p>将待处理的数据<font color=\"red\">以分区为单位</font>发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子 -mapPartitions</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//   迭代器</span></span><br><span class=\"line\"><span class=\"comment\">//mapPartitions : 可以以分区为单位进行数据转换操作</span></span><br><span class=\"line\"><span class=\"comment\">//                但是会将整个分区的数据加载到内存进行引用</span></span><br><span class=\"line\"><span class=\"comment\">//                如果处理完的数据是不会释放掉，存在对象的引用</span></span><br><span class=\"line\"><span class=\"comment\">//                在内存较小，数据量较大的场合下，容易出现内存溢出</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">//  【1，2】，【3，4】</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> mpRDD: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] = rdd.mapPartitions(</span><br><span class=\"line\">  iter =&gt; &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&quot;</span>)  <span class=\"comment\">//出现几次就代表用了几个分区</span></span><br><span class=\"line\">    iter.map(_ * <span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">mpRDD.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果 2 4 6 8</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><code>小功能：获取每个数据分区的最大值</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TODO 算子 -mapPartitions</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// iter为迭代器</span></span><br><span class=\"line\">   <span class=\"comment\">// mapPartitions方法 def mapPartitions[U : ClassTag](f: Iterator[T] =&gt; Iterator[U], preservesPartitioning: Boolean = false): RDD[U]</span></span><br><span class=\"line\">   <span class=\"comment\">// 返回类型为：迭代器，max返回类型不是迭代器 就用List包装一下返回迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\">   <span class=\"comment\">//  【1，2】，【3，4】</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> mpRDD: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] = rdd.mapPartitions(</span><br><span class=\"line\">      iter =&gt; &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class=\"line\">        <span class=\"type\">List</span>(iter.max).iterator</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    mpRDD.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果：2 4</span></span><br><span class=\"line\">    sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><strong>思考一个问题：map 和 mapPartitions 的区别？</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t数据处理角度:</span><br><span class=\"line\"><span class=\"type\">Map</span> 算子是分区内一个数据一个数据的执行，类似于串行操作。而 mapPartitions 算子是以分区为单位进行批处理操作。</span><br><span class=\"line\"></span><br><span class=\"line\">\t功能的角度:</span><br><span class=\"line\"><span class=\"type\">Map</span> 算子主要目的将数据源中的数据进行转换和改变。但是不会减少或增多数据。<span class=\"type\">MapPartitions</span> 算子需要传递一个迭代器，返回一个迭代器，没有要求的元素的个数保持不变， 所以可以增加或减少数据</span><br><span class=\"line\"></span><br><span class=\"line\">\t性能的角度:</span><br><span class=\"line\"><span class=\"type\">Map</span> 算子因为类似于串行操作，所以性能比较低，而是 mapPartitions 算子类似于批处理，所以性能较高。但是mapPartitions 算子会长时间占用内存，那么这样会导致内存可能不够用，出现内存溢出的错误。所以在内存有限的情况下，不推荐使用。使用 map 操作。</span><br><span class=\"line\"></span><br><span class=\"line\">不用考虑太多 完成比完美更重要！！！</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mapPartitionsWithIndex\"><a href=\"#mapPartitionsWithIndex\" class=\"headerlink\" title=\"mapPartitionsWithIndex\"></a>mapPartitionsWithIndex</h3><p><strong>函数签名：</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mapPartitionsWithIndex</span></span>[<span class=\"type\">U</span>:</span><br><span class=\"line\">       <span class=\"type\">ClassTag</span>]( f: (<span class=\"type\">Int</span>, <span class=\"type\">Iterator</span>[<span class=\"type\">T</span>]) =&gt; </span><br><span class=\"line\">       <span class=\"type\">Iterator</span>[<span class=\"type\">U</span>],</span><br><span class=\"line\">\t   preservesPartitioning: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>): <span class=\"type\">RDD</span>[<span class=\"type\">U</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明：</strong></p>\n<p>将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，在处理时同时可以获取当前分区索引。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"> <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// TODO 算子 -mapPartitionsWithIndex  显示 分区和数据</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">val</span> mpRDD = rdd.mapPartitionsWithIndex(</span><br><span class=\"line\">   (index,inter) =&gt; &#123;</span><br><span class=\"line\">   inter.map(num=&gt;&#123;</span><br><span class=\"line\">     (index,num)   <span class=\"comment\">//参数1：输出 index 为分区   参数2：num 为分区的所有数据,进行迭代</span></span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> )</span><br><span class=\"line\">   mpRDD.collect().foreach(println)</span><br><span class=\"line\"> <span class=\"comment\">/*结果：</span></span><br><span class=\"line\"><span class=\"comment\"> (0,1)  1在0号分区</span></span><br><span class=\"line\"><span class=\"comment\"> (0,2)</span></span><br><span class=\"line\"><span class=\"comment\"> (1,3)  3在1号分区</span></span><br><span class=\"line\"><span class=\"comment\"> (1,4)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><code>小功能：获取第二个数据分区的数据</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子 -mapPartitionsWithIndex 获取第二个数据分区的数据`</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">//总共就分两个区 【1，2】 【3，4】 为分区 0、1</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> mpRDD: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] = rdd.mapPartitionsWithIndex(</span><br><span class=\"line\">  (index,iter)=&gt;&#123;  </span><br><span class=\"line\"><span class=\"comment\">// index为分区编号 iter为迭代器所有数据  </span></span><br><span class=\"line\"><span class=\"comment\">// 返回类型为：迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(index==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">      iter</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"type\">Nil</span>.iterator</span><br><span class=\"line\">      <span class=\"comment\">//Nil叫空集合 它的迭代器就叫空迭代器，把迭代器所有数据清空</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">mpRDD.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果： 3 4 把分区0的数据清空了</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h3><p><strong>函数签名：</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flatMap</span></span>[<span class=\"type\">U</span>: <span class=\"type\">ClassTag</span>](f: <span class=\"type\">T</span> =&gt; <span class=\"type\">TraversableOnce</span>[<span class=\"type\">U</span>]): <span class=\"type\">RDD</span>[<span class=\"type\">U</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明：</strong></p>\n<p>将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子 -flatMap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;Hello Scala&quot;</span>,<span class=\"string\">&quot;Hello Spark&quot;</span></span><br><span class=\"line\">))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> flatRDD = rdd.flatMap(</span><br><span class=\"line\">  s =&gt; &#123;</span><br><span class=\"line\">    s.split(<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">flatRDD.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\"><span class=\"comment\">//Hello</span></span><br><span class=\"line\"><span class=\"comment\">//Scala</span></span><br><span class=\"line\"><span class=\"comment\">//Hello</span></span><br><span class=\"line\"><span class=\"comment\">//Spark</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><code>小功能：将 List(List(1,2),3,List(4,5))进行扁平化操作</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子 -flatMap 将 List(List(1,2),3,List(4,5))进行扁平化操作`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>),<span class=\"number\">3</span>,<span class=\"type\">List</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>)))   <span class=\"comment\">//两层List</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> flatRDD = rdd.flatMap(</span><br><span class=\"line\">  s =&gt; &#123;</span><br><span class=\"line\">    s <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> list:<span class=\"type\">List</span>[_]=&gt;list  <span class=\"comment\">//如果为一个集合类型，返回整个集合</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> data=&gt;<span class=\"type\">List</span>(data)   <span class=\"comment\">//如果为数字 3 不是集合就把他变成集合</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">flatRDD.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"comment\">//4</span></span><br><span class=\"line\"><span class=\"comment\">//5</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"glom\"><a href=\"#glom\" class=\"headerlink\" title=\"glom\"></a>glom</h3><p><strong>函数签名：</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">glom</span></span>(): <span class=\"type\">RDD</span>[<span class=\"type\">Array</span>[<span class=\"type\">T</span>]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//flatmap 整体分解成个体</span></span><br><span class=\"line\"><span class=\"comment\">//glom    个体合并成整体  Array</span></span><br><span class=\"line\">    <span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TODO 算子  glom</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> golmRDD: <span class=\"type\">RDD</span>[<span class=\"type\">Array</span>[<span class=\"type\">Int</span>]] = rdd.glom()</span><br><span class=\"line\">    golmRDD.collect().foreach(data=&gt; println(data.mkString(<span class=\"string\">&quot;,&quot;</span>)))</span><br><span class=\"line\">    <span class=\"comment\">//结果：</span></span><br><span class=\"line\">    <span class=\"comment\">//1,2</span></span><br><span class=\"line\">    <span class=\"comment\">//3,4</span></span><br><span class=\"line\">    sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><code>小功能：计算所有分区最大值求和（分区内取最大值，分区间最大值求和）</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子 小功能：计算所有分区最大值求和（分区内取最大值，分区间最大值求和）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rdd=sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> golmRDD: <span class=\"type\">RDD</span>[<span class=\"type\">Array</span>[<span class=\"type\">Int</span>]] = rdd.glom()</span><br><span class=\"line\"><span class=\"keyword\">val</span> mapRDD=golmRDD.map(</span><br><span class=\"line\">  data=&gt;&#123;</span><br><span class=\"line\">    data.max  <span class=\"comment\">//分区内取最大值</span></span><br><span class=\"line\">    <span class=\"comment\">//分区1：2   分区2：4</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">println(mapRDD.collect().sum)</span><br><span class=\"line\"><span class=\"comment\">//结果： 2+4</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"groupBy\"><a href=\"#groupBy\" class=\"headerlink\" title=\"groupBy\"></a>groupBy</h3><p><strong>函数签名：</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">groupBy</span></span>[<span class=\"type\">K</span>](f: <span class=\"type\">T</span> =&gt; <span class=\"type\">K</span>)(<span class=\"keyword\">implicit</span> kt: <span class=\"type\">ClassTag</span>[<span class=\"type\">K</span>]): <span class=\"type\">RDD</span>[(<span class=\"type\">K</span>, <span class=\"type\">Iterable</span>[<span class=\"type\">T</span>])]</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>将数据根据指定的规则进行分组, 分区默认不变，但是数据会被<font color=\"red\">打乱重新组合</font>，我们将这样的操作称之为<font color=\"red\">shuffle</font>。极限情况下，数据可能被分在同一个分区中</p>\n<p><font color=\"red\">一个组的数据在一个分区中，但是并不是说一个分区中只有一个组</font></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子- groupBy</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"comment\">// groupBy会将数据源中的每一个数据进行分组判断，根据返回的分组key进行分组</span></span><br><span class=\"line\"><span class=\"comment\">// 相同的key值的数据会放置在一个组中</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> groupRDD = rdd.groupBy(_ % <span class=\"number\">2</span>)  <span class=\"comment\">//匿名函数  进行奇偶划分</span></span><br><span class=\"line\">groupRDD.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果</span></span><br><span class=\"line\"><span class=\"comment\">//(0,CompactBuffer(2, 4))</span></span><br><span class=\"line\"><span class=\"comment\">//(1,CompactBuffer(1, 3))</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<p><code>小功能：将 List(&quot;Hello&quot;, &quot;hive&quot;, &quot;hbase&quot;, &quot;Hadoop&quot;)根据单词首写字母进行分组</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子- groupBy 将 List(&quot;Hello&quot;, &quot;hive&quot;, &quot;hbase&quot;, &quot;Hadoop&quot;)根据单词首写字母进行分组`</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;hive&quot;</span>, <span class=\"string\">&quot;hbase&quot;</span>, <span class=\"string\">&quot;Hadoop&quot;</span>))</span><br><span class=\"line\"><span class=\"comment\">// groupBy会将数据源中的每一个数据进行分组判断，根据返回的分组key进行分组</span></span><br><span class=\"line\"><span class=\"comment\">// 相同的key值的数据会放置在一个组中</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> groupRDD = rdd.groupBy(_.charAt(<span class=\"number\">0</span>))  <span class=\"comment\">//匿名函数  按第一个字母进行分组</span></span><br><span class=\"line\">groupRDD.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\"><span class=\"comment\">//(h,CompactBuffer(hive, hbase))</span></span><br><span class=\"line\"><span class=\"comment\">//(H,CompactBuffer(Hello, Hadoop))</span></span><br></pre></td></tr></table></figure>\n\n<p><code>小功能：从服务器日志数据 apache.log 中获取每个时间段访问量。</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子- groupBy 从服务器日志数据 apache.log 中获取每个时间段访问量。</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">&quot;datas/apache.log&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> timeRDD: <span class=\"type\">RDD</span>[(<span class=\"type\">String</span>, <span class=\"type\">Iterable</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)])] = rdd.map(</span><br><span class=\"line\">  line =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//parse()返回的是⼀个Date类型数据，format返回的是⼀个StringBuffer类型的数据</span></span><br><span class=\"line\">    <span class=\"comment\">//1.先把文本格式化为日期 2.转换为Date数据 2.取到小时数据，3.返回元组，按小时数据进行分组，取到一个就迭代器+1</span></span><br><span class=\"line\">    <span class=\"comment\">//SimpleDateFormat函数语法：</span></span><br><span class=\"line\">    <span class=\"comment\">//y 年</span></span><br><span class=\"line\">    <span class=\"comment\">//M 月</span></span><br><span class=\"line\">    <span class=\"comment\">//d 日</span></span><br><span class=\"line\">    <span class=\"comment\">//h 时 在上午或下午 (1~12)</span></span><br><span class=\"line\">    <span class=\"comment\">//H 时 在一天中 (0~23)</span></span><br><span class=\"line\">    <span class=\"comment\">//m 分</span></span><br><span class=\"line\">    <span class=\"comment\">//s 秒</span></span><br><span class=\"line\">    <span class=\"comment\">//S 毫秒</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> datas = line.split(<span class=\"string\">&quot; &quot;</span>) <span class=\"comment\">//所有数据空格拆分</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = datas(<span class=\"number\">3</span>) <span class=\"comment\">// 获取到时间一行  17/05/2015:10:05:34</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sdf  =<span class=\"keyword\">new</span> <span class=\"type\">SimpleDateFormat</span>(<span class=\"string\">&quot;dd/MM/yyyy:HH:mm:ss&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> date =sdf.parse(time)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sdf1 =<span class=\"keyword\">new</span> <span class=\"type\">SimpleDateFormat</span>(<span class=\"string\">&quot;HH&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> hour =sdf1.format(date)     <span class=\"comment\">//把小时转换为String类型</span></span><br><span class=\"line\">    (hour,<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">).groupBy(_._1)    <span class=\"comment\">//匿名函数  按返回的参数1  也就是返回的hour进行分组</span></span><br><span class=\"line\">timeRDD.map&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span>(hour,iter)=&gt;&#123;</span><br><span class=\"line\">    (hour,iter.size)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\"><span class=\"comment\">//(06,366)</span></span><br><span class=\"line\"><span class=\"comment\">//(20,486)</span></span><br><span class=\"line\"><span class=\"comment\">//(19,493)</span></span><br><span class=\"line\"><span class=\"comment\">//(15,496)</span></span><br><span class=\"line\"><span class=\"comment\">//(00,361)</span></span><br><span class=\"line\"><span class=\"comment\">//等等....</span></span><br><span class=\"line\"></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p> <strong>函数签名:</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">filter</span></span>(f: <span class=\"type\">T</span> =&gt; <span class=\"type\">Boolean</span>): <span class=\"type\">RDD</span>[<span class=\"type\">T</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>将数据根据指定的规则进行<strong>筛选过滤</strong>，符合规则的数据保留，不符合规则的数据丢弃。当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡，生产环境下，可能会出现<font color=\"red\">数据倾斜</font></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子-  filter</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> filterRDD = rdd.filter(_%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)</span><br><span class=\"line\">filterRDD.collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果</span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//3</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sample\"><a href=\"#sample\" class=\"headerlink\" title=\"sample\"></a>sample</h3><p> <strong>函数签名:</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sample</span></span>( withReplacement: </span><br><span class=\"line\">           <span class=\"type\">Boolean</span>, fraction: <span class=\"type\">Double</span>,</span><br><span class=\"line\">\t\t   seed: <span class=\"type\">Long</span> = <span class=\"type\">Utils</span>.random.nextLong): <span class=\"type\">RDD</span>[<span class=\"type\">T</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>根据指定的规则从数据集中抽取<font color=\"red\">数据</font></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子-\tsample</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>))</span><br><span class=\"line\"><span class=\"comment\">//sample算子需要转递三个参数</span></span><br><span class=\"line\"><span class=\"comment\">//1.第一个参数表示，抽取数据后是否将数据返回 true(放回)，false(丢弃)</span></span><br><span class=\"line\"><span class=\"comment\">//2.第二个参数表示：</span></span><br><span class=\"line\"><span class=\"comment\">//       如果抽取不放回的场合，数据源中每一条数据被抽取的概率，基准值的概念</span></span><br><span class=\"line\"><span class=\"comment\">//       如果抽取放回的场合：表示数据源中的每一条数据被抽取的可能次数</span></span><br><span class=\"line\"><span class=\"comment\">//3.第三个参数表示：抽取数据时随机算法的种子</span></span><br><span class=\"line\"><span class=\"comment\">//               如果不传递第三个参数，那么使用的是当前系统时间</span></span><br><span class=\"line\">println(rdd.sample(</span><br><span class=\"line\">  <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"number\">0.4</span></span><br><span class=\"line\">  <span class=\"comment\">// 1</span></span><br><span class=\"line\">).collect().mkString(<span class=\"string\">&quot;,&quot;</span>))</span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"distinct\"><a href=\"#distinct\" class=\"headerlink\" title=\"distinct\"></a>distinct</h3><p> <strong>函数签名:</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">distinct</span></span>()(<span class=\"keyword\">implicit</span> ord: <span class=\"type\">Ordering</span>[<span class=\"type\">T</span>] = <span class=\"literal\">null</span>): <span class=\"type\">RDD</span>[<span class=\"type\">T</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">distinct</span></span>(numPartitions: <span class=\"type\">Int</span>)(<span class=\"keyword\">implicit</span> ord: <span class=\"type\">Ordering</span>[<span class=\"type\">T</span>] = <span class=\"literal\">null</span>): <span class=\"type\">RDD</span>[<span class=\"type\">T</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>将数据集中重复的数据去重</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子-\tdistinct</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">rdd.distinct().collect().foreach(println)</span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\"><span class=\"comment\">//1 2 3 4</span></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"coalesce\"><a href=\"#coalesce\" class=\"headerlink\" title=\"coalesce\"></a>coalesce</h3><p> <strong>函数签名:</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">coalesce</span></span>(numPartitions: <span class=\"type\">Int</span>, shuffle: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t\t\tpartitionCoalescer: <span class=\"type\">Option</span>[<span class=\"type\">PartitionCoalescer</span>] = <span class=\"type\">Option</span>.empty) </span><br><span class=\"line\">\t\t\t\t\t(<span class=\"keyword\">implicit</span> ord: <span class=\"type\">Ordering</span>[<span class=\"type\">T</span>] = <span class=\"literal\">null</span>)</span><br><span class=\"line\">: <span class=\"type\">RDD</span>[<span class=\"type\">T</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>根据数据量<font color=\"red\">缩减分区</font>，用于大数据集过滤后，提高小数据集的执行效率</p>\n<p>当 spark 程序中，存在过多的小任务的时候，可以通过 coalesce 方法，收缩合并分区，减少分区的个数，减小任务调度成本</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// TODO 算子-\tcoalesce</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">4</span>)</span><br><span class=\"line\">   <span class=\"comment\">//coalesce方法默认情况下不会将分区的数据打乱重新组合</span></span><br><span class=\"line\">   <span class=\"comment\">//这种情况下的缩减分区可能会导致数据不均衡，出现数据倾斜</span></span><br><span class=\"line\">   <span class=\"comment\">//如果想要将数据均衡，可以进行shuffle处理,第二个参数填true  但是数据会被打乱</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">val</span> newRDD: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] = rdd.coalesce(<span class=\"number\">2</span>)</span><br><span class=\"line\">   <span class=\"comment\">// val newRDD: RDD[Int] = rdd.coalesce(2,true)</span></span><br><span class=\"line\">   newRDD.saveAsTextFile(<span class=\"string\">&quot;output&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"repartition\"><a href=\"#repartition\" class=\"headerlink\" title=\"repartition\"></a>repartition</h3><p> <strong>函数签名:</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">repartition</span></span>(numPartitions: <span class=\"type\">Int</span>)(<span class=\"keyword\">implicit</span> ord: <span class=\"type\">Ordering</span>[<span class=\"type\">T</span>] = <span class=\"literal\">null</span>): <span class=\"type\">RDD</span>[<span class=\"type\">T</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>该操作内部其实执行的是 coalesce 操作，参数 shuffle 的默认值为 true。无论是将分区数多的RDD 转换为分区数少的RDD，还是将分区数少的 RDD 转换为分区数多的RDD，repartition 操作都可以完成，因为无论如何都会经 shuffle 过程。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// TODO 算子-\trepartition</span></span><br><span class=\"line\">   <span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//coalesce算子可以扩大分区的，但是如果不进行shuffle操作，是没有意义，不起作用</span></span><br><span class=\"line\">   <span class=\"comment\">//所以如果想要实现扩大分区的效果，需要使用shuffle操作</span></span><br><span class=\"line\">   <span class=\"comment\">//spark提供了一个简化的操作</span></span><br><span class=\"line\">   <span class=\"comment\">//缩减分区：coalesce,如果想要数据均衡，可以采用shuffle 默认为flase</span></span><br><span class=\"line\">   <span class=\"comment\">//扩大分区：repartition,底层代码调用的就是coalesce,而且肯定采用shuffle  默认为true</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">val</span> newRDD: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] = rdd.repartition(<span class=\"number\">3</span>)</span><br><span class=\"line\">   newRDD.saveAsTextFile(<span class=\"string\">&quot;output&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sortBy\"><a href=\"#sortBy\" class=\"headerlink\" title=\"sortBy\"></a>sortBy</h3><p> <strong>函数签名:</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> </span></span><br><span class=\"line\">\tsortBy[<span class=\"type\">K</span>]( f: </span><br><span class=\"line\">    (<span class=\"type\">T</span>) =&gt; <span class=\"type\">K</span>,</span><br><span class=\"line\">    ascending: <span class=\"type\">Boolean</span> =  <span class=\"literal\">true</span>, numPartitions: <span class=\"type\">Int</span> = <span class=\"keyword\">this</span>.partitions.length)</span><br><span class=\"line\">(<span class=\"keyword\">implicit</span> ord: <span class=\"type\">Ordering</span>[<span class=\"type\">K</span>], ctag: <span class=\"type\">ClassTag</span>[<span class=\"type\">K</span>]): <span class=\"type\">RDD</span>[<span class=\"type\">T</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>该操作用于排序数据。<strong>在排序之前，可以将数据通过 f 函数进行处理，之后按照 f 函数处理的结果进行排序，默认为升序排列</strong>。排序后新产生的 RDD 的分区数与原RDD 的分区数一致。<strong>中间存在 shuffle 的过程</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子-\tsortBy</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>((<span class=\"string\">&quot;1&quot;</span>,<span class=\"number\">1</span>),(<span class=\"string\">&quot;11&quot;</span>,<span class=\"number\">2</span>),(<span class=\"string\">&quot;2&quot;</span>,<span class=\"number\">3</span>)),<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sortBy方法可以根据指定的规则对数据源中的数据进行排序，默认为升序 第二个参数可以改变排序的方式</span></span><br><span class=\"line\"><span class=\"comment\">//sortBy默认情况下，不会改变分区。但是中间存在shuffle操作</span></span><br><span class=\"line\"><span class=\"comment\">//false:降序  true:升序  默认为true  升序：小到大</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> newRDD = rdd.sortBy(t=&gt;t._1.toInt,<span class=\"literal\">true</span>)</span><br><span class=\"line\">newRDD.collect().foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双-Value-类型\"><a href=\"#双-Value-类型\" class=\"headerlink\" title=\"双 Value 类型\"></a><strong>双</strong> <strong>Value</strong> <strong>类型</strong></h3><ul>\n<li>交集： <strong>intersection</strong></li>\n</ul>\n<p>对源RDD 和参数RDD 求交集后返回一个新的RDD</p>\n<ul>\n<li>并集： <strong>union</strong></li>\n</ul>\n<p>对源RDD 和参数RDD 求并集后返回一个新的RDD</p>\n<ul>\n<li>差集： <strong>subtract</strong></li>\n</ul>\n<p>以一个 RDD 元素为主，去除两个 RDD 中重复元素，将其他元素保留下来。求差集</p>\n<ul>\n<li>拉链： <strong>zip</strong></li>\n</ul>\n<p>将两个 RDD 中的元素，以键值对的形式进行合并。其中，键值对中的Key 为第 1 个 RDD中的元素，Value 为第 2 个 RDD 中的相同位置的元素</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子-\t双Value类型</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd1 = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd2 = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"comment\">//交集，并集和差集要求两个数据源数据类型报错一致</span></span><br><span class=\"line\"><span class=\"comment\">//拉链操作两个数据的类型可以不一致，两个数据源要求分区数据数量保持一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集：【3,4】   intersection</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd3: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] = rdd1.intersection(rdd2)</span><br><span class=\"line\">println(rdd3.collect().mkString(<span class=\"string\">&quot;,&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并集： 【1,2,3,4,5,6】  union</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd4: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] = rdd1.union(rdd2)</span><br><span class=\"line\">println(rdd4.collect().mkString(<span class=\"string\">&quot;,&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//差集：【1,2】     subtract</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd5: <span class=\"type\">RDD</span>[<span class=\"type\">Int</span>] = rdd1.subtract(rdd2)</span><br><span class=\"line\">println(rdd5.collect().mkString(<span class=\"string\">&quot;,&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//拉链：【1-3,2-4,3-5,4-6】   zip</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd6: <span class=\"type\">RDD</span>[(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>)] = rdd1.zip(rdd2)</span><br><span class=\"line\">println(rdd6.collect().mkString(<span class=\"string\">&quot;,&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>思考一个问题：如果两个RDD 数据类型不一致怎么办？</li>\n</ul>\n<p>交集，并集和差集要求两个数据源数据类型报错一致,但拉链操作两个数据的类型可以不一致</p>\n<ul>\n<li><p>思考一个问题：如果两个RDD 数据分区不一致怎么办？</p>\n</li>\n<li><p>思考一个问题：如果两个RDD 分区数据数量不一致怎么办？</p>\n<p>交集，并集和差集 可以不一致    但拉链要求一致</p>\n</li>\n</ul>\n<h3 id=\"Key-Value-类型\"><a href=\"#Key-Value-类型\" class=\"headerlink\" title=\"Key - Value 类型\"></a><strong>Key - Value</strong> <strong>类型</strong></h3><h3 id=\"partitionBy\"><a href=\"#partitionBy\" class=\"headerlink\" title=\"partitionBy\"></a><strong>partitionBy</strong></h3><p><strong>函数签名:</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partitionBy</span></span>(partitioner: <span class=\"type\">Partitioner</span>): <span class=\"type\">RDD</span>[(<span class=\"type\">K</span>, <span class=\"type\">V</span>)]</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数说明:</strong></p>\n<p>将数据按照指定Partitioner 重新进行分区。Spark 默认的分区器是HashPartitioner</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//TODO 准备环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;RDD&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sc=<span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(sparkConf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO 算子-\tKey-Value类型</span></span><br><span class=\"line\"><span class=\"comment\">//指数据不是单一的值，是特点的类型叫键值类型</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//利用map将int转换为tape类型，形成了键值类型,partitionBy就可以使用了</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> mapRDD: <span class=\"type\">RDD</span>[(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>)] = rdd.map((_, <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\">//RDD=&gt;PairRDDFunctions</span></span><br><span class=\"line\"><span class=\"comment\">//隐式转换(二次编译)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//partitionBy根据指定的分区规则(HashPartitioner)对数据进程重分区</span></span><br><span class=\"line\">mapRDD.partitionBy(<span class=\"keyword\">new</span> <span class=\"type\">HashPartitioner</span>(<span class=\"number\">2</span>)).saveAsTextFile(<span class=\"string\">&quot;output&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sc.stop()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>思考一个问题：如果重分区的分区器和当前RDD 的分区器一样怎么办?</li>\n</ul>\n<p>如果数量和类型是一样的，什么都不会做，但是类型不匹配，数量不匹配，就会产生新的RDD</p>\n<ul>\n<li>思考一个问题：Spark 还有其他分区器吗？</li>\n</ul>\n<p>RangePartitioner(排序范围)、PythonPartitioner、HashPartitioner(哈希)</p>\n<p>像sortBy(排序)方法里就使用了RangePartitioner</p>\n<ul>\n<li>思考一个问题：如果想按照自己的方法进行数据分区怎么办？</li>\n</ul>\n<p>可以自己写个分区器</p>\n<p>  <code>思考一个问题：哪那么多问题？</code></p>\n","categories":["Spark"],"tags":["Spark"]},{"title":"SparkSQL","url":"/2022/07/29/sparksql/","content":"<p><img src=\"/2022/07/29/sparksql/0.png\"></p>\n<h1 id=\"SparkSQl概述\"><a href=\"#SparkSQl概述\" class=\"headerlink\" title=\"SparkSQl概述\"></a>SparkSQl概述</h1><p>对于开发人员来讲，SparkSQL 可以简化RDD 的开发，提高开发效率，且执行效率非常快，所以实际工作中，基本上采用的就是 SparkSQL。Spark SQL 为了简化RDD 的开发， 提高开发效率，提供了 2 个编程抽象，类似Spark Core 中的RDD</p>\n<ul>\n<li><strong>DataFrame</strong></li>\n<li><strong>DataSet</strong></li>\n</ul>\n<h2 id=\"DataFrame-是什么\"><a href=\"#DataFrame-是什么\" class=\"headerlink\" title=\"DataFrame 是什么\"></a><strong>DataFrame</strong> <strong>是什么</strong></h2><p>​        在 Spark 中，DataFrame 是一种以 RDD 为基础的分布式数据集，类似于传统数据库中的二维表格。DataFrame 与 RDD 的主要区别在于，前者带有 schema 元信息，即 DataFrame 所表示的二维表数据集的每一列都带有名称和类型。这使得 Spark SQL 得以洞察更多的结构信息，从而对藏于 DataFrame 背后的数据源以及作用于 DataFrame 之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观 RDD，由于无从得知所存数据元素的具体内部结构，Spark Core 只能在 stage 层面进行简单、通用的流水线优化。</p>\n<p>​       同时，与Hive 类似，DataFrame 也支持嵌套数据类型（struct、array 和 map）。从 API 易用性的角度上看，DataFrame API 提供的是一套高层的关系操作，比函数式的 RDD API 要更加友好，门槛更低。</p>\n<img src=\"/2022/07/29/sparksql/1.png\" style=\"zoom: 80%;\">\n上图直观地体现了DataFrame 和 RDD 的区别。\n\n<p>左侧的 RDD[Person]虽然以 Person 为类型参数，但 Spark 框架本身不了解Person 类的内部结构。而右侧的DataFrame 却提供了详细的结构信息，使得 Spark SQL 可以清楚地知道该数据集中包含哪些列，每列的名称和类型各是什么。</p>\n<p>DataFrame 是为数据提供了 Schema 的视图。可以把它当做数据库中的一张表来对待DataFrame 也是懒执行的，但性能上比 RDD 要高，主要原因：优化的执行计划，即查询计划通过 Spark catalyst optimiser 进行优化。比如下面一个例子:</p>\n<img src=\"/2022/07/29/sparksql/2.png\" style=\"zoom:80%;\">\n\n<p>为了说明查询优化，我们来看下方图片展示的人口数据分析的示例。图中构造了两个DataFrame，将它们 join 之后又做了一次filter 操作。如果原封不动地执行这个执行计划，最终的执行效率是不高的。因为 join 是一个代价较大的操作，也可能会产生一个较大的数据集。如果我们能将filter 下推到 join 下方，先对DataFrame 进行过滤，再 join 过滤后的较小的结果集，便可以有效缩短执行时间。而 Spark SQL 的查询优化器正是这样做的。简而言之， 逻辑查询计划优化就是一个利用基于关系代数的等价变换，将高成本的操作替换为低成本操作的过程。</p>\n<img src=\"/2022/07/29/sparksql/3.png\" style=\"zoom:80%;\">\n\n<h2 id=\"DataSet-是什么\"><a href=\"#DataSet-是什么\" class=\"headerlink\" title=\"DataSet 是什么\"></a><strong>DataSet</strong> <strong>是什么</strong></h2><p>DataSet 是分布式数据集合。DataSet 是Spark 1.6 中添加的一个新抽象，是DataFrame的一个扩展。它提供了RDD 的优势（强类型，使用强大的 lambda 函数的能力）以及SparkSQL 优化执行引擎的优点。DataSet 也可以使用功能性的转换（操作 map，flatMap，filter等等）。</p>\n<ul>\n<li>DataSet 是DataFrame API 的一个扩展，是SparkSQL 最新的数据抽象</li>\n<li>用户友好的 API 风格，既具有类型安全检查也具有DataFrame 的查询优化特性；</li>\n<li><strong>用样例类来对DataSet 中定义数据的结构信息，样例类中每个属性的名称直接映射到DataSet 中的字段名称</strong>；</li>\n<li>DataSet 是强类型的。比如可以有 DataSet[Car]，DataSet[Person]。</li>\n<li>DataFrame 是DataSet 的特列，DataFrame&#x3D;DataSet[Row] ，所以可以通过 as 方法将</li>\n<li>DataFrame 转换为DataSet。Row 是一个类型，跟 Car、Person 这些的类型一样，所有的表结构信息都用 Row 来表示。获取数据时需要指定顺序</li>\n</ul>\n<h1 id=\"SparkSQL-核心编程\"><a href=\"#SparkSQL-核心编程\" class=\"headerlink\" title=\"SparkSQL 核心编程\"></a><strong>SparkSQL 核心编程</strong></h1><h2 id=\"新的起点\"><a href=\"#新的起点\" class=\"headerlink\" title=\"新的起点\"></a><strong>新的起点</strong></h2><p>Spark Core 中，如果想要执行应用程序，需要首先构建上下文环境对象 SparkContext， Spark SQL 其实可以理解为对 Spark Core 的一种封装，不仅仅在模型上进行了封装，上下文环境对象也进行了封装。</p>\n<p>在老的版本中，SparkSQL 提供两种 SQL 查询起始点：一个叫 SQLContext，用于 Spark自己提供的SQL 查询；一个叫HiveContext，用于连接 Hive 的查询。</p>\n<p><font color=\"red\">SparkSession</font> 是 Spark 最新的 SQL 查询起始点，实质上是 SQLContext 和HiveContext 的组合，所以在 SQLContex 和HiveContext 上可用的API 在 SparkSession 上同样是可以使用的。SparkSession 内部封装了 SparkContext，所以计算实际上是由 sparkContext 完成的。当我们使用 spark-shell 的时候, spark 框架会自动的创建一个名称叫做 spark 的SparkSession 对象, 就像我们以前可以自动获取到一个 sc 来表示 SparkContext 对象一样</p>\n<img src=\"/2022/07/29/sparksql/4.png\" style=\"zoom:80%;\">\n\n<h2 id=\"DataFrame\"><a href=\"#DataFrame\" class=\"headerlink\" title=\"DataFrame\"></a><strong>DataFrame</strong></h2><p>Spark SQL 的DataFrame API 允许我们使用 DataFrame 而不用必须去注册临时表或者生成 SQL 表达式。DataFrame API 既有 transformation 操作也有 action 操作</p>\n<img src=\"/2022/07/29/sparksql/5.png\" style=\"zoom:80%;\">\n\n<h3 id=\"创建-DataFrame\"><a href=\"#创建-DataFrame\" class=\"headerlink\" title=\"创建 DataFrame\"></a><strong>创建</strong> <strong>DataFrame</strong></h3><p>在 Spark SQL 中 SparkSession 是创建DataFrame 和执行 SQL 的入口，创建 DataFrame 有三种方式：通过Spark 的数据源进行创建；从一个存在的RDD 进行转换；还可以从HiveTable 进行查询返回</p>\n<p><strong>查看 Spark 支持创建文件的数据源格式</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; spark.read.</span><br><span class=\"line\">csv\t  format  jdbc\tjson\tload\toption\toptions\torc\tparquet\tschema table\t\ttext\ttextFile</span><br></pre></td></tr></table></figure>\n\n<p>在 spark 的 bin&#x2F;data 目录中创建 user.json 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;username&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取 json 文件创建DataFrame</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> df = spark.read.json(<span class=\"string\">&quot;data/user.json&quot;</span>)</span><br><span class=\"line\">df: org.apache.spark.sql.<span class=\"type\">DataFrame</span> = [age: bigint， username: string]</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\">注意：如果从内存中获取数据，spark 可以知道数据类型具体是什么。如果是数字，默认作为 Int 处理；但是从文件中读取的数字，不能确定是什么类型，所以用 bigint 接收，可以和Long 类型转换，但是和 Int 不能进行转换</font></p>\n<h3 id=\"SQL-语法\"><a href=\"#SQL-语法\" class=\"headerlink\" title=\"SQL 语法\"></a><strong>SQL</strong> <strong>语法</strong></h3><p><strong>1.在 spark 的 bin&#x2F;data 目录中创建 user.json 文件</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;username&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;zhangsan&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;age&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">20</span><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>2.读取 JSON 文件创建DataFrame</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt;<span class=\"keyword\">val</span> df = spark.read.json(<span class=\"string\">&quot;data/user.json&quot;</span>)</span><br><span class=\"line\">df: org.apache.spark.sql.<span class=\"type\">DataFrame</span> = [age: bigint， username: string]</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.对 DataFrame 创建一个临时表</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; df.createOrReplaceTempView(<span class=\"string\">&quot;people&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.对于DataFrame 创建一个全局表</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; df.createGlobalTempView(<span class=\"string\">&quot;people&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过 SQL 语句实现查询全表</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; spark.sql(<span class=\"string\">&quot;SELECT * FROM people&quot;</span>).show  <span class=\"comment\">//临时表</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; spark.sql(<span class=\"string\">&quot;SELECT * FROM global_temp.people&quot;</span>).show() <span class=\"comment\">//全局表</span></span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\"><strong>注意：普通临时表是 Session 范围内的，如果想应用范围内有效，可以使用全局临时表。使用全局临时表时需要全路径访问，如：global_temp.people</strong></font></p>\n<h3 id=\"DSL-语法\"><a href=\"#DSL-语法\" class=\"headerlink\" title=\"DSL 语法\"></a><strong>DSL</strong> <strong>语法</strong></h3><p>DataFrame 提供一个特定领域语言(domain-specific language, DSL)去管理结构化的数据。可以在 Scala, Java, Python 和 R 中使用 DSL，<strong>使用 DSL 语法风格不必去创建临时视图了</strong></p>\n<ol>\n<li>创建DataFrame,读取 JSON 文件</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; scala&gt;<span class=\"keyword\">val</span> df = spark.read.json(<span class=\"string\">&quot;data/user.json&quot;</span>)</span><br><span class=\"line\">df: org.apache.spark.sql.<span class=\"type\">DataFrame</span> = [age: bigint， username: string]</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>查看DataFrame 的 Schema 信息</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; df.printSchema </span><br><span class=\"line\">root</span><br><span class=\"line\">|-- age: <span class=\"type\">Long</span> (nullable = <span class=\"literal\">true</span>)</span><br><span class=\"line\">|-- username: string (nullable = <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>只查看”age”列数据</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; df.select(<span class=\"string\">&quot;age&quot;</span>).show()</span><br><span class=\"line\">+---+</span><br><span class=\"line\">|age|</span><br><span class=\"line\">+---+</span><br><span class=\"line\">| <span class=\"number\">30</span>|</span><br><span class=\"line\">| <span class=\"number\">20</span>|</span><br><span class=\"line\">| <span class=\"number\">40</span>|</span><br><span class=\"line\">+---+</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>查看”username”列数据以及”age+1”数据</li>\n</ol>\n<p><font color=\"red\">注意:涉及到运算的时候, 每列都必须使用$, $表示引用这个数据，或者采用引号表达式：单引号+字段名</font></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; df.select($<span class=\"string\">&quot;username&quot;</span>,$<span class=\"string\">&quot;age&quot;</span> + <span class=\"number\">1</span>).show </span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; df.select(&#x27;username, &#x27;age + <span class=\"number\">1</span>).show()</span><br><span class=\"line\">+--------+---------+</span><br><span class=\"line\">|username|(age + <span class=\"number\">1</span>)|</span><br><span class=\"line\">+--------+---------+</span><br><span class=\"line\">|zhangsan|       <span class=\"number\">31</span>|</span><br><span class=\"line\">|zhangsan|       <span class=\"number\">21</span>|</span><br><span class=\"line\">|zhangsan|       <span class=\"number\">41</span>|</span><br><span class=\"line\">+--------+---------+</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>as关键字取别名</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; df.select(&#x27;username,&#x27;age+<span class=\"number\">1</span> as <span class=\"string\">&quot;age加1&quot;</span>).show</span><br><span class=\"line\">+--------+------+</span><br><span class=\"line\">|username|age加<span class=\"number\">1</span>|</span><br><span class=\"line\">+--------+------+</span><br><span class=\"line\">|zhangsan|    <span class=\"number\">31</span>|</span><br><span class=\"line\">|zhangsan|    <span class=\"number\">21</span>|</span><br><span class=\"line\">|zhangsan|    <span class=\"number\">41</span>|</span><br><span class=\"line\">+--------+------+</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>查看”age”大于”30”的数据</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; df.filter(&#x27;age&gt;<span class=\"number\">20</span>).show</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; df.filter($<span class=\"string\">&quot;age&quot;</span>&gt;<span class=\"number\">20</span>).show</span><br><span class=\"line\">+---+--------+</span><br><span class=\"line\">|age|username|</span><br><span class=\"line\">+---+--------+</span><br><span class=\"line\">| <span class=\"number\">30</span>|zhangsan|</span><br><span class=\"line\">| <span class=\"number\">40</span>|zhangsan|</span><br><span class=\"line\">+---+--------+</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>按照”age”分组，查看数据条数</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; df.groupBy(<span class=\"string\">&quot;age&quot;</span>).count.show</span><br><span class=\"line\">+---+-----+</span><br><span class=\"line\">|age|count|</span><br><span class=\"line\">+---+-----+</span><br><span class=\"line\">| <span class=\"number\">30</span>|    <span class=\"number\">1</span>|</span><br><span class=\"line\">| <span class=\"number\">20</span>|    <span class=\"number\">1</span>|</span><br><span class=\"line\">| <span class=\"number\">40</span>|    <span class=\"number\">1</span>|</span><br><span class=\"line\">+---+-----+</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RDD-转换为-DataFrame\"><a href=\"#RDD-转换为-DataFrame\" class=\"headerlink\" title=\"RDD 转换为 DataFrame\"></a><strong>RDD</strong> <strong>转换为</strong> <strong>DataFrame</strong></h3><p>在 IDEA 中开发程序时，如果需要RDD 与DF 或者DS 之间互相操作，那么需要引入</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> spark.implicits._</span><br></pre></td></tr></table></figure>\n\n<p>这里的 spark 不是Scala 中的包名，而是创建的 sparkSession 对象的变量名称，所以必须先创建 SparkSession 对象再导入。这里的 spark 对象不能使用var 声明，因为 Scala 只支持val 修饰的对象的引入。</p>\n<p>spark-shell 中无需导入，自动完成此操作。</p>\n<ol>\n<li><strong>toDF</strong></li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> rdd =sc.makeRDD(<span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; rdd.toDF(<span class=\"string\">&quot;id&quot;</span>).show</span><br><span class=\"line\">+---+</span><br><span class=\"line\">| id|</span><br><span class=\"line\">+---+</span><br><span class=\"line\">|  <span class=\"number\">1</span>|</span><br><span class=\"line\">|  <span class=\"number\">2</span>|</span><br><span class=\"line\">|  <span class=\"number\">3</span>|</span><br><span class=\"line\">|  <span class=\"number\">4</span>|</span><br><span class=\"line\">+---+</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><font color=\"red\">实际开发中，一般通过<strong>样例类</strong>将 RDD 转换为 DataFrame</font></li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">name:<span class=\"type\">String</span>,age:<span class=\"type\">Int</span></span>)</span></span><br><span class=\"line\">defined <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; sc.makeRDD(<span class=\"type\">List</span>((<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">30</span>),(<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">40</span>))).map(t=&gt;<span class=\"type\">User</span>(t._1,t._2)).toDF.show</span><br><span class=\"line\">+--------+---+</span><br><span class=\"line\">|    name|age|</span><br><span class=\"line\">+--------+---+</span><br><span class=\"line\">|zhangsan| <span class=\"number\">30</span>|</span><br><span class=\"line\">|    lisi| <span class=\"number\">40</span>|</span><br><span class=\"line\">+--------+---+</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DataFrame-转换为-RDD\"><a href=\"#DataFrame-转换为-RDD\" class=\"headerlink\" title=\"DataFrame 转换为 RDD\"></a><strong>DataFrame</strong> <strong>转换为</strong> <strong>RDD</strong></h3><p>DataFrame 其实就是对RDD 的封装，所以可以直接获取内部的RDD</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> df=sc.makeRDD(<span class=\"type\">List</span>((<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">30</span>),(<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">40</span>))).map(t=&gt;<span class=\"type\">User</span>(t._1,t._2)).toDF</span><br><span class=\"line\">df: org.apache.spark.sql.<span class=\"type\">DataFrame</span> = [name: string, age: int]</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> array=df.rdd.collect</span><br><span class=\"line\">array: <span class=\"type\">Array</span>[org.apache.spark.sql.<span class=\"type\">Row</span>] = <span class=\"type\">Array</span>([zhangsan,<span class=\"number\">30</span>], [lisi,<span class=\"number\">40</span>])</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\">注意：此时得到的RDD 存储类型为Row</font></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; array(<span class=\"number\">0</span>)</span><br><span class=\"line\">res32: org.apache.spark.sql.<span class=\"type\">Row</span> = [zhangsan,<span class=\"number\">30</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; array(<span class=\"number\">0</span>)(<span class=\"number\">0</span>)</span><br><span class=\"line\">res33: <span class=\"type\">Any</span> = zhangsan</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; array(<span class=\"number\">0</span>)(<span class=\"number\">1</span>)</span><br><span class=\"line\">res35: <span class=\"type\">Any</span> = <span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; array(<span class=\"number\">0</span>).getAs[<span class=\"type\">String</span>](<span class=\"string\">&quot;name&quot;</span>) </span><br><span class=\"line\">res30: <span class=\"type\">String</span> = zhangsan</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DataSet\"><a href=\"#DataSet\" class=\"headerlink\" title=\"DataSet\"></a><strong>DataSet</strong></h2><p>DataSet 是具有<font color=\"red\">强类型</font>的数据集合，需要提供对应的类型信息</p>\n<img src=\"/2022/07/29/sparksql/6.png\" style=\"zoom:80%;\">\n\n<h3 id=\"创建-DataSet\"><a href=\"#创建-DataSet\" class=\"headerlink\" title=\"创建 DataSet\"></a><strong>创建</strong> <strong>DataSet</strong></h3><ol>\n<li>使用样例类序列创建 DataSet</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">name: <span class=\"type\">String</span>, age: <span class=\"type\">Long</span></span>) <span class=\"title\">defined</span> <span class=\"title\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> caseClassDS = <span class=\"type\">Seq</span>(<span class=\"type\">Person</span>(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">2</span>)).toDS()</span><br><span class=\"line\">caseClassDS: org.apache.spark.sql.<span class=\"type\">Dataset</span>[<span class=\"type\">Person</span>] = [name: string, age: <span class=\"type\">Long</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; caseClassDS.show</span><br><span class=\"line\">+---------+---+</span><br><span class=\"line\">|\tname|age|</span><br><span class=\"line\">+---------+---+</span><br><span class=\"line\">| zhangsan| <span class=\"number\">2</span>|</span><br><span class=\"line\">+---------+---+</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用基本类型的序列创建DataSet</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> ds = <span class=\"type\">Seq</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>).toDS</span><br><span class=\"line\">ds: org.apache.spark.sql.<span class=\"type\">Dataset</span>[<span class=\"type\">Int</span>] = [value: int]</span><br><span class=\"line\">scala&gt; ds.show</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">|value|</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">|\t<span class=\"number\">1</span>|</span><br><span class=\"line\">|\t<span class=\"number\">2</span>|</span><br><span class=\"line\">|\t<span class=\"number\">3</span>|</span><br><span class=\"line\">|\t<span class=\"number\">4</span>|</span><br><span class=\"line\">|\t<span class=\"number\">5</span>|</span><br><span class=\"line\">+-----+</span><br></pre></td></tr></table></figure>\n\n<p><strong><font color=\"red\">注意：在实际使用的时候，很少用到把序列转换成DataSet，更多的是通过RDD 来得到DataSet</font></strong></p>\n<h3 id=\"RDD-转换为-DataSet\"><a href=\"#RDD-转换为-DataSet\" class=\"headerlink\" title=\"RDD 转换为 DataSet\"></a><strong>RDD</strong> <strong>转换为</strong> <strong>DataSet</strong></h3><p>SparkSQL 能够自动将包含有 case 类的RDD 转换成DataSet，case 类定义了 table 的结构，case 类属性通过反射变成了表的列名。Case 类可以包含诸如 Seq 或者 Array 等复杂的结构</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">name:<span class=\"type\">String</span>, age:<span class=\"type\">Int</span></span>) </span></span><br><span class=\"line\">defined <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; sc.makeRDD(<span class=\"type\">List</span>((<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">30</span>), (<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">49</span>))).map(t=&gt;<span class=\"type\">User</span>(t._1, t._2)).toDS</span><br><span class=\"line\"><span class=\"comment\">//sc.makeRDD(List(User(&quot;zhangsan&quot;,30),User(&quot;lisi&quot;,49))).toDs</span></span><br><span class=\"line\">res11: org.apache.spark.sql.<span class=\"type\">Dataset</span>[<span class=\"type\">User</span>] = [name: string, age: int]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DataSet-转换为-RDD\"><a href=\"#DataSet-转换为-RDD\" class=\"headerlink\" title=\"DataSet 转换为 RDD\"></a><strong>DataSet</strong> <strong>转换为</strong> <strong>RDD</strong></h3><p>DataSet 其实也是对 RDD 的封装，所以可以直接获取内部的RDD</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">name:<span class=\"type\">String</span>, age:<span class=\"type\">Int</span></span>) </span></span><br><span class=\"line\">defined <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; sc.makeRDD(<span class=\"type\">List</span>((<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">30</span>), (<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">49</span>))).map(t=&gt;<span class=\"type\">User</span>(t._1, t._2)).toDS</span><br><span class=\"line\">res11: org.apache.spark.sql.<span class=\"type\">Dataset</span>[<span class=\"type\">User</span>] = [name: string, age: int]</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> rdd = res11.rdd</span><br><span class=\"line\">rdd: org.apache.spark.rdd.<span class=\"type\">RDD</span>[<span class=\"type\">User</span>] = <span class=\"type\">MapPartitionsRDD</span>[<span class=\"number\">51</span>] at rdd at</span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">25</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; rdd.collect</span><br><span class=\"line\">res12: <span class=\"type\">Array</span>[<span class=\"type\">User</span>] = <span class=\"type\">Array</span>(<span class=\"type\">User</span>(zhangsan,<span class=\"number\">30</span>), <span class=\"type\">User</span>(lisi,<span class=\"number\">49</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DataFrame-和-DataSet-转换\"><a href=\"#DataFrame-和-DataSet-转换\" class=\"headerlink\" title=\"DataFrame 和 DataSet 转换\"></a><strong>DataFrame</strong> <strong>和</strong> <strong>DataSet</strong> <strong>转换</strong></h2><p>DataFrame 其实是DataSet 的特例，所以它们之间是可以互相转换的。</p>\n<p><strong>DataFrame 转换为DataSet</strong>    </p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">name:<span class=\"type\">String</span>, age:<span class=\"type\">Int</span></span>) </span></span><br><span class=\"line\">defined <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> df = sc.makeRDD(<span class=\"type\">List</span>((<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">30</span>), (<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">49</span>))).toDF(<span class=\"string\">&quot;name&quot;</span>,<span class=\"string\">&quot;age&quot;</span>)</span><br><span class=\"line\">df: org.apache.spark.sql.<span class=\"type\">DataFrame</span> = [name: string, age: int]</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> ds = df.as[<span class=\"type\">User</span>]</span><br><span class=\"line\">ds: org.apache.spark.sql.<span class=\"type\">Dataset</span>[<span class=\"type\">User</span>] = [name: string, age: int]</span><br></pre></td></tr></table></figure>\n\n<p><strong>DataSet 转换为DataFrame</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> ds = df.as[<span class=\"type\">User</span>]</span><br><span class=\"line\">ds: org.apache.spark.sql.<span class=\"type\">Dataset</span>[<span class=\"type\">User</span>] = [name: string, age: int]</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> df = ds.toDF</span><br><span class=\"line\">df: org.apache.spark.sql.<span class=\"type\">DataFrame</span> = [name: string, age: int]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RDD、DataFrame、DataSet-三者的关系\"><a href=\"#RDD、DataFrame、DataSet-三者的关系\" class=\"headerlink\" title=\"RDD、DataFrame、DataSet 三者的关系\"></a>RDD、DataFrame、DataSet 三者的关系</h2><p>在 SparkSQL 中 Spark 为我们提供了两个新的抽象，分别是 DataFrame 和 DataSet。他们和 RDD 有什么区别呢？首先从版本的产生上来看：</p>\n<ul>\n<li>Spark1.0 &#x3D;&gt; RDD</li>\n<li>Spark1.3 &#x3D;&gt; DataFrame</li>\n<li>Spark1.6 &#x3D;&gt; Dataset</li>\n</ul>\n<p>如果同样的数据都给到这三个数据结构，他们分别计算之后，都会给出相同的结果。不同是的他们的执行效率和执行方式。在后期的 Spark 版本中，DataSet 有可能会逐步取代RDD和 DataFrame 成为唯一的API 接口。</p>\n<h3 id=\"三者的共性\"><a href=\"#三者的共性\" class=\"headerlink\" title=\"三者的共性\"></a>三者的共性</h3><ul>\n<li><p>RDD、DataFrame、DataSet 全都是 spark 平台下的分布式弹性数据集，为处理超大型数据提供便利;</p>\n</li>\n<li><p>三者都有惰性机制，在进行创建、转换，如 map 方法时，不会立即执行，只有在遇到</p>\n<p>Action 如 foreach 时，三者才会开始遍历运算;</p>\n</li>\n<li><p>三者有许多共同的函数，如 filter，排序等;</p>\n</li>\n<li><p>在对DataFrame 和Dataset 进行操作许多操作都需要这个包:import spark.implicits._（在创建好 SparkSession 对象后尽量直接导入）</p>\n</li>\n<li><p>三者都会根据 Spark 的内存情况自动缓存运算，这样即使数据量很大，也不用担心会内存溢出</p>\n</li>\n<li><p>三者都有 partition 的概念</p>\n</li>\n<li><p>DataFrame 和DataSet 均可使用模式匹配获取各个字段的值和类型</p>\n</li>\n</ul>\n<h3 id=\"三者的区别\"><a href=\"#三者的区别\" class=\"headerlink\" title=\"三者的区别\"></a>三者的区别</h3><ol>\n<li><p>RDD</p>\n<ul>\n<li>RDD 一般和 spark mllib 同时使用</li>\n<li>RDD 不支持 sparksql 操作</li>\n</ul>\n</li>\n<li><p>DataFrame</p>\n<ul>\n<li>与 RDD 和 Dataset 不同，DataFrame 每一行的类型固定为Row，每一列的值没法直接访问，只有通过解析才能获取各个字段的值</li>\n<li>DataFrame 与DataSet 一般不与 spark mllib 同时使用</li>\n<li>DataFrame 与DataSet 均支持 SparkSQL 的操作，比如 select，groupby 之类，还能注册临时表&#x2F;视窗，进行 sql 语句操作</li>\n<li>DataFrame 与DataSet 支持一些特别方便的保存方式，比如保存成 csv，可以带上表头，这样每一列的字段名一目了然(后面专门讲解)</li>\n</ul>\n</li>\n<li><p>DataSet</p>\n<ul>\n<li>Dataset 和DataFrame 拥有完全相同的成员函数，区别只是每一行的数据类型不同。</li>\n</ul>\n<p>  DataFrame 其实就是DataSet 的一个特例 <font color=\"blue\">type DataFrame &#x3D; Dataset[Row]</font></p>\n<ul>\n<li>DataFrame 也可以叫Dataset[Row],每一行的类型是 Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用上面提到的 getAS 方法或者共性中的第七条提到的模式匹配拿出特定字段。而Dataset 中，每一行是什么类型是不一定的，在自定义了 case class 之后可以很自由的获得每一行的信息</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"三者的互相转换\"><a href=\"#三者的互相转换\" class=\"headerlink\" title=\"三者的互相转换\"></a>三者的互相转换</h3><img src=\"/2022/07/29/sparksql/6.png\" style=\"zoom:80%;\">\n\n<h2 id=\"IDEA-开发SparkSQL\"><a href=\"#IDEA-开发SparkSQL\" class=\"headerlink\" title=\"IDEA 开发SparkSQL\"></a><strong>IDEA</strong> 开发SparkSQL</h2><p>实际开发中，都是使用 IDEA 进行开发的。</p>\n<h3 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a><strong>添加依赖</strong></h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.spark<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spark-sql_2.12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--&lt;classifier&gt;sources&lt;/classifier&gt;--&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--去掉上方注释刷新，重启IDEA下载spark-sql源码--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h3><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Spark01_SparkSQL_Basic</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 创建SparkSQL的运行环境  RDD、DataFrame、DataSet 三者的互相转换</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sparkConf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;SparkSql&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> spark = <span class=\"type\">SparkSession</span>.builder().config(sparkConf).getOrCreate()  <span class=\"comment\">//上下文环境对象  builder构建  config传入配置对象</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> spark.implicits._</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//TODO 执行逻辑操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO DataFrame</span></span><br><span class=\"line\">    <span class=\"comment\">//val df: DataFrame = spark.read.json(&quot;datas/user.json&quot;)</span></span><br><span class=\"line\">    <span class=\"comment\">//df.show()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//DataFrame =&gt; SQL    使用SQL语法进行操作要创建视图(表)</span></span><br><span class=\"line\">    <span class=\"comment\">//  df.createOrReplaceTempView(&quot;user&quot;)  //临时视图</span></span><br><span class=\"line\">    <span class=\"comment\">//  spark.sql(&quot;select * from user&quot;).show()</span></span><br><span class=\"line\">    <span class=\"comment\">//  spark.sql(&quot;select age,username from user&quot;).show()</span></span><br><span class=\"line\">    <span class=\"comment\">//  spark.sql(&quot;select avg(age) from user&quot;).show()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//DataFrame =&gt; DSL</span></span><br><span class=\"line\">    <span class=\"comment\">//    df.select(&quot;age&quot;,&quot;username&quot;).show()</span></span><br><span class=\"line\">    <span class=\"comment\">//    df.select(&#x27;username as(&quot;用户名字&quot;),&#x27;age+1 as(&quot;年龄+1&quot;)).show()</span></span><br><span class=\"line\">    <span class=\"comment\">//    df.select($&quot;age&quot;+1).show()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO DataSet</span></span><br><span class=\"line\">    <span class=\"comment\">//DataFrame 其实是特点泛型的DataSet DataFrame所有操作DataSet都能用</span></span><br><span class=\"line\">    <span class=\"comment\">//val seq=Seq(1,2,3,4)</span></span><br><span class=\"line\">    <span class=\"comment\">//val ds=zw.toDS()</span></span><br><span class=\"line\">    <span class=\"comment\">//ds.show()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//RDD &lt;=&gt; DataFrame</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd: <span class=\"type\">RDD</span>[(<span class=\"type\">Int</span>, <span class=\"type\">String</span>, <span class=\"type\">Int</span>)] =spark.sparkContext.makeRDD(<span class=\"type\">List</span>((<span class=\"number\">1</span>,<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">30</span>),(<span class=\"number\">2</span>,<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">40</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> df: <span class=\"type\">DataFrame</span> = rdd.toDF(<span class=\"string\">&quot;id&quot;</span>, <span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;age&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rddRDD: <span class=\"type\">RDD</span>[<span class=\"type\">Row</span>] =df.rdd   <span class=\"comment\">//转换成RDD 和之前类型不一样，之前是Tuple 现在变成了Row</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//DataFrame &lt;=&gt; DataSet</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> ds: <span class=\"type\">Dataset</span>[<span class=\"type\">User</span>] = df.as[<span class=\"type\">User</span>]   <span class=\"comment\">//转成ds 要加个类型</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> df1: <span class=\"type\">DataFrame</span> = ds.toDF()   <span class=\"comment\">// 转成df  把类型去了，直接toDF</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//RDD &lt;=&gt; DataSet</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> ds1: <span class=\"type\">Dataset</span>[<span class=\"type\">User</span>] =rdd.map&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> (id,name,age)=&gt;&#123;</span><br><span class=\"line\">        <span class=\"type\">User</span>(id,name,age)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;.toDS()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> userRDD: <span class=\"type\">RDD</span>[<span class=\"type\">User</span>] =ds1.rdd</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//TODO 关闭环境</span></span><br><span class=\"line\">    spark.close()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">id:<span class=\"type\">Int</span>,name:<span class=\"type\">String</span>,age:<span class=\"type\">Int</span></span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用户自定义函数\"><a href=\"#用户自定义函数\" class=\"headerlink\" title=\"用户自定义函数\"></a>用户自定义函数</h2><p>用户可以通过 <font color=\"red\">spark.udf</font> 功能添加自定义函数，实现自定义功能。</p>\n<h3 id=\"UDF\"><a href=\"#UDF\" class=\"headerlink\" title=\"UDF\"></a>UDF</h3><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TODO 创建SparkSQL的运行环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;SparkSQL&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> spark=<span class=\"type\">SparkSession</span>.builder().config(sparkConf).getOrCreate()</span><br><span class=\"line\"><span class=\"keyword\">import</span>  spark.implicits._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TODO 1.创建DataFrame</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> df=spark.read.json(<span class=\"string\">&quot;datas/user.json&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//TODO 2.创建临时表</span></span><br><span class=\"line\">df.createOrReplaceTempView(<span class=\"string\">&quot;user&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//TODO 3.注册UDF</span></span><br><span class=\"line\">spark.udf.register(<span class=\"string\">&quot;prefixName&quot;</span>,(x:<span class=\"type\">String</span>)=&gt;&#123;</span><br><span class=\"line\"><span class=\"string\">&quot;Name:&quot;</span>+x</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//TODO 3.应用UDF</span></span><br><span class=\"line\">spark.sql(<span class=\"string\">&quot;select age,prefixName(username)  from user&quot;</span>).show() <span class=\"comment\">//给username 加一个前缀</span></span><br><span class=\"line\"></span><br><span class=\"line\">spark.stop()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"UDAF\"><a href=\"#UDAF\" class=\"headerlink\" title=\"UDAF\"></a><strong>UDAF</strong></h3><p><strong>强类型的Dataset 和弱类型的 DataFrame 都提供了相关的聚合函数</strong>， 如 count()countDistinct()，avg()，max()，min()。除此之外，用户可以设定自己的自定义聚合函数。通过继承 <strong>UserDefinedAggregateFunction</strong> 来实现用户自定义弱类型聚合函数。从Spark3.0 版本后，UserDefinedAggregateFunction 已经不推荐使用了。可以统一采用强类型聚合函数Aggregator</p>\n<p><code>注意关键词“聚合”，一般为多进单出类型；有使用数据库经验的小伙伴可以思考一下avg、sum、count、max、min这五个颇具代表性的聚合函数。</code></p>\n<img src=\"/2022/07/29/sparksql/7.png\" style=\"zoom:80%;\">\n\n<p><strong><font color=\"red\">需求：计算平均年龄</font></strong></p>\n<p> 一个需求可以采用很多种不同的方法实现需求</p>\n<h4 id=\"实现方式-RDD\"><a href=\"#实现方式-RDD\" class=\"headerlink\" title=\"实现方式 -RDD\"></a><strong>实现方式 -RDD</strong></h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// TODO 创建SparkSQL的运行环境 利用RDD计算平均年龄</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;SparkSQL&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> spark=<span class=\"type\">SparkSession</span>.builder().config(sparkConf).getOrCreate()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> res=spark.sparkContext.makeRDD(<span class=\"type\">List</span>((<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">20</span>),(<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">30</span>),(<span class=\"string\">&quot;wangwu&quot;</span>,<span class=\"number\">40</span>))).map&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> (name,age)=&gt;&#123;</span><br><span class=\"line\">    (age,<span class=\"number\">1</span>)  <span class=\"comment\">//取到（年龄，计数）</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#125;.reduce&#123;   <span class=\"comment\">//聚合 年龄相加+计数相加</span></span><br><span class=\"line\">    (t1,t2)=&gt;&#123;</span><br><span class=\"line\">      (t1._1+t2._1,+t1._2+t2._2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">println(res._1/res._2)</span><br><span class=\"line\">  </span><br><span class=\"line\">  spark.stop()</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"实现方式-累加器\"><a href=\"#实现方式-累加器\" class=\"headerlink\" title=\"实现方式 - 累加器\"></a><strong>实现方式 - 累加器</strong></h4><h4 id=\"实现方式-UDAF-弱类型\"><a href=\"#实现方式-UDAF-弱类型\" class=\"headerlink\" title=\"实现方式 -UDAF- 弱类型\"></a>实现方式 -UDAF- 弱类型</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zw.bigdata.spark.sql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.<span class=\"type\">SparkConf</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.&#123;<span class=\"type\">Row</span>, <span class=\"type\">SparkSession</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.expressions.&#123;<span class=\"type\">MutableAggregationBuffer</span>, <span class=\"type\">UserDefinedAggregateFunction</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.types.&#123;<span class=\"type\">DataType</span>, <span class=\"type\">LongType</span>, <span class=\"type\">StructField</span>, <span class=\"type\">StructType</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Auther:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * @Date: 2022/7/30</span></span><br><span class=\"line\"><span class=\"comment\"> * @Description: com.zw.bigdata.spark.sql</span></span><br><span class=\"line\"><span class=\"comment\"> * @Version:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Spark04_SparkSQL_UDAF</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 创建SparkSQL的运行环境  实现方式 -UDAF- 弱类型 计算年龄平均值</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;SparkSQL&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> spark=<span class=\"type\">SparkSession</span>.builder().config(sparkConf).getOrCreate()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> df=spark.read.json(<span class=\"string\">&quot;datas/user.json&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//user.json文件内容</span></span><br><span class=\"line\">      <span class=\"comment\">//&#123;&quot;username&quot;: &quot;zhangsan&quot;,&quot;age&quot;: 20&#125;</span></span><br><span class=\"line\">\t  <span class=\"comment\">//&#123;&quot;username&quot;: &quot;lisi&quot;,&quot;age&quot;: 30&#125; </span></span><br><span class=\"line\">      <span class=\"comment\">//&#123;&quot;username&quot;: &quot;wangwu&quot;,&quot;age&quot;: 40&#125;</span></span><br><span class=\"line\">    df.createOrReplaceTempView(<span class=\"string\">&quot;user&quot;</span>)</span><br><span class=\"line\">    spark.udf.register(<span class=\"string\">&quot;ageAvg&quot;</span>,<span class=\"keyword\">new</span> <span class=\"type\">MyAvgUDAF</span>)   <span class=\"comment\">//在 spark 中注册聚合函数</span></span><br><span class=\"line\">    spark.sql(<span class=\"string\">&quot;select ageAvg(age)  from user&quot;</span>).show() </span><br><span class=\"line\"></span><br><span class=\"line\">    spark.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  自定义聚合函数类：计算年龄平均值</span></span><br><span class=\"line\"><span class=\"comment\">  1.继承UserDefinedAggregateFunction</span></span><br><span class=\"line\"><span class=\"comment\">  2.重写方法(8)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAvgUDAF</span> <span class=\"keyword\">extends</span> <span class=\"title\">UserDefinedAggregateFunction</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//输入数据的结构:Int</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inputSchema</span></span>: <span class=\"type\">StructType</span> = &#123;</span><br><span class=\"line\">    <span class=\"type\">StructType</span>(</span><br><span class=\"line\">      <span class=\"type\">Array</span>(</span><br><span class=\"line\">        <span class=\"type\">StructField</span>(<span class=\"string\">&quot;age&quot;</span>,<span class=\"type\">LongType</span>)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//缓冲区数据的结构:Buffer</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bufferSchema</span></span>: <span class=\"type\">StructType</span> = &#123;</span><br><span class=\"line\">      <span class=\"type\">StructType</span>(</span><br><span class=\"line\">        <span class=\"type\">Array</span>(</span><br><span class=\"line\">          <span class=\"type\">StructField</span>(<span class=\"string\">&quot;total&quot;</span>,<span class=\"type\">LongType</span>),</span><br><span class=\"line\">          <span class=\"type\">StructField</span>(<span class=\"string\">&quot;count&quot;</span>,<span class=\"type\">LongType</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//函数计算结果的数据类型：Out</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dataType</span></span>: <span class=\"type\">DataType</span> = <span class=\"type\">LongType</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//函数的稳定性:对于相同的输入是否一直返回相同的输出</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deterministic</span></span>: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//缓冲区初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">initialize</span></span>(buffer: <span class=\"type\">MutableAggregationBuffer</span>): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">      <span class=\"comment\">//buffer(0)=0L</span></span><br><span class=\"line\">      <span class=\"comment\">//buffer(1)=0L</span></span><br><span class=\"line\">      buffer.update(<span class=\"number\">0</span>,<span class=\"number\">0</span>L)<span class=\"comment\">// 存年龄的总和</span></span><br><span class=\"line\">      buffer.update(<span class=\"number\">1</span>,<span class=\"number\">0</span>L)<span class=\"comment\">// 存年龄的个数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据输入的值更新缓冲区数据</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">update</span></span>(buffer: <span class=\"type\">MutableAggregationBuffer</span>, input: <span class=\"type\">Row</span>): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">      buffer.update(<span class=\"number\">0</span>,buffer.getLong(<span class=\"number\">0</span>)+input.getLong(<span class=\"number\">0</span>))</span><br><span class=\"line\">      buffer.update(<span class=\"number\">1</span>,buffer.getLong(<span class=\"number\">1</span>)+<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//缓冲区数据合并</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span></span>(buffer1: <span class=\"type\">MutableAggregationBuffer</span>, buffer2: <span class=\"type\">Row</span>): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">      buffer1.update(<span class=\"number\">0</span>,buffer1.getLong(<span class=\"number\">0</span>)+buffer2.getLong(<span class=\"number\">0</span>))</span><br><span class=\"line\">      buffer1.update(<span class=\"number\">1</span>,buffer1.getLong(<span class=\"number\">1</span>)+buffer2.getLong(<span class=\"number\">1</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//计算平均值</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">evaluate</span></span>(buffer: <span class=\"type\">Row</span>): <span class=\"type\">Any</span> = &#123;</span><br><span class=\"line\">      buffer.getLong(<span class=\"number\">0</span>)/buffer.getLong(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//结果</span></span><br><span class=\"line\"><span class=\"comment\">//+--------------+</span></span><br><span class=\"line\"><span class=\"comment\">//|myavgudaf(age)|</span></span><br><span class=\"line\"><span class=\"comment\">//+--------------+</span></span><br><span class=\"line\"><span class=\"comment\">//|            30|</span></span><br><span class=\"line\"><span class=\"comment\">//+--------------+</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现方式-UDAF-强类型\"><a href=\"#实现方式-UDAF-强类型\" class=\"headerlink\" title=\"实现方式 -UDAF- 强类型\"></a>实现方式 -UDAF- 强类型</h4><p><font color=\"red\">Spark3.0 版本可以采用强类型的 Aggregator 方式代替 UserDefinedAggregateFunction</font></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zw.bigdata.spark.sql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.<span class=\"type\">SparkConf</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.expressions.<span class=\"type\">Aggregator</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.&#123;<span class=\"type\">Encoder</span>, <span class=\"type\">Encoders</span>, <span class=\"type\">Row</span>, <span class=\"type\">SparkSession</span>, functions&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Auther:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * @Date: 2022/7/30</span></span><br><span class=\"line\"><span class=\"comment\"> * @Description: com.zw.bigdata.spark.sql</span></span><br><span class=\"line\"><span class=\"comment\"> * @Version:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Spark04_SparkSQL_UDAF1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 创建SparkSQL的运行环境  实现方式 -UDAF- 强类型 计算年龄平均值</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;SparkSQL&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> spark=<span class=\"type\">SparkSession</span>.builder().config(sparkConf).getOrCreate()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> df=spark.read.json(<span class=\"string\">&quot;datas/user.json&quot;</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//user.json文件内容</span></span><br><span class=\"line\">      <span class=\"comment\">//&#123;&quot;username&quot;: &quot;zhangsan&quot;,&quot;age&quot;: 20&#125;</span></span><br><span class=\"line\">\t  <span class=\"comment\">//&#123;&quot;username&quot;: &quot;lisi&quot;,&quot;age&quot;: 30&#125; </span></span><br><span class=\"line\">      <span class=\"comment\">//&#123;&quot;username&quot;: &quot;wangwu&quot;,&quot;age&quot;: 40&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    df.createOrReplaceTempView(<span class=\"string\">&quot;user&quot;</span>)</span><br><span class=\"line\">    spark.udf.register(<span class=\"string\">&quot;ageAvg&quot;</span>,functions.udaf(<span class=\"keyword\">new</span> <span class=\"type\">MyAvgUDAF</span>))  <span class=\"comment\">//  将强类型转换为弱类型的操作 functions.udaf(agg)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    spark.sql(<span class=\"string\">&quot;select ageAvg(age)  from user&quot;</span>).show() </span><br><span class=\"line\"></span><br><span class=\"line\">    spark.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  自定义聚合函数类：计算年龄平均值</span></span><br><span class=\"line\"><span class=\"comment\">  1.继承org.apache.spark.sql.expressions 定义泛型 把类型定义好了才能用强类型操作数据</span></span><br><span class=\"line\"><span class=\"comment\">      IN:  输入的数据类型Long</span></span><br><span class=\"line\"><span class=\"comment\">      BUF: 缓冲区的数据类型 BUFF</span></span><br><span class=\"line\"><span class=\"comment\">      OUT: 输出的数据类型 Long</span></span><br><span class=\"line\"><span class=\"comment\">  2.重写方法(6)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buff</span>(<span class=\"params\">var total:<span class=\"type\">Long</span>,var count:<span class=\"type\">Long</span></span>)  <span class=\"comment\">//样例类</span></span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAvgUDAF</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aggregator</span>[<span class=\"type\">Long</span>,<span class=\"type\">Buff</span>,<span class=\"type\">Long</span>]</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//z &amp; zero 初始值或零值</span></span><br><span class=\"line\">    <span class=\"comment\">//缓冲区的初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zero</span></span>: <span class=\"type\">Buff</span> = &#123;</span><br><span class=\"line\">      <span class=\"type\">Buff</span>(<span class=\"number\">0</span>L,<span class=\"number\">0</span>L)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据输入的数据更新缓冲区的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reduce</span></span>(buff: <span class=\"type\">Buff</span>, in: <span class=\"type\">Long</span>): <span class=\"type\">Buff</span> = &#123;</span><br><span class=\"line\">      buff.total=buff.total+in  <span class=\"comment\">//年龄增加  </span></span><br><span class=\"line\">      buff.count=buff.count+<span class=\"number\">1</span>   <span class=\"comment\">//计数</span></span><br><span class=\"line\">      buff</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//合并缓冲区</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span></span>(buff1: <span class=\"type\">Buff</span>, buff2: <span class=\"type\">Buff</span>): <span class=\"type\">Buff</span> = &#123;</span><br><span class=\"line\">      buff1.total=buff1.total+buff2.total</span><br><span class=\"line\">      buff1.count=buff1.count+buff2.count</span><br><span class=\"line\">      buff1                      <span class=\"comment\">//返回合 合并后的缓冲区</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//计算结果</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">finish</span></span>(buff: <span class=\"type\">Buff</span>): <span class=\"type\">Long</span> = &#123;</span><br><span class=\"line\">      buff.total/buff.count   <span class=\"comment\">//年龄总数/计数  求平均值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//缓冲区编码操作  固定写法  自定义类：product</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bufferEncoder</span></span>: <span class=\"type\">Encoder</span>[<span class=\"type\">Buff</span>] = <span class=\"type\">Encoders</span>.product</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//输出的编码操作  固定写法  scala存在的类：scalaLong</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">outputEncoder</span></span>: <span class=\"type\">Encoder</span>[<span class=\"type\">Long</span>] = <span class=\"type\">Encoders</span>.scalaLong</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">////结果：</span></span><br><span class=\"line\"><span class=\"comment\">//+--------------+</span></span><br><span class=\"line\"><span class=\"comment\">//|myavgudaf(age)|</span></span><br><span class=\"line\"><span class=\"comment\">//+--------------+</span></span><br><span class=\"line\"><span class=\"comment\">//|            30|</span></span><br><span class=\"line\"><span class=\"comment\">//+--------------+</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现方式-UDAD-早期强类型函数实现\"><a href=\"#实现方式-UDAD-早期强类型函数实现\" class=\"headerlink\" title=\"实现方式 -UDAD- 早期强类型函数实现\"></a>实现方式 -UDAD- 早期强类型函数实现</h4><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zw.bigdata.spark.sql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.<span class=\"type\">SparkConf</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.expressions.<span class=\"type\">Aggregator</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.&#123;<span class=\"type\">Dataset</span>, <span class=\"type\">Encoder</span>, <span class=\"type\">Encoders</span>, <span class=\"type\">SparkSession</span>, <span class=\"type\">TypedColumn</span>, functions&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Auther:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * @Date: 2022/7/30</span></span><br><span class=\"line\"><span class=\"comment\"> * @Description: com.zw.bigdata.spark.sql</span></span><br><span class=\"line\"><span class=\"comment\"> * @Version:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Spark04_SparkSQL_UDAF2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO 创建SparkSQL的运行环境  实现方式 -UDAF- 强类型</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>).setAppName(<span class=\"string\">&quot;SparkSQL&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> spark=<span class=\"type\">SparkSession</span>.builder().config(sparkConf).getOrCreate()</span><br><span class=\"line\">    <span class=\"keyword\">import</span> spark.implicits._</span><br><span class=\"line\">    <span class=\"keyword\">val</span> df=spark.read.json(<span class=\"string\">&quot;datas/user.json&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//早期版本中，spark不能在sql中使用强类型UDAF操作</span></span><br><span class=\"line\">    <span class=\"comment\">//SQL:结构化 &amp; DSL：面向对象</span></span><br><span class=\"line\">    <span class=\"comment\">//早期的UDAF强类型聚合函数使用DSL语法操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> ds: <span class=\"type\">Dataset</span>[<span class=\"type\">User</span>] = df.as[<span class=\"type\">User</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将UDAF函数转换为查询的列对象</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> udadCol: <span class=\"type\">TypedColumn</span>[<span class=\"type\">User</span>, <span class=\"type\">Long</span>] = <span class=\"keyword\">new</span> <span class=\"type\">MyAvgUDAF</span>().toColumn</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//DSL语法</span></span><br><span class=\"line\">    ds.select(udadCol).show()</span><br><span class=\"line\"></span><br><span class=\"line\">    spark.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">username:<span class=\"type\">String</span>,age:<span class=\"type\">Long</span></span>)</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buff</span>(<span class=\"params\">var total:<span class=\"type\">Long</span>,var count:<span class=\"type\">Long</span></span>)  <span class=\"comment\">//样例类</span></span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAvgUDAF</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aggregator</span>[<span class=\"type\">User</span>,<span class=\"type\">Buff</span>,<span class=\"type\">Long</span>]</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//z &amp; zero 初始值或零值</span></span><br><span class=\"line\">    <span class=\"comment\">//缓冲区的初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zero</span></span>: <span class=\"type\">Buff</span> = &#123;</span><br><span class=\"line\">      <span class=\"type\">Buff</span>(<span class=\"number\">0</span>L,<span class=\"number\">0</span>L)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据输入的数据更新缓冲区的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reduce</span></span>(buff: <span class=\"type\">Buff</span>, in: <span class=\"type\">User</span>): <span class=\"type\">Buff</span> = &#123;</span><br><span class=\"line\">      buff.total=buff.total+in.age  <span class=\"comment\">//年龄增加</span></span><br><span class=\"line\">      buff.count=buff.count+<span class=\"number\">1</span>   <span class=\"comment\">//计数</span></span><br><span class=\"line\">      buff</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//合并缓冲区</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span></span>(buff1: <span class=\"type\">Buff</span>, buff2: <span class=\"type\">Buff</span>): <span class=\"type\">Buff</span> = &#123;</span><br><span class=\"line\">      buff1.total=buff1.total+buff2.total</span><br><span class=\"line\">      buff1.count=buff1.count+buff2.count</span><br><span class=\"line\">      buff1                      <span class=\"comment\">//返回合 合并后的缓冲区</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//计算结果</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">finish</span></span>(buff: <span class=\"type\">Buff</span>): <span class=\"type\">Long</span> = &#123;</span><br><span class=\"line\">      buff.total/buff.count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//缓冲区编码操作  固定写法  自定义类：product</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bufferEncoder</span></span>: <span class=\"type\">Encoder</span>[<span class=\"type\">Buff</span>] = <span class=\"type\">Encoders</span>.product</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//输出的编码操作  固定写法  scala存在的类：scalaLong</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">outputEncoder</span></span>: <span class=\"type\">Encoder</span>[<span class=\"type\">Long</span>] = <span class=\"type\">Encoders</span>.scalaLong</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">////结果：</span></span><br><span class=\"line\"><span class=\"comment\">//+---------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"comment\">//|MyAvgUDAF(com.zw.bigdata.spark.sql.Spark04_SparkSQL_UDAF2$User)|</span></span><br><span class=\"line\"><span class=\"comment\">//+---------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"comment\">//|                                                             30|</span></span><br><span class=\"line\"><span class=\"comment\">//+---------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据的加载和保存\"><a href=\"#数据的加载和保存\" class=\"headerlink\" title=\"数据的加载和保存\"></a><strong>数据的加载和保存</strong></h3><h4 id=\"通用的加载和保存方式\"><a href=\"#通用的加载和保存方式\" class=\"headerlink\" title=\"通用的加载和保存方式\"></a><strong>通用的加载和保存方式</strong></h4><p>SparkSQL 提供了通用的保存数据和数据加载的方式。这里的通用指的是使用相同的API，根据不同的参数读取和保存不同格式的数据，SparkSQL 默认读取和保存的文件格式为 <strong>parquet</strong></p>\n<p><strong>加载数据</strong></p>\n<p><font color=\"red\">spark.read.load</font> 是加载数据的通用方法</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; spark.read.</span><br><span class=\"line\">csv  table\tformat\ttext\tjdbc\tjson\ttextFile\tload\toption\toptions\torc\tparquet\tschema</span><br><span class=\"line\">table\ttext\ttextFile</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> df=spark.read.format(<span class=\"string\">&quot;json&quot;</span>).load(<span class=\"string\">&quot;input/user.json&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//     val df=spark.read.json(&quot;input/json&quot;)</span></span><br><span class=\"line\">df: org.apache.spark.sql.<span class=\"type\">DataFrame</span> = [age: bigint, username: string]</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; df.show</span><br><span class=\"line\">+---+--------+</span><br><span class=\"line\">|age|username|</span><br><span class=\"line\">+---+--------+</span><br><span class=\"line\">| <span class=\"number\">30</span>|zhangsan|</span><br><span class=\"line\">| <span class=\"number\">20</span>|zhangsan|</span><br><span class=\"line\">| <span class=\"number\">40</span>|zhangsan|</span><br><span class=\"line\">+---+--------+</span><br><span class=\"line\"><span class=\"comment\">//使用DSL语法不用创建表，SQL要创建表</span></span><br><span class=\"line\"><span class=\"comment\">//scala&gt;spark.sql(&quot;select * from json.`/opt/module/data/user.json`&quot;).show</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//默认保存Parquet文件</span></span><br><span class=\"line\">scala&gt; df.write.save(<span class=\"string\">&quot;output1&quot;</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定保存json文件</span></span><br><span class=\"line\">scala&gt; df.writeformat(<span class=\"string\">&quot;json&quot;</span>).save(<span class=\"string\">&quot;output1&quot;</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果文件已经存在则追加</span></span><br><span class=\"line\">scala&gt; df.write.format(<span class=\"string\">&quot;json&quot;</span>).mode(<span class=\"string\">&quot;append&quot;</span>).save(<span class=\"string\">&quot;output&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果文件已经存在则覆盖</span></span><br><span class=\"line\">scala&gt; df.write.format(<span class=\"string\">&quot;json&quot;</span>).mode(<span class=\"string\">&quot;overwrite&quot;</span>).save(<span class=\"string\">&quot;output&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果文件已经存在则忽略</span></span><br><span class=\"line\">scala&gt; df.write.format(<span class=\"string\">&quot;json&quot;</span>).mode(<span class=\"string\">&quot;ignore&quot;</span>).save(<span class=\"string\">&quot;output&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Parquet\"><a href=\"#Parquet\" class=\"headerlink\" title=\"Parquet\"></a>Parquet</h4><p>Spark SQL 的默认数据源为 <font color=\"red\">Parquet 格式</font>。Parquet 是一种能够有效存储嵌套数据的列式存储格式。</p>\n<p>数据源为 Parquet 文件时，Spark SQL 可以方便的执行所有的操作，不需要使用 format。修改配置项<font color=\"red\">spark.sql.sources.default</font>，可修改默认数据源格式。</p>\n<h4 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h4><p>Spark SQL 能够自动推测 JSON 数据集的结构，并将它加载为一个Dataset[Row]. 可以通过 SparkSession.read.json()去加载 JSON 文件。</p>\n<p><font color=\"red\">注意：Spark 读取的 JSON 文件不是传统的JSON 文件，每一行都应该是一个 JSON 串</font></p>\n<p>格式如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Michael&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Andy&quot;</span>， <span class=\"attr\">&quot;age&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">30</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">[</span><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Justin&quot;</span>， <span class=\"attr\">&quot;age&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">19</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Justin&quot;</span>， <span class=\"attr\">&quot;age&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">19</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CSV\"><a href=\"#CSV\" class=\"headerlink\" title=\"CSV\"></a><strong>CSV</strong></h4><p>Spark SQL 可以配置 CSV 文件的列表信息，读取CSV 文件,CSV 文件的第一行设置为数据列</p>\n<p>spark-3.0.0-bin-hadoop3.2\\examples\\src\\main\\resources\\people.csv</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">var</span>                    df=spark.read.format(<span class=\"string\">&quot;csv&quot;</span>).option(<span class=\"string\">&quot;sep&quot;</span>,<span class=\"string\">&quot;;&quot;</span>).option(<span class=\"string\">&quot;inferSchema&quot;</span>,<span class=\"string\">&quot;true&quot;</span>).option(<span class=\"string\">&quot;header&quot;</span>,<span class=\"string\">&quot;true&quot;</span>).load(<span class=\"string\">&quot;../examples/src/main/resources/people.csv&quot;</span>)</span><br><span class=\"line\">scala&gt; df.show</span><br><span class=\"line\">+-----+---+---------+</span><br><span class=\"line\">| name|age|      job|</span><br><span class=\"line\">+-----+---+---------+</span><br><span class=\"line\">|<span class=\"type\">Jorge</span>| <span class=\"number\">30</span>|<span class=\"type\">Developer</span>|</span><br><span class=\"line\">|  <span class=\"type\">Bob</span>| <span class=\"number\">32</span>|<span class=\"type\">Developer</span>|</span><br><span class=\"line\">+-----+---+---------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a><strong>MySQL</strong></h4><p>Spark SQL 可以通过 JDBC 从关系型数据库中读取数据的方式创建DataFrame，通过对DataFrame 一系列的计算后，还可以将数据再写回关系型数据库中。如果使用 spark-shell 操作，可在启动shell 时指定相关的数据库驱动路径或者将相关的数据库驱动放到 spark 的类路径下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bin/spark-shell</span><br><span class=\"line\">--jars mysql-connector-java-5.1.27-bin.jar</span><br></pre></td></tr></table></figure>\n\n<p>我们这里只演示在Idea 中通过 JDBC 对 Mysql 进行操作</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>8.0.25<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--按照本机对应mysql版本进行设置--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TODO 创建SparkSQL的运行环境</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> sparkConf=<span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setMaster(<span class=\"string\">&quot;local[*]&quot;</span>) .setAppName(<span class=\"string\">&quot;SparkSQL&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> spark=<span class=\"type\">SparkSession</span>.builder().config(sparkConf).getOrCreate()</span><br><span class=\"line\"><span class=\"keyword\">import</span> spark.implicits._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取Mysql数据</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> df=spark.read</span><br><span class=\"line\">  .format(<span class=\"string\">&quot;jdbc&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;url&quot;</span>, <span class=\"string\">&quot;jdbc:mysql://localhost:3306/spark-sql&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;driver&quot;</span>, <span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;dbtable&quot;</span>, <span class=\"string\">&quot;user&quot;</span>)</span><br><span class=\"line\">  .load()</span><br><span class=\"line\"><span class=\"comment\">//df.show()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 保存数据</span></span><br><span class=\"line\">df.write</span><br><span class=\"line\">  .format(<span class=\"string\">&quot;jdbc&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;url&quot;</span>, <span class=\"string\">&quot;jdbc:mysql://localhost:3306/spark-sql&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;driver&quot;</span>, <span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>)</span><br><span class=\"line\">  .option(<span class=\"string\">&quot;dbtable&quot;</span>, <span class=\"string\">&quot;user1&quot;</span>)   <span class=\"comment\">//保存user1表</span></span><br><span class=\"line\">  .mode(<span class=\"type\">SaveMode</span>.<span class=\"type\">Append</span>)  <span class=\"comment\">//涉及到出错问题</span></span><br><span class=\"line\">  .save()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TODO 关闭环境</span></span><br><span class=\"line\">spark.stop()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h4><p>​        Apache Hive 是 Hadoop 上的 SQL 引擎，Spark SQL 编译时可以包含 Hive 支持，也可以不包含。包含 Hive 支持的 Spark SQL 可以支持 Hive 表访问、UDF (用户自定义函数)以及 Hive 查询语言(HiveQL&#x2F;HQL)等。需要强调的一点是，如果要在 Spark SQL 中包含Hive 的库，并不需要事先安装 Hive。一般来说，最好还是在编译 Spark SQL 时引入 Hive 支持，这样就可以使用这些特性了。如果你下载的是二进制版本的 Spark，它应该已经在编译时添加了 Hive 支持。</p>\n<p>​       若要把 Spark SQL 连接到一个部署好的 Hive 上，你必须把 hive-site.xml 复制到Spark 的配置文件目录中($SPARK_HOME&#x2F;conf)。即使没有部署好 Hive，Spark SQL 也可以运行。 需要注意的是，如果你没有部署好 Hive，Spark SQL 会在当前的工作目录中创建出自己的 Hive 元数据仓库，叫作 metastore_db。此外，如果你尝试使用 HiveQL 中的CREATE TABLE (并非 CREATE EXTERNAL TABLE)语句来创建表，这些表会被放在你默认的文件系统中的 &#x2F;user&#x2F;hive&#x2F;warehouse 目录中(如果你的 classpath 中有配好的hdfs-site.xml，默认的文件系统就是 HDFS，否则就是本地文件系统)。</p>\n<p>spark-shell 默认是Hive 支持的；代码中是默认不支持的，需要手动指定（加一个参数即可）。</p>\n<h5 id=\"外部的Hive\"><a href=\"#外部的Hive\" class=\"headerlink\" title=\"外部的Hive\"></a>外部的Hive</h5><p>如果想连接外部已经部署好的Hive，需要通过以下几个步骤：</p>\n<ul>\n<li><p>Spark 要接管 Hive 需要把hive-site.xml 拷贝到conf&#x2F;目录下</p>\n</li>\n<li><p>把 Mysql 的驱动 copy 到 jars&#x2F;目录下</p>\n</li>\n<li><p>如果访问不到 hdfs，则需要把 core-site.xml 和 hdfs-site.xml 拷贝到 conf&#x2F;目录下</p>\n</li>\n<li><p>重启 spark-shell</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; spark.sql(<span class=\"string\">&quot;show tables&quot;</span>).show</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"IDEA代码操作Hive\"><a href=\"#IDEA代码操作Hive\" class=\"headerlink\" title=\"IDEA代码操作Hive\"></a>IDEA代码操作Hive</h5><p><a href=\"https://blog.csdn.net/weixin_36040866/article/details/124567017?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=IDEA%20spark%E8%BF%9E%E6%8E%A5hive&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124567017.142\">https://blog.csdn.net/weixin_36040866/article/details/124567017?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=IDEA%20spark%E8%BF%9E%E6%8E%A5hive&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124567017.142</a></p>\n","categories":["Spark"],"tags":["Spark"]},{"title":"ZooKeeper基础","url":"/2022/07/11/zookeeper-ji-chu/","content":"","categories":["ZooKeeper"],"tags":["ZooKeeper"]},{"title":"equals的若干问题解答","url":"/2022/04/21/equals-de-ruo-gan-wen-ti-jie-da/","content":"<p>详细解答：<a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\">Java hashCode() 和 equals()的若干问题解答</a></p>\n<h1 id=\"引用于：javaGuide-做的笔记\"><a href=\"#引用于：javaGuide-做的笔记\" class=\"headerlink\" title=\"引用于：javaGuide 做的笔记\"></a>引用于：javaGuide 做的笔记</h1><h2 id=\"String-equals-和-Object-equals-有何区别？\"><a href=\"#String-equals-和-Object-equals-有何区别？\" class=\"headerlink\" title=\"String#equals() 和 Object#equals() 有何区别？\"></a>String#equals() 和 Object#equals() 有何区别？</h2><ol>\n<li>操作少量的数据: 适用 String</li>\n<li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li>\n<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>\n</ol>\n<p>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。</p>\n<h2 id=\"String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？\"><a href=\"#String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？\" class=\"headerlink\" title=\"String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？\"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h2><p>会创建 1 或 2 个字符串：</p>\n<ul>\n<li>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。</li>\n<li>如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</li>\n</ul>\n<p>验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);<span class=\"comment\">// 堆内存的地址值</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">System.out.println(s1 == s2);<span class=\"comment\">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class=\"line\">System.out.println(s1.equals(s2));<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"String-类型的变量和常量做“-”运算时发生了什么？\"><a href=\"#String-类型的变量和常量做“-”运算时发生了什么？\" class=\"headerlink\" title=\"String 类型的变量和常量做“+”运算时发生了什么？\"></a>String 类型的变量和常量做“+”运算时发生了什么？</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;str&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ing&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str3</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;str&quot;</span> + <span class=\"string\">&quot;ing&quot;</span>;<span class=\"comment\">//常量池中的对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str4</span> <span class=\"operator\">=</span> str1 + str2; <span class=\"comment\">//在堆上创建的新的对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str5</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;string&quot;</span>;<span class=\"comment\">//常量池中的对象</span></span><br><span class=\"line\">System.out.println(str3 == str4);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str3 == str5);<span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(str4 == str5);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/04/21/equals-de-ruo-gan-wen-ti-jie-da/1.jpg\" alt=\"1\"><br>注意 ：比较 String 字符串的值是否相等，可以使用 equals() 方法。 String 中的 equals 方法是被重写过的。 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是字符串的值是否相等。如果你使用 &#x3D;&#x3D; 比较两个字符串是否相等的话，IDEA 还是提示你使用 equals() 方法替换。</p>\n<blockquote>\n<p>对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于引用数据类型来说，&#x3D;&#x3D;比较的是对象的内存地址。</p>\n</blockquote>\n<p> 对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。</p>\n<p> <code>字符串常量池</code> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">String</span> <span class=\"variable\">aa</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>; <span class=\"comment\">// 放在常量池中</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">bb</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>; <span class=\"comment\">// 从常量池中查找</span></span><br><span class=\"line\">System.out.println(aa==bb);<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n","categories":["Java"],"tags":["equals的若干问题解答"]},{"title":"java常用类","url":"/2022/05/31/java-chang-yong-lei/","content":"<h1 id=\"String的特性\"><a href=\"#String的特性\" class=\"headerlink\" title=\"String的特性\"></a><center>String的特性</center></h1><ul>\n<li><font color=\"red\">String类：代表字符串。</font>Java 程序中的所有字符串字面值（如 “abc” ）都作 为此类的实例实现。</li>\n<li>String是一个final类，代表<font color=\"red\">不可变的字符序列</font>。</li>\n<li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。</li>\n<li>String对象的字符内容是存储在一个字符数组value[]中的。</li>\n</ul>\n<p><strong>源代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">String</span></span><br><span class=\"line\"><span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\"><span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span> value[];</span><br><span class=\"line\"><span class=\"comment\">/** Cache the hash code for the string */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> hash; <span class=\"comment\">// Default to 0</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"理解String的不可变性\"><a href=\"#理解String的不可变性\" class=\"headerlink\" title=\"理解String的不可变性\"></a>理解String的不可变性</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.testng.annotations.Test;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/5/31</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//String的使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StringTest</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    String:字符串，使用一对“”引起来表示</span></span><br><span class=\"line\"><span class=\"comment\">    1.String 声明为final的，不可被继承</span></span><br><span class=\"line\"><span class=\"comment\">    2.String 实现了Serializable接口：表示字符串是支持序列化的</span></span><br><span class=\"line\"><span class=\"comment\">        实现了Comparable接口：表示String可以比较大小</span></span><br><span class=\"line\"><span class=\"comment\">    3.String：内部定义了final chat[] value用于存储字符串数据的</span></span><br><span class=\"line\"><span class=\"comment\">    4.String: 代表不可变的字符串序列。简称：不可变性</span></span><br><span class=\"line\"><span class=\"comment\">    通过字面量的方式（区别于new）,给一个字符串赋值，此时字符串值声明在字符串常量池中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        String s1=<span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        String s2=<span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(s1==s2);   <span class=\"comment\">//比较s1和s2的地址值</span></span><br><span class=\"line\">        <span class=\"comment\">//结果为：true 常量池不会存储相同内容的字符串,所以s1和s2的地址都是相同的</span></span><br><span class=\"line\"></span><br><span class=\"line\">        s1=<span class=\"string\">&quot;hello&quot;</span>;   <span class=\"comment\">//1. 当对字符串重新赋值时，需要重写指定内存区域赋值</span></span><br><span class=\"line\">        <span class=\"comment\">//不能使用原有的value进行赋值（重新开辟赋值地址，存储hello，地址也变了）</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        String s3=<span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        s3+=<span class=\"string\">&quot;def&quot;</span>;</span><br><span class=\"line\">        System.out.println(s3);</span><br><span class=\"line\">        <span class=\"comment\">//2. 对现有的字符串进行连接操作时，也需要重新指定内存区域赋值</span></span><br><span class=\"line\">        <span class=\"comment\">//不能使用原有的value进行赋值（也就是进行拼接操作，也会重新开辟内存地址）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String s4=<span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        String s5=s4.replace(<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;m&quot;</span>); </span><br><span class=\"line\">        <span class=\"comment\">//将下标为0的字符替换改变 重新开辟一个新地址存储</span></span><br><span class=\"line\">        <span class=\"comment\">//3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域</span></span><br><span class=\"line\">        System.out.println(s4==s5);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"String的不同实例方式对比\"><a href=\"#String的不同实例方式对比\" class=\"headerlink\" title=\"String的不同实例方式对比\"></a>String的不同实例方式对比</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">String的实例方式</span><br><span class=\"line\">方式一：通过字面量定义的方式</span><br><span class=\"line\">方式二：通过new + 构造器的方式</span><br><span class=\"line\"></span><br><span class=\"line\">面试题： String s = new String(&quot;abc&quot;); 方式创建对象，在内存中创建了几个对象？</span><br><span class=\"line\">两个： 一个是堆空间中的new结构，另一个是char[]对应的常量池中的数据：“abc”</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过字面量定义的方式，此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中</span></span><br><span class=\"line\">       String s1=<span class=\"string\">&quot;javaEE&quot;</span>;</span><br><span class=\"line\">       String s2=<span class=\"string\">&quot;javaEE&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//通过new + 构造器的方式：此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值</span></span><br><span class=\"line\">       String s3= <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;javaEE&quot;</span>);</span><br><span class=\"line\">       String s4= <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;javaEE&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(s1 == s2);  <span class=\"comment\">//true</span></span><br><span class=\"line\">        System.out.println(s1 == s3);  <span class=\"comment\">//false</span></span><br><span class=\"line\">        System.out.println(s1 == s4);  <span class=\"comment\">//false</span></span><br><span class=\"line\">        System.out.println(s3 == s4);  <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*****************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Tom&quot;</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Tom&quot;</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(p1.name.equals(p2.name));  <span class=\"comment\">//true</span></span><br><span class=\"line\">        System.out.println(p1.name==p2.name);       <span class=\"comment\">//true</span></span><br><span class=\"line\">        <span class=\"comment\">//true   比较的是String数组的地址直，常量池中只有一个  Tom在常量池里面</span></span><br><span class=\"line\">        <span class=\"comment\">// 他们都指向常量池的“tom&quot; 而常量池里面只有一个tom</span></span><br><span class=\"line\"></span><br><span class=\"line\">        p1.name=<span class=\"string\">&quot;Jerry&quot;</span>;</span><br><span class=\"line\">        System.out.println(p2.name);   <span class=\"comment\">//Tom</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name, <span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"String不同拼接操作的对比\"><a href=\"#String不同拼接操作的对比\" class=\"headerlink\" title=\"String不同拼接操作的对比\"></a>String不同拼接操作的对比</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    结论：</span></span><br><span class=\"line\"><span class=\"comment\">    1.常量与常量的拼接结果在常量池。且常量池中不会存在相同的常量</span></span><br><span class=\"line\"><span class=\"comment\">    2.只要其中有一个是变量，结果就在堆中</span></span><br><span class=\"line\"><span class=\"comment\">    3.如果拼接的结果调用intern()方法，返回值就在常量池中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/1</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String s1=<span class=\"string\">&quot;javaEE&quot;</span>;</span><br><span class=\"line\">        String s2=<span class=\"string\">&quot;hadoop&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s3=<span class=\"string\">&quot;javaEEhadoop&quot;</span>;</span><br><span class=\"line\">        String s4=<span class=\"string\">&quot;jvaEE&quot;</span>+<span class=\"string\">&quot;hadoop&quot;</span>;</span><br><span class=\"line\">        String s5=s1+<span class=\"string\">&quot;hadoop&quot;</span>;</span><br><span class=\"line\">        String s6=<span class=\"string\">&quot;javaEE&quot;</span>+s2;</span><br><span class=\"line\">        String s7=s1+s2;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(s3 == s4);   <span class=\"comment\">//true</span></span><br><span class=\"line\">        System.out.println(s3 == s5);   <span class=\"comment\">//false</span></span><br><span class=\"line\">        System.out.println(s3 == s6);   <span class=\"comment\">//false</span></span><br><span class=\"line\">        System.out.println(s3 == s7);   <span class=\"comment\">//false</span></span><br><span class=\"line\">        System.out.println(s5 == s6);   <span class=\"comment\">//false</span></span><br><span class=\"line\">        System.out.println(s5 == s7);   <span class=\"comment\">//false</span></span><br><span class=\"line\">        System.out.println(s6 == s7);   <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String s8=s6.intern();          <span class=\"comment\">//返回值得到的s8使用的常量值中已经存在的&quot;javaEEhadoop&quot;</span></span><br><span class=\"line\">        System.out.println(s3 == s8);   <span class=\"comment\">//true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"String常用的方法1\"><a href=\"#String常用的方法1\" class=\"headerlink\" title=\"String常用的方法1\"></a>String常用的方法1</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">length</span><span class=\"params\">()</span>:返回字符串的长度： <span class=\"keyword\">return</span> value.length</span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"title function_\">charAt</span><span class=\"params\">(<span class=\"type\">int</span> index)</span>：返回某索引处的字符<span class=\"keyword\">return</span> value[index]</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isEmpty</span><span class=\"params\">()</span>：判断是否是空字符串：<span class=\"keyword\">return</span> value.length == <span class=\"number\">0</span></span><br><span class=\"line\">String <span class=\"title function_\">toLowerCase</span><span class=\"params\">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span><br><span class=\"line\">String <span class=\"title function_\">toUpperCase</span><span class=\"params\">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span><br><span class=\"line\">String <span class=\"title function_\">trim</span><span class=\"params\">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span>：比较字符串的内容是否相同</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">equalsIgnoreCase</span><span class=\"params\">(String anotherString)</span>：与equals方法类似，忽略大小写</span><br><span class=\"line\">String <span class=\"title function_\">concat</span><span class=\"params\">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">compareTo</span><span class=\"params\">(String anotherString)</span>：比较两个字符串的大小</span><br><span class=\"line\">String <span class=\"title function_\">substring</span><span class=\"params\">(<span class=\"type\">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从 beginIndex开始截取到最后的一个子字符串。</span><br><span class=\"line\">String <span class=\"title function_\">substring</span><span class=\"params\">(<span class=\"type\">int</span> beginIndex, <span class=\"type\">int</span> endIndex)</span>：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">       String s1=<span class=\"string\">&quot;HelloWorld&quot;</span>;</span><br><span class=\"line\">       String s2=<span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\">       System.out.println(s1.equals(s2));   <span class=\"comment\">//对比字符串内容是否相同</span></span><br><span class=\"line\">       System.out.println(s1.equalsIgnoreCase(s2));  <span class=\"comment\">//忽略大小写</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String s3=<span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        String s4=s3.concat(<span class=\"string\">&quot;def&quot;</span>);   <span class=\"comment\">//相当于拼接 把字符串添加到结尾</span></span><br><span class=\"line\">        System.out.println(s4);</span><br><span class=\"line\"></span><br><span class=\"line\">        String s5=<span class=\"string\">&quot;abc&quot;</span>;   <span class=\"comment\">//一个字符对比</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s6</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abe&quot;</span>);  <span class=\"comment\">// c-e  99-101 =-1   Ascii码</span></span><br><span class=\"line\">        System.out.println(s5.compareTo(s6));</span><br><span class=\"line\"></span><br><span class=\"line\">        String s7=<span class=\"string\">&quot;为什么束手无策啊&quot;</span>;</span><br><span class=\"line\">        String s8=s7.substring(<span class=\"number\">2</span>); <span class=\"comment\">//数组下标2到末尾的字符串</span></span><br><span class=\"line\">        System.out.println(s7);</span><br><span class=\"line\">        System.out.println(s8);</span><br><span class=\"line\"></span><br><span class=\"line\">        String s9=s7.substring(<span class=\"number\">3</span>,<span class=\"number\">7</span>); <span class=\"comment\">//数组下标2到下标5</span></span><br><span class=\"line\">        System.out.println(s9);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"String常用的方法2\"><a href=\"#String常用的方法2\" class=\"headerlink\" title=\"String常用的方法2\"></a>String常用的方法2</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">endsWith</span><span class=\"params\">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">startsWith</span><span class=\"params\">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">startsWith</span><span class=\"params\">(String prefix, <span class=\"type\">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">contains</span><span class=\"params\">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class=\"type\">char</span> 值序列时，返回 <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">indexOf</span><span class=\"params\">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">indexOf</span><span class=\"params\">(String str, <span class=\"type\">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">lastIndexOf</span><span class=\"params\">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">lastIndexOf</span><span class=\"params\">(String str, <span class=\"type\">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span><br><span class=\"line\">注：indexOf和lastIndexOf方法如果未找到都是返回-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">       String str1=<span class=\"string\">&quot;hellowworld&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">boolean</span> <span class=\"variable\">b1</span> <span class=\"operator\">=</span>str1.endsWith(<span class=\"string\">&quot;rld&quot;</span>);  <span class=\"comment\">//测试此字符串是否按指定的后缀结束</span></span><br><span class=\"line\">       System.out.println(b1);            <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">boolean</span> b2=str1.startsWith(<span class=\"string\">&quot;He&quot;</span>);  <span class=\"comment\">//测试此字符串 是否按指定的前缀开始</span></span><br><span class=\"line\">       System.out.println(b2);            <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">boolean</span> b3=str1.startsWith(<span class=\"string\">&quot;ll&quot;</span>,<span class=\"number\">2</span>);  <span class=\"comment\">//根据指定索引  是否按照指定的前缀开始</span></span><br><span class=\"line\">       System.out.println(b3);                           <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">       String str2=<span class=\"string\">&quot;wor&quot;</span>;                          <span class=\"comment\">//是否包含含指定的 char 值序列</span></span><br><span class=\"line\">       System.out.println(str1.contains(str2));    <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(str1.indexOf(<span class=\"string\">&quot;zw&quot;</span>));    <span class=\"comment\">//返回  第一次出现位置的下标 如果未找到就是 -1</span></span><br><span class=\"line\">                                                 <span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(str1.indexOf(<span class=\"string\">&quot;or&quot;</span>,<span class=\"number\">5</span>)); <span class=\"comment\">//返回 从指定的索引开始  判断</span></span><br><span class=\"line\">                                                               <span class=\"comment\">// 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">       String str3=<span class=\"string\">&quot;hellorworld&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(str3.lastIndexOf(<span class=\"string\">&quot;or&quot;</span>));  <span class=\"comment\">//返回 开始反向搜索 第一次出现位置的下标</span></span><br><span class=\"line\">                                                        <span class=\"comment\">// 7</span></span><br><span class=\"line\">       System.out.println(str3.lastIndexOf(<span class=\"string\">&quot;or&quot;</span>,<span class=\"number\">6</span>)); <span class=\"comment\">//返回   指定的索引</span></span><br><span class=\"line\">                                                        <span class=\"comment\">// 4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"String常用的方法3\"><a href=\"#String常用的方法3\" class=\"headerlink\" title=\"String常用的方法3\"></a>String常用的方法3</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">char</span> oldChar, <span class=\"type\">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span><br><span class=\"line\">String <span class=\"title function_\">replace</span><span class=\"params\">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span><br><span class=\"line\">String <span class=\"title function_\">replaceAll</span><span class=\"params\">(String regex, String replacement)</span>：使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span><br><span class=\"line\">String <span class=\"title function_\">replaceFirst</span><span class=\"params\">(String regex, String replacement)</span>：使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">matches</span><span class=\"params\">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span><br><span class=\"line\">String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span><br><span class=\"line\">String[] split(String regex, <span class=\"type\">int</span> limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String str1=<span class=\"string\">&quot;宜春yichun宜春&quot;</span>;</span><br><span class=\"line\">        String str2=str1.replace(<span class=\"string\">&#x27;春&#x27;</span>,<span class=\"string\">&#x27;.&#x27;</span>);   <span class=\"comment\">//注意是单引号‘号</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(str2);    <span class=\"comment\">//宜.yichun宜.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String str3=str1.replace(<span class=\"string\">&quot;宜春&quot;</span>,<span class=\"string\">&quot;赣州&quot;</span>);  </span><br><span class=\"line\">        System.out.println(str3);       <span class=\"comment\">//赣州yichun赣州</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        String str=<span class=\"string\">&quot;12hello34world5java67mysql89&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">string</span> <span class=\"operator\">=</span>str.replaceAll(<span class=\"string\">&quot;\\\\d+&quot;</span>,<span class=\"string\">&quot;,&quot;</span>).replaceAll(<span class=\"string\">&quot;^,|,$&quot;</span>,<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//把字符串中的数字替换成 ， 如果结果中开头和结尾有 ， 的话就去掉</span></span><br><span class=\"line\">        System.out.println(string);    <span class=\"comment\">////hello,world,java,mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\">        str=<span class=\"string\">&quot;12345&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> matches=str.matches(<span class=\"string\">&quot;\\\\d+&quot;</span>);   <span class=\"comment\">//正则表达式</span></span><br><span class=\"line\">        System.out.println(matches);  <span class=\"comment\">//true</span></span><br><span class=\"line\">        <span class=\"comment\">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String tel=<span class=\"string\">&quot;0571-4534289&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> result=tel.matches(<span class=\"string\">&quot;0571-\\\\d&#123;7,8&#125;&quot;</span>);   <span class=\"comment\">//正则表达式</span></span><br><span class=\"line\">        System.out.println(result);   <span class=\"comment\">//true</span></span><br><span class=\"line\">        <span class=\"comment\">//判断这是否是一个杭州的固定电话</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;***********************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        str=<span class=\"string\">&quot;hello|world|java&quot;</span>;</span><br><span class=\"line\">        String[] strs=str.split(<span class=\"string\">&quot;\\\\|&quot;</span>);   <span class=\"comment\">//对 | 进行切片 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(strs[i]);   <span class=\"comment\">//hello  world  java</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        str2 =<span class=\"string\">&quot;hello.world.java&quot;</span>;</span><br><span class=\"line\">        String[] strs2=str2.split(<span class=\"string\">&quot;\\\\.&quot;</span>);  <span class=\"comment\">//对 , 进行切片</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; strs2.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(strs2[i]);  <span class=\"comment\">//hello  world  java</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"String与基本数据类型包装类的转换\"><a href=\"#String与基本数据类型包装类的转换\" class=\"headerlink\" title=\"String与基本数据类型包装类的转换\"></a>String与基本数据类型包装类的转换</h1><ul>\n<li><p><strong>字符串 -&gt; 基本数据类型、包装类</strong></p>\n<ul>\n<li>Integer包装类的**public static int <font color=\"red\">parseInt(String s)</font>**：可以将由“数字”字 符组成的字符串转换为整型。</li>\n<li>类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应 的类方法可以将由<font color=\"red\">“数字”字符</font>组成的字符串，转化为相应的基本数据类型。</li>\n</ul>\n</li>\n<li><p><strong>基本数据类型、包装类 -&gt;字符串</strong></p>\n<ul>\n<li>调用String类的**public String <font color=\"red\">valueOf(int n)</font>**可将int型转换为字符串</li>\n<li>相应的**valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double  d)、valueOf(boolean b)**可由参数的相应类型到字符串的转换</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    复习:</span></span><br><span class=\"line\"><span class=\"comment\">    String 与基本数据类型、包装类型之间的转换</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</span></span><br><span class=\"line\"><span class=\"comment\">    基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String str1=<span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// int num = (int)str1; //错误的</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span>Integer.parseInt(str1);    <span class=\"comment\">//String向 基本数据类型转换 要调用包装类</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String str2=String.valueOf(num);   <span class=\"comment\">//基本数据类型向 String转换使用String重载的valueOf方法</span></span><br><span class=\"line\">        String str3=num+<span class=\"string\">&quot;&quot;</span>;                <span class=\"comment\">//使用拼接也是可以的</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(str1==str3);   <span class=\"comment\">//堆内存  是不等于常量池的</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"String与char-之间的转换\"><a href=\"#String与char-之间的转换\" class=\"headerlink\" title=\"String与char[]之间的转换\"></a>String与char[]之间的转换</h1><ul>\n<li><p>字符数组 –&gt; 字符串</p>\n<ul>\n<li>String 类的构造器：<strong>String(char[]) 和 String(char[]，int offset，int length)</strong> 分别用字符数组中的全部字符和部分字符创建字符串对象。</li>\n</ul>\n</li>\n<li><p>字符串 –&gt; 字符数组</p>\n</li>\n<li><p>**public char[] toCharArray()**：将字符串中的全部字符存放在一个字符数组 中的方法。</p>\n</li>\n<li><p>**public void getChars(int srcBegin, int srcEnd, char[] dst,  int dstBegin)**：提供了将指定索引范围内的字符串存放到数组中的方法。</p>\n</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    String 与 char[]之间的转换</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    String --&gt; char[]: 调用String的toCharArray()</span></span><br><span class=\"line\"><span class=\"comment\">    char[] --&gt; String: 调用String的构造器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String str1=<span class=\"string\">&quot;abc123&quot;</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">char</span>[] charArray=str1.toCharArray();   <span class=\"comment\">//把String类型转换为 char数组类型</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(charArray[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span>[] arr =<span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[]&#123;<span class=\"string\">&#x27;h&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;l&#x27;</span>,<span class=\"string\">&#x27;l&#x27;</span>,<span class=\"string\">&#x27;o&#x27;</span>&#125;; </span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(arr);</span><br><span class=\"line\">        <span class=\"comment\">//利用构造器把 char数组类型 转换为String</span></span><br><span class=\"line\">        System.out.println(str2);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"String与byte-之间的转换\"><a href=\"#String与byte-之间的转换\" class=\"headerlink\" title=\"String与byte[]之间的转换\"></a>String与byte[]之间的转换</h1><ul>\n<li>字节数组 –&gt;字符串<ul>\n<li>**String(byte[])**：通过使用平台的默认字符集解码指定的 byte 数组，构 造一个新的 String。</li>\n<li><strong>String(byte[]，int offset，int length)</strong> ：用指定的字节数组的一部分， 即从数组起始位置offset开始取length个字节构造一个字符串对象。</li>\n</ul>\n</li>\n<li>字符串 –&gt; 字节数组</li>\n<li><strong>public byte[] getBytes()</strong> ：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li>\n<li><strong>public byte[] getBytes(String charsetName)</strong> ：使用指定的字符集将 此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    编码：String --&gt; byte[]:调用String的getBytes()</span></span><br><span class=\"line\"><span class=\"comment\">    解码：byte --&gt; String:调用String的构造器</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    编码： 字符串 --&gt; 字符 （看得懂 --&gt; 看不懂的二进制数据）</span></span><br><span class=\"line\"><span class=\"comment\">    解码：编码的逆过程，字节 --&gt;字符串 （看不懂的二进制数据 --&gt; 看得懂）</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    说明： 解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出选乱码。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> UnsupportedEncodingException &#123;</span><br><span class=\"line\">        String str1=<span class=\"string\">&quot;abc123中国&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes=str1.getBytes();   <span class=\"comment\">//使用默认的字符集，进行编码 Ascii UTF-8   字符串 -&gt;字节数组</span></span><br><span class=\"line\">        System.out.println(Arrays.toString(bytes));</span><br><span class=\"line\">        <span class=\"comment\">//[97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] gbks=str1.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);  <span class=\"comment\">//  字符串  字节数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 使用指定的字符集，进行编码 UTF-8 Ascii</span></span><br><span class=\"line\">        System.out.println(Arrays.toString(gbks));</span><br><span class=\"line\">        <span class=\"comment\">//[97, 98, 99, 49, 50, 51, -42, -48, -71, -6]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        String str2=<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(bytes,<span class=\"number\">0</span>,<span class=\"number\">12</span>);   <span class=\"comment\">//使用默认的字符集，进行解码。 第一个到数组长度之间的   字节数组 -&gt;字符串</span></span><br><span class=\"line\">        System.out.println(str2);</span><br><span class=\"line\">        <span class=\"comment\">//abc123中国</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        String str3=<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(gbks);    <span class=\"comment\">//默认解码方式  与gbk编码 不一样      字节数组 -&gt;字符串</span></span><br><span class=\"line\">        System.out.println(str3);        <span class=\"comment\">//乱码</span></span><br><span class=\"line\">        <span class=\"comment\">//abc123�й�</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str4</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(gbks,<span class=\"string\">&quot;gbk&quot;</span>);  <span class=\"comment\">//如果是 gbk 默认编码方式 指定的字符集将此 String 编码</span></span><br><span class=\"line\">        System.out.println(str4);</span><br><span class=\"line\">        <span class=\"comment\">//abc123中国</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"解决一个拼接问题\"><a href=\"#解决一个拼接问题\" class=\"headerlink\" title=\"解决一个拼接问题\"></a>解决一个拼接问题</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/4</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: PACKAGE_NAME</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    结论：</span></span><br><span class=\"line\"><span class=\"comment\">    1. 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量</span></span><br><span class=\"line\"><span class=\"comment\">    2. 只要其中有一个是变量，结果就在常量池中</span></span><br><span class=\"line\"><span class=\"comment\">    3. 如果拼接的结果调用intern()方法，返回值就在常量池中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String s1=<span class=\"string\">&quot;javaEEhadoop&quot;</span>;</span><br><span class=\"line\">        String s2=<span class=\"string\">&quot;javaEE&quot;</span>;</span><br><span class=\"line\">        String s3=s2+<span class=\"string\">&quot;hadoop&quot;</span>;        <span class=\"comment\">//变成堆内存了</span></span><br><span class=\"line\">        System.out.println(s1==s3);   <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">s4</span> <span class=\"operator\">=</span><span class=\"string\">&quot;javaEE&quot;</span>;   <span class=\"comment\">//常量  加了final就是在常量池中的了</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s5</span> <span class=\"operator\">=</span>s4+<span class=\"string\">&quot;hadoop&quot;</span>;</span><br><span class=\"line\">        System.out.println(s1==s5);   <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用了 final 被final修饰的是不可改变的变量 等于说是常量 在常量池当中</span></span><br><span class=\"line\">        <span class=\"comment\">//最后常量和常量比较那就是 true 了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"StringBuffer的源码分析\"><a href=\"#StringBuffer的源码分析\" class=\"headerlink\" title=\"StringBuffer的源码分析\"></a>StringBuffer的源码分析</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> syn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Auther</span>:kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: 2022/6/18</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: syn</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span>:1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StringBufferBuilderTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  String、StringBuffer、StringBuilder三者的异同？</span></span><br><span class=\"line\"><span class=\"comment\">  String:不可变的字符序列</span></span><br><span class=\"line\"><span class=\"comment\">  StringBuffer:可变的字符序列:线程安全的，效率低</span></span><br><span class=\"line\"><span class=\"comment\">  StringBuilder:可变的字符序列：jdk5.0新增的 线程不安全的，效率高,底层使用char[]存储</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  源码分析：</span></span><br><span class=\"line\"><span class=\"comment\">  String str = new String(); //char[] value = new char[0];</span></span><br><span class=\"line\"><span class=\"comment\">  String str1 = new String(&quot;abc&quot;); //char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  StringBuffer sb1 = new StringBuffer();  //char[] value = new char[16];  底层创建了长度是16的数组</span></span><br><span class=\"line\"><span class=\"comment\">  System.out.print;n(sb1.lenght());</span></span><br><span class=\"line\"><span class=\"comment\">  sb1.append(&#x27;a&#x27;); //value[0] = &#x27;a&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">  sb1.append(&#x27;b&#x27;); //value[1] = &#x27;b&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);  //char[] value = new char[&quot;abc&quot;.lenght()+16]   //底层</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  //问题1 System.out.println(sb2.lenght());</span></span><br><span class=\"line\"><span class=\"comment\">  //问题2.扩容问题：如果要添加的数据底层数组盛不下，那就需要扩容底层的数组</span></span><br><span class=\"line\"><span class=\"comment\">          默认情况下，扩容为原来容器的2倍+2，同时将原有的数组中的元素赋值到新的数组中</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          指导意义：开发中建议大家使用：StringBuffer(int cappcity) 或 StringBuilder(int cappcity)</span></span><br><span class=\"line\"><span class=\"comment\">          尽量不使用自动扩容</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">StringBuffer</span> <span class=\"variable\">sb1</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">    sb1.setCharAt(<span class=\"number\">0</span>,<span class=\"string\">&#x27;m&#x27;</span>);</span><br><span class=\"line\">    System.out.println(sb1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">StringBuffer</span> <span class=\"variable\">sb2</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">    System.out.println(sb2.length());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"StringBuffer的常用方法\"><a href=\"#StringBuffer的常用方法\" class=\"headerlink\" title=\"StringBuffer的常用方法\"></a>StringBuffer的常用方法</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">在字符串末尾添加各种类型：</span><br><span class=\"line\"><span class=\"keyword\">public</span> StringBuffer <span class=\"title function_\">append</span><span class=\"params\">(各种类型)</span></span><br><span class=\"line\">在某个位置添加各种类型：</span><br><span class=\"line\"><span class=\"keyword\">public</span> StringBuffer <span class=\"title function_\">insert</span><span class=\"params\">(<span class=\"type\">int</span> offset, 各种类型)</span></span><br><span class=\"line\">删除字符或某一段字符串：</span><br><span class=\"line\">deleteCharAt(<span class=\"type\">int</span> index) / <span class=\"keyword\">public</span> StringBuffer <span class=\"title function_\">delete</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span></span><br><span class=\"line\">包含的字符数：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">length</span><span class=\"params\">()</span></span><br><span class=\"line\">返回某位置的字符：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">char</span> <span class=\"title function_\">charAt</span><span class=\"params\">(<span class=\"type\">int</span> index)</span></span><br><span class=\"line\">得到一段字符：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getChars</span><span class=\"params\">(<span class=\"type\">int</span> srcBegin, <span class=\"type\">int</span> srcEnd, <span class=\"type\">char</span>[] dst, <span class=\"type\">int</span> dstBegin)</span></span><br><span class=\"line\">字符串倒转：</span><br><span class=\"line\"><span class=\"keyword\">public</span> StringBuffer <span class=\"title function_\">reverse</span><span class=\"params\">()</span></span><br><span class=\"line\">替换某个位置的字符：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setCharAt</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">char</span> ch)</span></span><br><span class=\"line\">转为字符串：</span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span></span><br><span class=\"line\">    </span><br><span class=\"line\">Sring 常用方法</span><br><span class=\"line\"><span class=\"number\">1</span> 返回某位置的字符：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">char</span> <span class=\"title function_\">charAt</span><span class=\"params\">(<span class=\"type\">int</span> index)</span></span><br><span class=\"line\"><span class=\"number\">2</span> 连接某个字符串，返回连接后的结果，效果和+类似：</span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">concat</span><span class=\"params\">(String str)</span></span><br><span class=\"line\"><span class=\"number\">3</span>判断字符串是否以某串结尾 /开头：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">endsWith</span><span class=\"params\">(String suffix)</span>/startsWith(String prefix)</span><br><span class=\"line\"><span class=\"number\">4</span> 字符串内容是否相等/不区分大小写情况下是否相等：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object anObject)</span>/equalsIgnoreCase(String anotherString)</span><br><span class=\"line\"><span class=\"number\">5</span>：替换字符：</span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">char</span> oldChar, <span class=\"type\">char</span> newChar)</span></span><br><span class=\"line\"><span class=\"number\">6</span> 截取某段：</span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">substring</span><span class=\"params\">(<span class=\"type\">int</span> beginIndex)</span>/substring(<span class=\"type\">int</span> beginIndex, <span class=\"type\">int</span> endIndex)</span><br><span class=\"line\"><span class=\"number\">7</span> 转为字符数组：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">char</span>[] toCharArray()</span><br><span class=\"line\"><span class=\"number\">8</span> <span class=\"keyword\">public</span> String <span class=\"title function_\">toLowerCase</span><span class=\"params\">()</span>/toUpperCase()</span><br><span class=\"line\"><span class=\"number\">9</span> 去掉两边空格：</span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">trim</span><span class=\"params\">()</span></span><br><span class=\"line\">————————————————</span><br><span class=\"line\">版权声明：本文为CSDN博主「Tamagoi」的原创文章，遵循CC <span class=\"number\">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class=\"line\">原文链接：https:<span class=\"comment\">//blog.csdn.net/qq_45682870/article/details/110490767</span></span><br></pre></td></tr></table></figure>\n\n","categories":["Java"],"tags":["java"]},{"title":"java异常","url":"/2022/05/11/java-yi-chang/","content":"<ul>\n<li><p>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常” 。 (开发过程中的语法错误和逻辑错误不是异常)</p>\n</li>\n<li><p>Java程序在执行过程中所发生的异常事件可分为两类：</p>\n<ol>\n<li><font color=\"red\">Error</font>：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源 耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性 的代码进行处理。</li>\n<li><font color=\"red\">Exception</font>: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使 用针对性的代码进行处理。例如：</li>\n</ol>\n<ul>\n<li>空指针访问</li>\n<li>数组角标越界</li>\n<li>试图读取不存在的文件</li>\n<li>网络连接中断</li>\n</ul>\n</li>\n<li><p>程序员通常只能处理Exception，而对Error无能为力</p>\n</li>\n<li><p>对于这些错误，一般有两种解决方法：一是遇到错误就终止程序 的运行。另一种方法是由程序员在编写程序时，就考虑到错误的 检测、错误消息的提示，以及错误的处理。</p>\n</li>\n<li><p>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。 比如：除数为0，数组下标越界等</p>\n<p>​         分类： <font color=\"red\">编译时异常</font>和 <font color=\"red\">运行时异常</font></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"运行时异常-unchecked，RuntimeException\"><a href=\"#运行时异常-unchecked，RuntimeException\" class=\"headerlink\" title=\"运行时异常(unchecked，RuntimeException):\"></a>运行时异常(unchecked，RuntimeException):</h1><p> <font color=\"red\">要编译过了，出现的错误才叫运行时异常！！！也就是骗过了编译器以下就是常用的运行时异常</font></p>\n<h1 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">main(args);</span><br><span class=\"line\"><span class=\"comment\">// java.lang.StackOverflowError</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>[<span class=\"number\">1024</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"comment\">// java.lang.OutOfMemoryError</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"空指针异常\"><a href=\"#空指针异常\" class=\"headerlink\" title=\"空指针异常\"></a>空指针异常</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">str =<span class=\"literal\">null</span>;</span><br><span class=\"line\">System.out.println(str.charAt(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组角标越界\"><a href=\"#数组角标越界\" class=\"headerlink\" title=\"数组角标越界\"></a>数组角标越界</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr =<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">System.out.println(arr[<span class=\"number\">10</span>]);</span><br><span class=\"line\"><span class=\"comment\">// java.lang.ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符串越界\"><a href=\"#字符串越界\" class=\"headerlink\" title=\"字符串越界\"></a>字符串越界</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">System.out.println(str.charAt(<span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">//java.lang.StringIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类型转换异常\"><a href=\"#类型转换异常\" class=\"headerlink\" title=\"类型转换异常\"></a>类型转换异常</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> (String)obj;</span><br><span class=\"line\"><span class=\"comment\">//java.lang.ClassCastException  本身是个Date,然后向上转型，也就是多态，接下来强转，转成String，从编译的角度语法是ok的，但是会出现类型转换异常</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数字格式异常\"><a href=\"#数字格式异常\" class=\"headerlink\" title=\"数字格式异常\"></a>数字格式异常</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span><span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">str=<span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> Integer.parseInt(str);</span><br><span class=\"line\"><span class=\"comment\">// java.lang.NumberFormatException</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"输入不匹配异常\"><a href=\"#输入不匹配异常\" class=\"headerlink\" title=\"输入不匹配异常\"></a>输入不匹配异常</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">score</span> <span class=\"operator\">=</span> scanner.nextInt();</span><br><span class=\"line\">System.out.println(score);</span><br><span class=\"line\"><span class=\"comment\">// java.util.InputMismatchException   这里输入除了整形数字以外，就会报出异常</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"算数异常\"><a href=\"#算数异常\" class=\"headerlink\" title=\"算数异常\"></a>算数异常</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a=<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> b=<span class=\"number\">0</span>;</span><br><span class=\"line\">System.out.println(a/b);</span><br><span class=\"line\"><span class=\"comment\">//java.lang.ArithmeticException  b为 0 时，运行时会得到无限大的数，这就叫算数的异常</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"编译时异常\"><a href=\"#编译时异常\" class=\"headerlink\" title=\"编译时异常\"></a>编译时异常</h1><h4 id=\"就是编译时出现的异常，直接报错了-也就是一般编译器IDE提示的异常比如：语法错误。\"><a href=\"#就是编译时出现的异常，直接报错了-也就是一般编译器IDE提示的异常比如：语法错误。\" class=\"headerlink\" title=\"就是编译时出现的异常，直接报错了,也就是一般编译器IDE提示的异常比如：语法错误。\"></a>就是编译时出现的异常，直接报错了,也就是一般编译器IDE提示的异常比如：语法错误。</h4><hr>\n<h1 id=\"异常处理机制一：-try-catch-finally\"><a href=\"#异常处理机制一：-try-catch-finally\" class=\"headerlink\" title=\"异常处理机制一： try-catch-finally\"></a>异常处理机制一： try-catch-finally</h1><p><code>ctrl+alt+T   快捷键</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">...... <span class=\"comment\">//可能产生异常的代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span>( ExceptionName1 e )&#123;</span><br><span class=\"line\">...... <span class=\"comment\">//当产生ExceptionName1型异常时的处置措施</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span>( ExceptionName2 e )&#123;</span><br><span class=\"line\">...... <span class=\"comment\">//当产生ExceptionName2型异常时的处置措施</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[ <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">...... <span class=\"comment\">//无论是否发生异常，都无条件执行的语句</span></span><br><span class=\"line\">&#125; ]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;hello.txt&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>try</strong></p>\n<p>捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现 异常的代码放在try语句块中。</p>\n</li>\n<li><p><strong>catch (Exceptiontype e)</strong></p>\n<p>在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随 一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>\n</li>\n<li><p><strong>finally</strong></p>\n<p>捕获异常的最后一步是通过finally语句为异常处理提供一个 统一的出口,使得在控制流转到程序的其它部分以前,能够对程序的状态作统一的管理。</p>\n<p> <font color=\"red\">不论在try代码块中是否发生了异常事件，catch语句是否执 行，catch语句是否有异常，catch语句中是否有return， finally块中的语句都会被执行。</font></p>\n<p>finally语句和catch语句是任选的</p>\n</li>\n</ul>\n<p><strong>当try语句中出现异常时</strong>，会执⾏catch中的语句，java运⾏时系统会⾃动将catch括号中的Exception e 初始化，也就是实例化Exception类型的对象。e是此名称。然后e（引⽤）会⾃动调⽤Exception类中指定的⽅法，也就出现了e.printStackTrace() <font color=\"red\">printStackTrace()⽅法的意思是：在命令⾏打印异常信息在程序中出错的位置及原因。（这是⽩话解释，⽐较容易理解)</font></p>\n<p><strong>在捕获异常的时候</strong>，⼤家都可能要⽤到这样的⼀条语句：e.printStackTrace();e是Throwable的实例异常对象，⽤在catch语句中，相当于⼀个形参，⼀旦try捕获到了异常，那么就将这个异常信息交给e，由e处理，printStackTrace()是异常类的⼀个⽅法。与它重载的⽅法还有printStackTrace(PrintStream s) 和printStackTrace(PrintWriter s)。在Throwable类中,printStackTrace()内部是这样执⾏的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printStackTrace</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        printStackTrace(System.err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它调⽤了printStackTrace(PrintStream s)⽅法。err是System类当中的⼀个静态PrintStream类型字段。所以它能传递进去。</p>\n<h2 id=\"捕获异常的有关信息\"><a href=\"#捕获异常的有关信息\" class=\"headerlink\" title=\"捕获异常的有关信息\"></a>捕获异常的有关信息</h2><p>与其它对象一样，可以访问一个异常对象的成员变量或调用它的 方法。</p>\n<ul>\n<li><font color=\"red\">getMessage()</font>   获取异常信息，返回字符串</li>\n<li><font color=\"red\">printStackTrace()</font> 获取异常类名和异常信息，以及异常出 现在程序中的位置。返回值void。</li>\n</ul>\n<h2 id=\"异常处理机制-举例-1\"><a href=\"#异常处理机制-举例-1\" class=\"headerlink\" title=\"异常处理机制:举例(1)\"></a>异常处理机制:举例(1)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IndexOutExp</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">String friends[] = &#123; <span class=\"string\">&quot;lisa&quot;</span>, <span class=\"string\">&quot;bily&quot;</span>, <span class=\"string\">&quot;kessy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">System.out.println(friends[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;index err&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;\\nthis is the end&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">程序IndexOutExp.java运行结果：java IndexOutExp</span><br><span class=\"line\">lisa</span><br><span class=\"line\">bily</span><br><span class=\"line\">kessy</span><br><span class=\"line\">index err</span><br><span class=\"line\">this is the en</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异常处理机制-举例-2\"><a href=\"#异常处理机制-举例-2\" class=\"headerlink\" title=\"异常处理机制:举例(2)\"></a>异常处理机制:举例(2)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;    <span class=\"comment\">//默认为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> y;</span><br><span class=\"line\">        <span class=\"type\">test</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">test</span>();     <span class=\"comment\">//这个是自己本类，具体的类名</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            y = <span class=\"number\">3</span> / c.x;      <span class=\"comment\">//调用x</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;     <span class=\"comment\">//算数异常错误</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;test by zero error!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;program ends ok!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">程序DivideZero1运行结果：java DivideZero1</span><br><span class=\"line\">divide by zero error!</span><br><span class=\"line\">program ends ok!</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异常处理机制-IO-Exception\"><a href=\"#异常处理机制-IO-Exception\" class=\"headerlink\" title=\"异常处理机制 IO Exception\"></a>异常处理机制 IO Exception</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            File file=<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;E:/JDBC/src/zw.txt&quot;</span>);   <span class=\"comment\">//实际文件路径</span></span><br><span class=\"line\">            <span class=\"type\">FileInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(file);</span><br><span class=\"line\">            <span class=\"type\">int</span> b;</span><br><span class=\"line\">            b = in.read();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (b != -<span class=\"number\">1</span>) &#123;      <span class=\"comment\">//到了末尾就不读了</span></span><br><span class=\"line\">                System.out.print((<span class=\"type\">char</span>) b);</span><br><span class=\"line\">                b = in.read();   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;It&#x27;s ok!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>小知识</strong>：<code>FileInputStream类的成员方法read()的功能是每次从相应的(本地为 ASCII码编码格式)文件中读取一个字节，并转换成0~255之间的int型整数返回， 到达文件末尾时则返回-1。</code></p>\n<h1 id=\"异常处理机制二：throws\"><a href=\"#异常处理机制二：throws\" class=\"headerlink\" title=\"异常处理机制二：throws\"></a>异常处理机制二：throws</h1><ul>\n<li><strong>声明抛出异常是Java中处理异常的第二种方式</strong><ol>\n<li>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这 种异常，则此方法应<font color=\"red\">显示地</font>声明抛出异常，表明该方法将不对这些异常进行处理， 而由该方法的<font color=\"red\">调用者</font>负责处理。</li>\n<li>在方法声明中用<font color=\"red\">throws</font>语句可以声明抛出异常的列表，throws后面的异常类型可 以是方法中产生的异常类型，也可以是它的父类。</li>\n</ol>\n</li>\n<li>声明抛出异常举例：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String file)</span> <span class=\"keyword\">throws</span> FileNotFoundException &#123;</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 读文件的操作可能产生FileNotFoundException类型的异常</span></span><br><span class=\"line\"><span class=\"type\">FileInputStream</span> <span class=\"variable\">fis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(file);</span><br><span class=\"line\">..……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"手动抛出异常-throw\"><a href=\"#手动抛出异常-throw\" class=\"headerlink\" title=\"手动抛出异常 throw\"></a>手动抛出异常 throw</h1><ul>\n<li><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并 抛出，也可根据需要使用人工创建并抛出。</p>\n<ol>\n<li><p>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运 行环境)。</p>\n<p><font color=\"red\">IOException e &#x3D; new IOException(); </font></p>\n<p><font color=\"red\">throw e;</font></p>\n</li>\n<li><p>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将 会产生语法错误：</p>\n<p><font color=\"red\">throw new String(“want to throw”);</font></p>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"总结-异常处理5个关键字\"><a href=\"#总结-异常处理5个关键字\" class=\"headerlink\" title=\"总结:异常处理5个关键字\"></a><center>总结:异常处理5个关键字</center></h1><p><img src=\"/2022/05/11/java-yi-chang/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%85%B3%E9%94%AE%E5%AD%97.png\"></p>\n<center>一首小悟结束异常处理</center>\n\n<p>世界上最遥远的<font color=\"red\">距离</font>，是我在if里你在else里，似乎一直相伴又永远分离；</p>\n<p>世界上最痴心的<font color=\"red\">等待</font>，是我当case你是switch，或许永远都选不上自己；</p>\n<p>世界上最真情的<font color=\"red\">相依</font>，是你在try我在catch。无论你发神马脾气，我都默 默承受，静静处理。到那时，再来期待我们的finally。</p>\n<p>注：</p>\n<p>部分笔记来源：尚硅谷</p>\n","categories":["Java"],"tags":["java"]},{"title":"mysql基础笔记","url":"/2022/04/24/mysql-ji-chu-bi-ji/","content":"<h1 id=\"MySQL数据库基础知识\"><a href=\"#MySQL数据库基础知识\" class=\"headerlink\" title=\"MySQL数据库基础知识\"></a>MySQL数据库基础知识</h1><ul>\n<li><p><strong>概念</strong><br>MySQL是一款开源、跨平台的关系型数据库管理系统(DBMS，Database Management System)。关系型数据库将数据存放在结构化的一个或多个表中，表之间相互关联，反应客观事物的本质联系。数据库管理系统提供对数据的安全性和完整性控制。</p>\n</li>\n<li><p><strong>表</strong><br>关系型数据库中，数据库表是一系列二维数组的集合，用来存储数据和操作数据的逻辑，由记录(行)和字段(列)组成。</p>\n</li>\n<li><p><strong>主键</strong><br>主键(Primary Key)又称主码，用于唯一的标识表中的每一条记录，可以由一列或多列组合。主键列上不能重复值，也不能为空(null)，用来做确定数据唯一性的标识。</p>\n</li>\n<li><p><strong>SQL语言</strong></p>\n<p>SQL(Structured Query Language)，结构化查询语言，用来对数据库进行增、删、改、查等操作的语言。主要包括以下四个部分：</p>\n<ol>\n<li>数据库定义语言(DDL);</li>\n<li>数据库操作语言(DML);</li>\n<li>数据库查询语言(DQL);</li>\n<li>数据控制语言(DCL);</li>\n</ol>\n</li>\n<li><p><strong>数据库访问接口</strong></p>\n<p>​    不同的程序设计语言会有不同的数据库访问接口，程序语言通过接口执行SQL语句，进行数据库管理，主要接口有以下几种：</p>\n<ol>\n<li><p>ODBC(Open Database Connectivity)，开放数据库互联，为访问不同的SQL数据库提供了公共接口，使用SQL作为访问数据库的标准，一个应用程序可以通过共同的一组代码访问不同的SQL数据库管理系统(DBMS)。Access、MySQL、Oracle数据库均可用ODBC API进行访问。</p>\n</li>\n<li><p>JDBC(Java Database Connectivity)，Java数据库连接，是Java连接数据库的标准方法，通过执行SQL语句的Java API，为多种关系型数据库提供统一访问，是一组用Java语言编写的类和接口。</p>\n</li>\n<li><p>ADO.NET(ADO：ActiveX Data Objects)，微软.NET框架下一组用于和数据源交互的面相对象的库。提供了对关系型数据、XML和应用程序数据的访问，允许和不同类型的数据库和数据库进行交互。</p>\n</li>\n<li><p>PDO(PHP Data Object)，为PHP访问数据库定义了一个轻量级、一致性的接口，提供一个数据访问的抽象层，这样无论使用什么数据库，都可以通过一致的函数执行查询和获取数据，为PHP5后加入的功能。</p>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h1 id=\"报错信息代码\"><a href=\"#报错信息代码\" class=\"headerlink\" title=\"报错信息代码\"></a>报错信息代码</h1><p>  1064 语法错误</p>\n<h2 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">CREATE</span> database zw;</span><br></pre></td></tr></table></figure>\n<h3 id=\"比较完善的写法，创建数据库，这个写法，就不会出现1007报错\"><a href=\"#比较完善的写法，创建数据库，这个写法，就不会出现1007报错\" class=\"headerlink\" title=\"比较完善的写法，创建数据库，这个写法，就不会出现1007报错\"></a>比较完善的写法，创建数据库，这个写法，就不会出现1007报错</h3><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">CREATE</span> DATABASE IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> ZW; </span><br><span class=\"line\">    <span class=\"comment\">-- create database if not exists zw;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最完善的写法，包含了数据库的字符集指定，让你的mysql能够支持utf-8编码，支持中文，且不敏感大小写\"><a href=\"#最完善的写法，包含了数据库的字符集指定，让你的mysql能够支持utf-8编码，支持中文，且不敏感大小写\" class=\"headerlink\" title=\"最完善的写法，包含了数据库的字符集指定，让你的mysql能够支持utf-8编码，支持中文，且不敏感大小写\"></a>最完善的写法，包含了数据库的字符集指定，让你的mysql能够支持utf-8编码，支持中文，且不敏感大小写</h3><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span>  <span class=\"keyword\">CREATE</span> DATABASE IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> ZW1 <span class=\"keyword\">DEFAULT</span> CHARSET UTF8 <span class=\"keyword\">COLLATE</span>  utf8_general_ci;</span><br><span class=\"line\"><span class=\"comment\">--     小写： create database if not exists zw1 default charset utf8 collate  uft8_general_ci;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"查看数据库\"><a href=\"#查看数据库\" class=\"headerlink\" title=\"查看数据库\"></a>查看数据库</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SHOW</span> databases;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">DROP</span> databases;</span><br><span class=\"line\">    <span class=\"comment\">-- drop </span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"选择数据库\"><a href=\"#选择数据库\" class=\"headerlink\" title=\"选择数据库\"></a>选择数据库</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> use mysql;</span><br><span class=\"line\">    <span class=\"comment\">-- 选择 数据库名</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"查看当前在哪个库中\"><a href=\"#查看当前在哪个库中\" class=\"headerlink\" title=\"查看当前在哪个库中\"></a>查看当前在哪个库中</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> database();</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看数据库里有多少张表\"><a href=\"#查看数据库里有多少张表\" class=\"headerlink\" title=\"查看数据库里有多少张表\"></a>查看数据库里有多少张表</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> tables;</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看表结构\"><a href=\"#查看表结构\" class=\"headerlink\" title=\"查看表结构\"></a>查看表结构</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span>  <span class=\"keyword\">desc</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"><span class=\"comment\">--      desc 表名</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"指定字段查询-user-host\"><a href=\"#指定字段查询-user-host\" class=\"headerlink\" title=\"指定字段查询  user host\"></a>指定字段查询  user host</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span>  <span class=\"keyword\">select</span> <span class=\"keyword\">user</span>,host <span class=\"keyword\">from</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"><span class=\"comment\">--      查询      字段         表名</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"简单查询\"><a href=\"#简单查询\" class=\"headerlink\" title=\"简单查询\"></a><strong><center>简单查询</center></strong></h1><p>查询一个字段</p>\n<p>select 字段名 from 表名；</p>\n<p>select和from都是关键字</p>\n<p>字段名和表名都是标识符</p>\n<p><strong>强调</strong></p>\n<p>对于SQL语句来说，都是通用的</p>\n<p>所有的SQL语句以“;”结尾</p>\n<p>另外SQL语句不区分大小写，都行</p>\n<p><strong>查询两个字段或多个字段</strong></p>\n<p>用逗号隔开</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> id,name,password,address,phone <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>查询所有字段</strong></p>\n<p>第一种方式：可以把每个字段都写上</p>\n<p>第二种方式：可以使用*</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">user</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式的缺点：</p>\n<pre><code>1. 效率低\n2. 可读性差\n</code></pre>\n<p>在实际开发中不建议，可以自己玩没问题，你可以在DOS命令窗口中想快速的看一看全表数据可以采用这种方式。</p>\n<p><strong>给查询的列起别名</strong></p>\n <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> id <span class=\"keyword\">as</span> 编号,name <span class=\"keyword\">as</span> 姓名 <span class=\"keyword\">from</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> id,name <span class=\"keyword\">as</span> 姓名 <span class=\"keyword\">from</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"><span class=\"comment\">-- as 后面跟的就是别名</span></span><br></pre></td></tr></table></figure>\n\n<p>使用  <strong>as</strong> 关键字起别名</p>\n<p>__注意__：只是将显示的查询结果列名显示为 <code>编号姓名</code>，原表的列名还是叫id,name </p>\n<p>__记住__：select 语句是永远都不会进行修改操作的。（因为只负责查询）</p>\n<p><strong>as</strong>  关键字可以省略吗？ 可以的     (使用空格省略)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name 姓名,id 编号 <span class=\"keyword\">from</span> <span class=\"keyword\">user</span>;</span><br></pre></td></tr></table></figure>\n\n<p>假设起的别名有空格怎么办？  sql语句也会进行编译</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name 姓名,id 编 号 <span class=\"keyword\">from</span> <span class=\"keyword\">user</span>;</span><br></pre></td></tr></table></figure>\n\n<p>DBMS看到这样的语句，进行SQL语句的编译，不符合语法，编译报错。</p>\n<p>怎么解决？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"string\">&#x27;姓 名&#x27;</span>,id <span class=\"string\">&#x27;编 号&#x27;</span> <span class=\"keyword\">from</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> name &quot;姓 名&quot;,id &quot;编 号&quot; <span class=\"keyword\">from</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\">           <span class=\"comment\">-- 如果起别名要加个空格，就加个 单引号或者双引号</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准，双引号在oracle数据库中用不了。但是在mysql中可以使用。</p>\n<p>再次强调：数据库中的字符串都是用单引号括起来。这是标准的。双引号不标准。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary<span class=\"operator\">*</span><span class=\"number\">12</span> <span class=\"keyword\">from</span> employees;</span><br><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary<span class=\"operator\">*</span><span class=\"number\">12</span> 一年的工资 <span class=\"keyword\">from</span> employees; <span class=\"comment\">--起别名</span></span><br></pre></td></tr></table></figure>\n\n<p>结论：字段可以使用数学表达式！！！  然后起别名</p>\n<hr>\n<h1 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a><center>条件查询</center></h1><p><strong>1. 什么是条件查询?</strong></p>\n<p>不是将表中所有的数据都查出来，是查询符合条件的。</p>\n<p>语法格式：</p>\n<p>​    select</p>\n<p>​        字段1，字段2，字段3….</p>\n<p>​    from</p>\n<p>​        表名</p>\n<p>​    where</p>\n<p>​        条件：</p>\n<p><strong>2. 都有哪些条件?</strong></p>\n<p><strong>&#x3D; 等于</strong></p>\n<p>查询 名 工资等于2500的名字的工资情况？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary 工资 <span class=\"keyword\">from</span> employees <span class=\"keyword\">where</span> salary<span class=\"operator\">=</span><span class=\"number\">2500</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>&lt;&gt;或！&#x3D;不等于</strong></p>\n<p>查询 名 工资不等于2500的工资情况？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary 工资 <span class=\"keyword\">from</span> employees <span class=\"keyword\">where</span> salary<span class=\"operator\">!=</span><span class=\"number\">2500</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary 工资 <span class=\"keyword\">from</span> employees <span class=\"keyword\">where</span> salary<span class=\"operator\">&lt;&gt;</span><span class=\"number\">2500</span>;  <span class=\"comment\">--小于号和大于号组成的不等号</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>&lt;  小于</strong></p>\n<p>查询 名 工资小于2500的工资情况？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary 工资 <span class=\"keyword\">from</span> employees <span class=\"keyword\">where</span> salary<span class=\"operator\">&lt;</span><span class=\"number\">2500</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>&lt; &#x3D;小于等于</strong></p>\n<p>查询 名 工资小于等于2500的工资情况？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary 工资 <span class=\"keyword\">from</span> employees <span class=\"keyword\">where</span> salary<span class=\"operator\">&lt;=</span><span class=\"number\">2500</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>&gt;  大于</strong></p>\n<p>查询 名 工资大于2500的工资情况？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary 工资 <span class=\"keyword\">from</span> employees <span class=\"keyword\">where</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">2500</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>&gt; &#x3D;大于等于</strong></p>\n<p>查询 名 工资小于等于2500的工资情况？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> first_name,salary 工资 <span class=\"keyword\">from</span> employees <span class=\"keyword\">where</span> salary<span class=\"operator\">&gt;=</span><span class=\"number\">2500</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查询姓为： Austin 的工资和编号情况</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> last_name 姓,employee_id 编号,salary 工资 <span class=\"keyword\">from</span> employees <span class=\"keyword\">where</span> last_name<span class=\"operator\">=</span><span class=\"string\">&#x27;Austin&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>__betwee …. and ….    两者之间，等同于 &gt;&#x3D; and &lt;&#x3D; __</p>\n<p>查询工资在2500和3000之间的员工信息？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h2 id=\"笔记部分来源：\"><a href=\"#笔记部分来源：\" class=\"headerlink\" title=\"笔记部分来源：\"></a>笔记部分来源：</h2><p>[1]：<a href=\"https://www.jianshu.com/p/77a2c88a81c9\">https://www.jianshu.com/p/77a2c88a81c9</a><br>[2]：<a href=\"https://www.bilibili.com/video/BV1WT4y1a7K6\">https://www.bilibili.com/video/BV1WT4y1a7K6</a></p>\n<p>[3]：<a href=\"https://www.bilibili.com/video/BV1Vy4y1z7EX\">https://www.bilibili.com/video/BV1Vy4y1z7EX</a></p>\n","categories":["mysql"],"tags":["mysql"]},{"title":"Markdown笔记","url":"/2022/03/30/markdown/","content":"<h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><blockquote>\n<p>这是一段引用    </p>\n</blockquote>\n<p><em>斜体</em></p>\n<p><strong>粗体</strong></p>\n<p><em><strong>粗斜体</strong></em></p>\n<hr>\n<p><del>删除线</del></p>\n<p><u>下划线</u></p>\n<p>把大象放进冰箱</p>\n<ol>\n<li>打开冰箱</li>\n<li>大象放进去</li>\n<li>关上冰箱<br>无序列表</li>\n</ol>\n<ul>\n<li><p>阿斯顿</p>\n</li>\n<li><p>啊实打实大大</p>\n</li>\n<li><p>阿斯顿</p>\n</li>\n<li><p><input checked disabled type=\"checkbox\"> \n吃饭</p>\n</li>\n<li><p><input disabled type=\"checkbox\"> \n睡觉</p>\n</li>\n<li><p><input disabled type=\"checkbox\"> \n打豆豆</p>\n</li>\n</ul>\n<p>代码块：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Hello</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<!-- 冒号在左边就左对齐 两边居中对齐 -->\n<p>表格:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">姓名</th>\n<th align=\"right\">年龄</th>\n<th align=\"center\">成绩</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">张三</td>\n<td align=\"right\">19</td>\n<td align=\"center\">100</td>\n</tr>\n<tr>\n<td align=\"left\">王五</td>\n<td align=\"right\">19</td>\n<td align=\"center\">66</td>\n</tr>\n</tbody></table>\n<p>快捷键：<br>ctrl+B      横线<br>alt+c       批量修改格式</p>\n<p>脚注：<br>一键三连[^三连]<br>[^三连]:点赞、收藏、投币<br><br></p>\n<hr>\n<p>链接:<br>这是一个链接<a href=\"https://www.bilibili.com/\">bilibili</a><br>这个链接用1作为网站变量[百度][1]<br>这个链接用2作为网站变量[博客][2]<br>[1]:<a href=\"http://www.baidu.com/\">http://www.baidu.com/</a><br>[2]:<a href=\"http://blog-zw.top/\">http://blog-zw.top/</a></p>\n<p><img src=\"/2022/03/30/markdown/you.png\" alt=\"you\"></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=333750&auto=1&height=66\"></iframe>\n\n","categories":["Markdown"],"tags":["markdown"]},{"title":"Python基础笔记","url":"/2022/03/31/python-ji-chu-bi-ji/","content":"<h1 id=\"python基础笔记\"><a href=\"#python基础笔记\" class=\"headerlink\" title=\"python基础笔记\"></a><center>python基础笔记</center></h1><ul>\n<li>不单单只能导入变量函数和类都可以使用</li>\n</ul>\n<p>import&lt;模块名&gt;   会导入这个模块所有的代码元素，在访问时需要加前缀“模块名”</p>\n<p>form &lt;模块名&gt; import&lt;代码元素&gt;  会导入模块名中的代码元素(变量)直接使用代码元素名字 在访问时不需要加前缀“模块名”</p>\n<p>form &lt;模块名&gt; import&lt;代码元素&gt; as &lt;代码元素别名&gt;<br>会导入模块名中的代码元素(变量) 但使用时需要使用别名 在访问时不需要加前缀“模块名”</p>\n<p>例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> world</span><br><span class=\"line\"><span class=\"keyword\">from</span> world <span class=\"keyword\">import</span> Z</span><br><span class=\"line\"><span class=\"keyword\">from</span> world <span class=\"keyword\">import</span> x <span class=\"keyword\">as</span> x2</span><br><span class=\"line\">x=<span class=\"number\">100</span></span><br><span class=\"line\">y=<span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (y)       <span class=\"comment\">#访问当前模块变量y</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (world.y) <span class=\"comment\">#访问world模块变量y</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (z)       <span class=\"comment\">#访问world模块变量z</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (x2)      <span class=\"comment\">#x2是wor1d模块x别名</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"数字类型的数据\"><a href=\"#数字类型的数据\" class=\"headerlink\" title=\"数字类型的数据\"></a>数字类型的数据</h1><ul>\n<li><p>Python中有6种主要的内置数据类型：数字、字符串、列表、元组、集合和字典。</p>\n</li>\n<li><p>Python中有4种数字类型：整数类型、浮类型、复数类型和布尔类型</p>\n</li>\n</ul>\n<h2 id=\"整数类型\"><a href=\"#整数类型\" class=\"headerlink\" title=\"整数类型\"></a>整数类型</h2><ul>\n<li>Python中的整数类型为int类</li>\n<li>整数类型只有一种就是int</li>\n<li>默认情况下表示10进制</li>\n</ul>\n<ol>\n<li>二进制表示方式以阿拉伯数字 0B或(b) 作为前缀</li>\n<li>八进制表示方式以阿拉伯数字 0O或(o) 作为前缀</li>\n<li>十六进制表示方式以阿拉伯数字 0X或(x)作为前缀<h2 id=\"浮点类型\"><a href=\"#浮点类型\" class=\"headerlink\" title=\"浮点类型\"></a>浮点类型</h2></li>\n</ol>\n<ul>\n<li>Python中的浮点类型为float类</li>\n</ul>\n<ol>\n<li>print(type(1.))  打印出来也是float类型</li>\n<li>采用科学及算法表示科学计数法中会使用E(或e)表示10的指数，如e2表示10</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">3.36e2</span>)  //结果：<span class=\"number\">336.0</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">3.36e-2</span>) //结果：<span class=\"number\">0.0336</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">.36e-2</span>)  //结果：<span class=\"number\">0.00336</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"复数类型\"><a href=\"#复数类型\" class=\"headerlink\" title=\"复数类型\"></a>复数类型</h2><ul>\n<li>复数在数学中被表示为：a+bi,其中a被称为实部b被称为虚部，被称为虚数单位。</li>\n</ul>\n<ol>\n<li>复数不能单独存在，他们总是和一个0.0的实属部分一起来构成一个复数</li>\n<li>复数有实数部分和虚数部分构成</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">1</span>+<span class=\"number\">2j</span></span><br><span class=\"line\">b=<span class=\"number\">1</span>+<span class=\"number\">4j</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a+b)   // (<span class=\"number\">2</span>+<span class=\"number\">6j</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(a)) // &lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;complex&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h2><ul>\n<li>Python中的布尔类型为bool类：它只有两个值：True和False。</li>\n</ul>\n<ol>\n<li>布尔类型也属于整数类型，也可以说是整数类型的一种子类</li>\n<li>在python只有True和False、</li>\n</ol>\n<p>注意可以进行转换：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">bool</span>(<span class=\"number\">0</span>))   //整数<span class=\"number\">0</span>被转换为<span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">bool</span>(<span class=\"number\">2</span>))   //其他非零整数例如<span class=\"number\">2</span>被转换为<span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">bool</span>(<span class=\"string\">&#x27;&#x27;</span>))  //其他非空字符串会被转换为<span class=\"literal\">True</span> </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">bool</span>([]))  //(空列表）被转换为<span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">bool</span>(&#123;&#125;))  //(空字典）被转换为<span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"数字类型的相互转换\"><a href=\"#数字类型的相互转换\" class=\"headerlink\" title=\"数字类型的相互转换\"></a>数字类型的相互转换</h2><ol>\n<li>隐式类型的转换（自动类型转换）</li>\n<li>显式类型的转换（通过某种手段转换）</li>\n</ol>\n<h3 id=\"隐式类型转换：\"><a href=\"#隐式类型转换：\" class=\"headerlink\" title=\"隐式类型转换：\"></a>隐式类型转换：</h3><ul>\n<li>数字之间可以进行数学计算，在<br>进行数学计算时若数字类型不同，则<br>会发生隐式类型的转换。</li>\n</ul>\n<h4 id=\"转换表\"><a href=\"#转换表\" class=\"headerlink\" title=\"转换表\"></a><center>转换表</center></h4><table>\n<thead>\n<tr>\n<th align=\"center\">操作数1的类型</th>\n<th align=\"center\">操作数为2的类型</th>\n<th align=\"center\">转换后的类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">布尔</td>\n<td align=\"center\">整数</td>\n<td align=\"center\">整数</td>\n</tr>\n<tr>\n<td align=\"center\">布尔、整数</td>\n<td align=\"center\">浮点</td>\n<td align=\"center\">浮点</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">1</span>+<span class=\"literal\">True</span>)      //布尔值<span class=\"literal\">True</span>被转换为整数</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">1.0</span>+<span class=\"number\">1</span>)       //整数<span class=\"number\">1</span>被转换为浮点数</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">1.0</span>+<span class=\"literal\">True</span>)    //布尔值<span class=\"literal\">True</span>被转换为浮点数</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">1.0</span>+<span class=\"number\">1</span>+<span class=\"literal\">True</span>)  //整数<span class=\"number\">1</span>和布尔值都被转换为浮点数</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">1.0</span>+<span class=\"number\">1</span>+<span class=\"literal\">False</span>) //整数<span class=\"number\">1</span>和布尔值都被转换为浮点数</span><br></pre></td></tr></table></figure>\n<h3 id=\"显式类型转换：\"><a href=\"#显式类型转换：\" class=\"headerlink\" title=\"显式类型转换：\"></a>显式类型转换：</h3><ul>\n<li>需要使用转换函数进行显示转换分别是 int()、float()和bool()函数，来实现数字类型之间的转换</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(<span class=\"number\">1.0</span>+<span class=\"number\">1</span>))   //<span class=\"built_in\">int</span>(<span class=\"number\">1.0</span>)被转换为整数<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(<span class=\"literal\">False</span>))   //布尔数值<span class=\"literal\">False</span>使用<span class=\"built_in\">int</span>()函数返回<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(<span class=\"literal\">True</span>))    //布尔数值<span class=\"literal\">True</span>使用<span class=\"built_in\">int</span>()函数返回<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(<span class=\"number\">0.6</span>))     //浮点数值使用<span class=\"built_in\">int</span>()函数会截掉小数部分</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">float</span>(<span class=\"number\">5</span>))     //整数值使用f1oat()函数会加上小数部分(<span class=\"number\">.0</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">float</span>(<span class=\"literal\">False</span>)) //布尔数值<span class=\"literal\">False</span>使用<span class=\"built_in\">float</span>()函数返回<span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">float</span>(<span class=\"literal\">True</span>))  //与齿数值<span class=\"literal\">True</span>使用<span class=\"built_in\">float</span>()函数返回<span class=\"number\">1.0</span></span><br><span class=\"line\">结果：</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">5.0</span></span><br><span class=\"line\"><span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"number\">1.0</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><ul>\n<li>算术运算符</li>\n<li>比较运算符</li>\n<li>逻辑运算符</li>\n<li>位运算符</li>\n<li>赋值运算符</li>\n<li>运算符优先级<h2 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">名称</th>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">+</td>\n<td align=\"center\">加</td>\n<td align=\"center\">a+b</td>\n<td align=\"center\">求a与b的和</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">减</td>\n<td align=\"center\">a-b</td>\n<td align=\"center\">求a与b的差</td>\n</tr>\n<tr>\n<td align=\"center\">*</td>\n<td align=\"center\">乘</td>\n<td align=\"center\">a*b</td>\n<td align=\"center\">求a与b的积</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;</td>\n<td align=\"center\">除</td>\n<td align=\"center\">a&#x2F;b</td>\n<td align=\"center\">求a除以b的商</td>\n</tr>\n<tr>\n<td align=\"center\">%</td>\n<td align=\"center\">取余</td>\n<td align=\"center\">a%b</td>\n<td align=\"center\">求a除以b的余数</td>\n</tr>\n<tr>\n<td align=\"center\">**</td>\n<td align=\"center\">幂</td>\n<td align=\"center\">a**b</td>\n<td align=\"center\">求a的b次幂</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;&#x2F;</td>\n<td align=\"center\">地板除法</td>\n<td align=\"center\">a&#x2F;&#x2F;b</td>\n<td align=\"center\">求小于a与b的商的最大整数</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n<li>除法和地板除法的区别：&#x2F; 除的数结果是float类型 地板除法除的结果是整数类型<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">1</span>    </span><br><span class=\"line\"><span class=\"built_in\">print</span>(-a)    //-a是对a的取反运算</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">3</span>//<span class=\"number\">2</span>)  // <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">3</span>/<span class=\"number\">2</span>)   // <span class=\"number\">1.5</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(-<span class=\"number\">3</span>//<span class=\"number\">2</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(-<span class=\"number\">8</span>/<span class=\"number\">3</span>) // -<span class=\"number\">2</span></span><br><span class=\"line\">注意：</span><br><span class=\"line\">//   负数的地板除法运算 和整数不同 得到商后 像上取整，结果也就变成-<span class=\"number\">2</span> 了</span><br></pre></td></tr></table></figure>\n<h2 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">名称</th>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x3D;&#x3D;</td>\n<td align=\"center\">等于</td>\n<td align=\"center\">a&#x3D;&#x3D;b</td>\n<td align=\"center\">a等于b时返回True,否则返回False</td>\n</tr>\n<tr>\n<td align=\"center\">!&#x3D;</td>\n<td align=\"center\">不等于</td>\n<td align=\"center\">a!&#x3D;b</td>\n<td align=\"center\">与&#x3D;&#x3D;相反</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;</td>\n<td align=\"center\">大于</td>\n<td align=\"center\">a&gt;b</td>\n<td align=\"center\">a大于b时返回True,否则返回False</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;</td>\n<td align=\"center\">小于</td>\n<td align=\"center\">a&lt;b</td>\n<td align=\"center\">a小于b时返回True,否则返回False</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;&#x3D;</td>\n<td align=\"center\">大于等于</td>\n<td align=\"center\">a&gt;&#x3D;b</td>\n<td align=\"center\">a大于等于b时返回True,否则返回False</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;&#x3D;</td>\n<td align=\"center\">小于等于</td>\n<td align=\"center\">a&lt;&#x3D;b</td>\n<td align=\"center\">a小于等于b时返回True,否则返回False</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">名称</th>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">not</td>\n<td align=\"center\">逻辑非</td>\n<td align=\"center\">not a</td>\n<td align=\"center\">a为True时，值为False,a为False时，值为True</td>\n</tr>\n<tr>\n<td align=\"center\">and</td>\n<td align=\"center\">逻辑与</td>\n<td align=\"center\">a and b</td>\n<td align=\"center\">a、b全为Tue时，计算结果为True,否则为False</td>\n</tr>\n<tr>\n<td align=\"center\">or</td>\n<td align=\"center\">逻辑或</td>\n<td align=\"center\">a or b</td>\n<td align=\"center\">a、b全为Falset时，计算结果为False,否则为True</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>注意: 结果值为 True 和 False (bool值)</p>\n<h2 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">名称</th>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">~</td>\n<td align=\"center\">位反</td>\n<td align=\"center\">~X</td>\n<td align=\"center\">将x的值按位取反</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;</td>\n<td align=\"center\">位与</td>\n<td align=\"center\">x &amp; y</td>\n<td align=\"center\">将x与y按位进行位与运算</td>\n</tr>\n<tr>\n<td align=\"center\">|</td>\n<td align=\"center\">位或</td>\n<td align=\"center\">x | y</td>\n<td align=\"center\">将x与y按位进行位或运算</td>\n</tr>\n<tr>\n<td align=\"center\">^</td>\n<td align=\"center\">位异或</td>\n<td align=\"center\">x ^ y</td>\n<td align=\"center\">将x与y按位进行位异或运算</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;&gt;</td>\n<td align=\"center\">右移</td>\n<td align=\"center\">x &gt;&gt; a</td>\n<td align=\"center\">将x右移a位，高位采用符号位补位</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;&lt;</td>\n<td align=\"center\">左移</td>\n<td align=\"center\">x &lt;&lt; a</td>\n<td align=\"center\">将x左移a位，低位用0补位</td>\n</tr>\n</tbody></table>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2>","categories":["Python"],"tags":["python"]},{"title":"Python字符串","url":"/2022/06/06/python-zi-fu-chuan/","content":"<h2 id=\"爬虫是如何爬取网页的\"><a href=\"#爬虫是如何爬取网页的\" class=\"headerlink\" title=\"爬虫是如何爬取网页的\"></a>爬虫是如何爬取网页的</h2><ul>\n<li><blockquote>\n<p>1.向网页发送请求</p>\n<p>2.获取网页源代码</p>\n<p>3.解析数据内容</p>\n<p>4.存储数据</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"python中面向对象的三大基本特征及作用\"><a href=\"#python中面向对象的三大基本特征及作用\" class=\"headerlink\" title=\"python中面向对象的三大基本特征及作用\"></a>python中面向对象的三大基本特征及作用</h2><ul>\n<li><blockquote>\n<p>继承、封装（隐藏）、多态。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"类方法和实例方法\"><a href=\"#类方法和实例方法\" class=\"headerlink\" title=\"类方法和实例方法\"></a>类方法和实例方法</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">类名</span>:</span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">类方法名</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">        <span class=\"comment\">#方法体</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 实例属性</span></span><br><span class=\"line\">        self.age = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># self.number = 100</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符串内联函数\"><a href=\"#字符串内联函数\" class=\"headerlink\" title=\"字符串内联函数\"></a>字符串内联函数</h1><ul>\n<li><blockquote>\n<p>切片截取字符串 [起始:结束:步长]</p>\n</blockquote>\n<p><code>结束有，练习代码！！！</code></p>\n</li>\n</ul>\n<h2 id=\"find函数\"><a href=\"#find函数\" class=\"headerlink\" title=\"find函数\"></a><strong>find函数</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.find(<span class=\"built_in\">str</span>, beg=<span class=\"number\">0</span>, end=<span class=\"built_in\">len</span>(string))</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\"><span class=\"built_in\">str</span> -- 指定检索的字符串。</span><br><span class=\"line\">beg -- 开始索引，默认为<span class=\"number\">0</span>。</span><br><span class=\"line\">end -- 结束索引，默认为字符串的长度</span><br><span class=\"line\"></span><br><span class=\"line\">第⼀次匹配成功时返回匹配位置的索引，否则返回-<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"index函数\"><a href=\"#index函数\" class=\"headerlink\" title=\"index函数\"></a><strong>index函数</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.find(<span class=\"built_in\">str</span>, beg=<span class=\"number\">0</span>, end=<span class=\"built_in\">len</span>(string))</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\"><span class=\"built_in\">str</span> -- 指定检索的字符串。</span><br><span class=\"line\">beg -- 开始索引，默认为<span class=\"number\">0</span>。</span><br><span class=\"line\">end -- 结束索引，默认为字符串的长度。</span><br><span class=\"line\"></span><br><span class=\"line\">第⼀次匹配成功时返回匹配位置的索引，否则抛出异常 ValueError.</span><br></pre></td></tr></table></figure>\n\n<p><code>区别：find与index都是Python3中str类型的内置类型，都是⽤于查找⼦串在字符串中第⼀次匹配成功并返回，区别在于当匹配不成功时，前者返回-1，⽽后者抛出异常。</code></p>\n<h2 id=\"count函数\"><a href=\"#count函数\" class=\"headerlink\" title=\"count函数\"></a><strong>count函数</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.count(sub, start= <span class=\"number\">0</span>, end=<span class=\"built_in\">len</span>(string))</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\">sub -- 搜索的子字符串</span><br><span class=\"line\">start -- 字符串开始搜索的位置</span><br><span class=\"line\">end -- 字符串中结束搜索的位置</span><br><span class=\"line\"></span><br><span class=\"line\">统计字符串中某个字符的个数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"replace函数\"><a href=\"#replace函数\" class=\"headerlink\" title=\"replace函数\"></a><strong>replace函数</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.replace(old, new[, <span class=\"built_in\">max</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\">old -- 将被替换的字符串。</span><br><span class=\"line\">new -- 新字符串，用于替换old字符串。</span><br><span class=\"line\"><span class=\"built_in\">max</span> -- 可选字符串，替换不超过mac次</span><br><span class=\"line\"></span><br><span class=\"line\">将旧字符串替换为新字符串</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"splite函数\"><a href=\"#splite函数\" class=\"headerlink\" title=\"splite函数\"></a><strong>splite函数</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.split(<span class=\"built_in\">str</span>=<span class=\"string\">&quot;&quot;</span>, num=string.count(<span class=\"built_in\">str</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\"><span class=\"built_in\">str</span> -- 分隔符。默认为所有空字符。</span><br><span class=\"line\">num -- 分割次</span><br><span class=\"line\"></span><br><span class=\"line\">通过指定分隔符对字符串进行切片</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"capitalize函数\"><a href=\"#capitalize函数\" class=\"headerlink\" title=\"capitalize函数\"></a>capitalize函数</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.capitalize()</span><br><span class=\"line\"></span><br><span class=\"line\">第一个字符大写，其他字符小写</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"title函数\"><a href=\"#title函数\" class=\"headerlink\" title=\"title函数\"></a>title函数</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.title()</span><br><span class=\"line\"></span><br><span class=\"line\">所有单词首字母大写，其余字母小写</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"startswith函数\"><a href=\"#startswith函数\" class=\"headerlink\" title=\"startswith函数\"></a>startswith函数</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.startswith(<span class=\"built_in\">str</span>, beg=<span class=\"number\">0</span>,end=<span class=\"built_in\">len</span>(string))</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\"><span class=\"built_in\">str</span> -- 检测的字符串。</span><br><span class=\"line\">strbeg -- 可选参数用于设置字符串检测的起始位置。</span><br><span class=\"line\">strend -- 可选参数用于设置字符串检测的结束位置</span><br><span class=\"line\"></span><br><span class=\"line\">检查字符串是否以制定子串开头</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"endswith函数\"><a href=\"#endswith函数\" class=\"headerlink\" title=\"endswith函数\"></a>endswith函数</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.endswith(suffix[, start[, end]])</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\">suffix -- 该参数可以是一个字符串或者是一个元素。</span><br><span class=\"line\">start -- 字符串中的开始位置。</span><br><span class=\"line\">end -- 字符串中的结束位置。</span><br><span class=\"line\"></span><br><span class=\"line\">检查字符串是否以制定子串结尾</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"upper函数\"><a href=\"#upper函数\" class=\"headerlink\" title=\"upper函数\"></a>upper函数</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.upper()</span><br><span class=\"line\"></span><br><span class=\"line\">mystr = <span class=\"string\">&#x27;hello world itheima and itheimaApp&#x27;</span></span><br><span class=\"line\">newStr = mystr.upper()</span><br><span class=\"line\">结果为：HELLO WORLD ITHEIMA AND ITHEIMAAPP</span><br><span class=\"line\"></span><br><span class=\"line\">将小写字母转为大写字母</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ljust函数\"><a href=\"#ljust函数\" class=\"headerlink\" title=\"ljust函数\"></a>ljust函数</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.ljust(width[, fillchar])</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\">width -- 指定字符串长度。</span><br><span class=\"line\">fillchar -- 填充字符，默认为空格</span><br><span class=\"line\"></span><br><span class=\"line\">左对齐，使用空格填充至指定长度的新字符串</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rjust函数\"><a href=\"#rjust函数\" class=\"headerlink\" title=\"rjust函数\"></a>rjust函数</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.rjust(width[, fillchar])</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\">width -- 指定字符串长度。</span><br><span class=\"line\">fillchar -- 填充字符，默认为空格</span><br><span class=\"line\"></span><br><span class=\"line\">右对齐，使用空格填充至指定长度的新字符串</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"center函数\"><a href=\"#center函数\" class=\"headerlink\" title=\"center函数\"></a>center函数</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">str</span>.center(width[, fillchar])</span><br><span class=\"line\"></span><br><span class=\"line\">参数如下：</span><br><span class=\"line\">width -- 字符串的总宽度。</span><br><span class=\"line\">fillchar -- 填充字符。</span><br><span class=\"line\"></span><br><span class=\"line\">返回一个指定的宽度 width 居中的字符串 </span><br></pre></td></tr></table></figure>\n\n<hr>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- code =utf-8 #-*-</span></span><br><span class=\"line\"><span class=\"comment\"># @Time : 2022/6/6</span></span><br><span class=\"line\"><span class=\"comment\"># @Author: kli_zw</span></span><br><span class=\"line\"><span class=\"comment\"># @File : test3.py</span></span><br><span class=\"line\"><span class=\"comment\"># @Software: PyCharm</span></span><br><span class=\"line\">name = <span class=\"string\">&quot;abcdef&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(name[::-<span class=\"number\">1</span>])  \t\t\t\t<span class=\"comment\"># 负数就是从右边看步长</span></span><br><span class=\"line\">str1 = <span class=\"string\">&quot;this is string example....wow!!!&quot;</span></span><br><span class=\"line\">str2 = <span class=\"string\">&quot;exam&quot;</span></span><br><span class=\"line\">i = <span class=\"string\">&quot;i&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.index(str2))\t\t\t\t  <span class=\"comment\"># 是否包含子字符串,返回下标</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.find(str2))\t\t\t\t  <span class=\"comment\"># 是否包含子字符串,返回下标</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.count(i)) \t\t\t\t  <span class=\"comment\"># 统计个数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.replace(<span class=\"string\">&quot;this&quot;</span>, <span class=\"string\">&quot;those&quot;</span>))  <span class=\"comment\"># 将旧字符串替换为新字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str2.split(<span class=\"string\">&quot; &quot;</span>, <span class=\"number\">1</span>))  \t\t<span class=\"comment\"># 默认是以空格分割 这个是按空格分割一次</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.capitalize())  \t\t<span class=\"comment\"># 第一个字符大写，其他字符小写</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.title())  \t\t\t<span class=\"comment\"># 所有单词首字母大写  其余字母小写</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.startswith(<span class=\"string\">&#x27;this&#x27;</span>))  <span class=\"comment\"># 检查字符串是否以制定子串开头</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.startswith(<span class=\"string\">&#x27;is&#x27;</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>))  <span class=\"comment\"># 下标范围</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.startswith(<span class=\"string\">&#x27;this&#x27;</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>))  <span class=\"comment\"># flase</span></span><br><span class=\"line\">zw=<span class=\"string\">&quot;str&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.endswith(zw,<span class=\"number\">8</span>,<span class=\"number\">11</span>)) <span class=\"comment\"># 判断是否有后缀  字符开始位置下标，结束位置下标</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.upper())           <span class=\"comment\">#全部转换为大写</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.ljust(<span class=\"number\">40</span>,<span class=\"string\">&#x27;0&#x27;</span>))     <span class=\"comment\">#默认使用空格，可以指定填充   左对齐</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.rjust(<span class=\"number\">40</span>,<span class=\"string\">&#x27;0&#x27;</span>))     <span class=\"comment\">#默认使用空格，可以指定填充   右对齐</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.center(<span class=\"number\">40</span>,<span class=\"string\">&#x27;0&#x27;</span>))    <span class=\"comment\">#默认使用空格，可以指定填充   居中对齐</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">str1 = <span class=\"string\">&quot;this is string example....wow!!!&quot;</span></span><br><span class=\"line\">str2 = <span class=\"string\">&quot;exam&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.index(str2))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(str1.find(str2))</span><br></pre></td></tr></table></figure>\n\n","categories":["Python"],"tags":["python"]},{"title":"为什么Java中只有值传递？","url":"/2022/04/26/wei-shi-me-java-zhong-zhi-you-zhi-chuan-di/","content":"<h1 id=\"为什么-Java-中只有值传递？\"><a href=\"#为什么-Java-中只有值传递？\" class=\"headerlink\" title=\"为什么 Java 中只有值传递？\"></a>为什么 Java 中只有值传递？</h1><p>开始之前，我们先来搞懂下面这两个概念：</p>\n<ul>\n<li>形参&amp;实参</li>\n<li>值传递&amp;引用传递</li>\n</ul>\n<h1 id=\"形参-amp-实参\"><a href=\"#形参-amp-实参\" class=\"headerlink\" title=\"形参&amp;实参\"></a>形参&amp;实参</h1><p>方法的定义可能会用到参数（有参的方法），参数在程序语言中分为：</p>\n<ul>\n<li>实参（实际参数） ：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li>\n<li>形参（形式参数） ：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">hello</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// hello 为实参</span></span><br><span class=\"line\">sayHello(hello);</span><br><span class=\"line\"><span class=\"comment\">// str 为形参</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    System.out.println(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"值传递-amp-引用传递\"><a href=\"#值传递-amp-引用传递\" class=\"headerlink\" title=\"值传递&amp;引用传递\"></a>值传递&amp;引用传递</h1>程序设计语言将实参传递给方法（或函数）的方式分为两种：</li>\n<li>值传递 ：方法接收的是实参值的拷贝，会创建副本。</li>\n<li>引用传递 ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>\n</ul>\n<p><code>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</code></p>\n<h1 id=\"为什么-Java-只有值传递？\"><a href=\"#为什么-Java-只有值传递？\" class=\"headerlink\" title=\"为什么 Java 只有值传递？\"></a>为什么 Java 只有值传递？</h1><p>为什么说 Java 只有值传递呢？ 不需要太多废话，我通过 3 个例子来给大家证明。</p>\n<h1 id=\"案例1：传递基本类型参数\"><a href=\"#案例1：传递基本类型参数\" class=\"headerlink\" title=\"案例1：传递基本类型参数\"></a>案例1：传递基本类型参数</h1><h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num1 = &quot;</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num2 = &quot;</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;a = &quot;</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b = &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出：\"><a href=\"#输出：\" class=\"headerlink\" title=\"输出：\"></a>输出：</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">20</span></span><br><span class=\"line\">b = <span class=\"number\">10</span></span><br><span class=\"line\">num1 = <span class=\"number\">10</span></span><br><span class=\"line\">num2 = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a>解析：</h2><h3 id=\"在-swap-方法中，a、b-的值进行交换，并不会影响到-num1、num2。因为，a、b-的值，只是从-num1、num2-的复制过来的。也就是说，a、b-相当于-num1、num2-的副本，副本的内容无论怎么修改，都不会影响到原件本身。\"><a href=\"#在-swap-方法中，a、b-的值进行交换，并不会影响到-num1、num2。因为，a、b-的值，只是从-num1、num2-的复制过来的。也就是说，a、b-相当于-num1、num2-的副本，副本的内容无论怎么修改，都不会影响到原件本身。\" class=\"headerlink\" title=\"在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\"></a>在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</h3><h1 id=\"案例2：传递引用类型参数1\"><a href=\"#案例2：传递引用类型参数1\" class=\"headerlink\" title=\"案例2：传递引用类型参数1\"></a>案例2：传递引用类型参数1</h1><h2 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">  System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  change(arr);</span><br><span class=\"line\">  System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">  array[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出：-1\"><a href=\"#输出：-1\" class=\"headerlink\" title=\"输出：\"></a>输出：</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"解析：-1\"><a href=\"#解析：-1\" class=\"headerlink\" title=\"解析：\"></a>解析：</h2><h3 id=\"看了这个案例很多人肯定觉得-Java-对引用类型的参数采用的是引用传递。实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！也就是说-change-方法的参数拷贝的是-arr-（实参）的地址，因此，它和-arr-指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。为了更强有力地反驳-Java-对引用类型的参数采用的不是引用传递，我们再来看下面这个案例\"><a href=\"#看了这个案例很多人肯定觉得-Java-对引用类型的参数采用的是引用传递。实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！也就是说-change-方法的参数拷贝的是-arr-（实参）的地址，因此，它和-arr-指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。为了更强有力地反驳-Java-对引用类型的参数采用的不是引用传递，我们再来看下面这个案例\" class=\"headerlink\" title=\"看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例\"></a>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例</h3><h1 id=\"案例3-：传递引用类型参数2\"><a href=\"#案例3-：传递引用类型参数2\" class=\"headerlink\" title=\"案例3 ：传递引用类型参数2\"></a>案例3 ：传递引用类型参数2</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">   <span class=\"comment\">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Person</span> <span class=\"variable\">xiaoZhang</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;小张&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Person</span> <span class=\"variable\">xiaoLi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;小李&quot;</span>);</span><br><span class=\"line\">    swap(xiaoZhang, xiaoLi);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(Person person1, Person person2)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Person</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> person1;</span><br><span class=\"line\">    person1 = person2;</span><br><span class=\"line\">    person2 = temp;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;person1:&quot;</span> + person1.getName());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;person2:&quot;</span> + person2.getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出:\"></a>输出:</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">person1:小李</span><br><span class=\"line\">person2:小张</span><br><span class=\"line\">xiaoZhang:小张</span><br><span class=\"line\">xiaoLi:小李</span><br></pre></td></tr></table></figure>\n<h3 id=\"解析：-2\"><a href=\"#解析：-2\" class=\"headerlink\" title=\"解析：\"></a>解析：</h3><h3 id=\"怎么回事？？？两个引用类型的形参互换并没有影响实参啊！swap-方法的参数-person1-和-person2-只是拷贝的实参-xiaoZhang-和-xiaoLi-的地址。因此，-person1-和-person2-的互换只是拷贝的两个地址的互换罢了，并不会影响到实参-xiaoZhang-和-xiaoLi-。\"><a href=\"#怎么回事？？？两个引用类型的形参互换并没有影响实参啊！swap-方法的参数-person1-和-person2-只是拷贝的实参-xiaoZhang-和-xiaoLi-的地址。因此，-person1-和-person2-的互换只是拷贝的两个地址的互换罢了，并不会影响到实参-xiaoZhang-和-xiaoLi-。\" class=\"headerlink\" title=\"怎么回事？？？两个引用类型的形参互换并没有影响实参啊！swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。\"></a>怎么回事？？？两个引用类型的形参互换并没有影响实参啊！swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。</h3><h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"Java-中将实参传递给方法（或函数）的方式是-值传递-：\"><a href=\"#Java-中将实参传递给方法（或函数）的方式是-值传递-：\" class=\"headerlink\" title=\"Java 中将实参传递给方法（或函数）的方式是 值传递 ：\"></a>Java 中将实参传递给方法（或函数）的方式是 值传递 ：</h2><ul>\n<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>\n<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>\n</ul>\n<h1 id=\"引用于：-JavaGuide\"><a href=\"#引用于：-JavaGuide\" class=\"headerlink\" title=\"引用于： JavaGuide\"></a>引用于： JavaGuide</h1>","categories":["Java"],"tags":["java"]},{"title":"text","url":"/2022/08/07/text/","content":""},{"title":"在Linux里安装jdk","url":"/2022/04/30/zai-linux-li-an-zhuang-jdk/","content":"<h1 id=\"下载jdk\"><a href=\"#下载jdk\" class=\"headerlink\" title=\"下载jdk\"></a>下载jdk</h1><p>进入华为镜像网址：<a href=\"https://repo.huaweicloud.com/java/jdk/\">https://repo.huaweicloud.com/java/jdk/</a></p>\n<ol>\n<li><p>选择：8u181-b13</p>\n</li>\n<li><p>下载：jdk-8u181-linux-x64.tar.gz</p>\n</li>\n</ol>\n<img src=\"/2022/04/30/zai-linux-li-an-zhuang-jdk/2.png\" alt=\"11\" style=\"zoom:67%;\">\n\n<img src=\"/2022/04/30/zai-linux-li-an-zhuang-jdk/3.png\" style=\"zoom: 67%;\">\n\n<hr>\n<h1 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h1><ol>\n<li><strong>进入到安装包目录下，解压安装包到opt目录</strong></li>\n</ol>\n<ul>\n<li><blockquote>\n<p><strong>tar -zxvf jdk -8u22l-linux-x64.tar.gz  -C &#x2F;opt</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>配置java环境配置</strong>  进入etc&#x2F;profile配置全局变量</li>\n</ol>\n<ul>\n<li><blockquote>\n<p> <strong>vi &#x2F;etc&#x2F;profile</strong>        </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p> <strong>export JAVA_HOME&#x3D;&#x2F; opt&#x2F;java</strong> </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p> <strong>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>配置完成</strong></li>\n</ol>\n<ul>\n<li><blockquote>\n<p><strong>source &#x2F;etc&#x2F;profile</strong>    —-重新加载配置文件</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>java -version</strong>               —- 查看jdk版本</p>\n</blockquote>\n<p><code>后续可以使用命令 javac xxx.java  进行编译  java  xxx  运行</code></p>\n</li>\n</ul>\n","categories":["Linux"],"tags":["在Linux里安装jdk"]},{"title":"在Linux里安装mysql","url":"/2022/04/30/zai-linux-li-an-zhuang-mysql/","content":"<h1 id=\"解压安装包\"><a href=\"#解压安装包\" class=\"headerlink\" title=\"解压安装包\"></a>解压安装包</h1><ul>\n<li><blockquote>\n<p><strong>tar -zxvf mysql(版本号.tar.gz)  -C &#x2F;opt</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>cd &#x2F;opt</strong>  </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>mv mysql(版本号)    mysql</strong></p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"进入配置全局环境变量-可选择设置\"><a href=\"#进入配置全局环境变量-可选择设置\" class=\"headerlink\" title=\"进入配置全局环境变量(可选择设置)\"></a>进入配置全局环境变量(可选择设置)</h1><ul>\n<li><blockquote>\n<p><strong>vim &#x2F;etc&#x2F;profile</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>export MYSQL_HOME&#x3D;&#x2F;opt&#x2F;mysql</strong>  —-为实际安装目录路径</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>export PATH&#x3D;$PATH:$MYSQL_HOME&#x2F;bin</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>source &#x2F;etc&#x2F;profile</strong>  —-重新加载配置文件</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"创建用户与组-和-mysql创建目录存放数据\"><a href=\"#创建用户与组-和-mysql创建目录存放数据\" class=\"headerlink\" title=\"创建用户与组 和 mysql创建目录存放数据\"></a>创建用户与组 和 mysql创建目录存放数据</h1><ul>\n<li><blockquote>\n<p><strong>groupadd mysql</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>useradd -r -g mysql mysql</strong> </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>mkdir -p &#x2F;var&#x2F;lib&#x2F;mysql</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>chown mysql:mysql  -R &#x2F;var&#x2F;lib&#x2F;mysql</strong></p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"设置配置文件\"><a href=\"#设置配置文件\" class=\"headerlink\" title=\"设置配置文件\"></a>设置配置文件</h1><ul>\n<li><blockquote>\n<p><strong>vim &#x2F;etc&#x2F;my.cnf</strong></p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"keyword\">user</span><span class=\"operator\">=</span>mysql</span><br><span class=\"line\">basedir<span class=\"operator\">=</span><span class=\"operator\">/</span>opt<span class=\"operator\">/</span>mysql                                    </span><br><span class=\"line\">datadir<span class=\"operator\">=</span><span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql                    </span><br><span class=\"line\">socket<span class=\"operator\">=</span><span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql.sock </span><br><span class=\"line\"><span class=\"type\">character</span><span class=\"operator\">-</span><span class=\"keyword\">set</span><span class=\"operator\">-</span>server<span class=\"operator\">=</span>utf8mb4  </span><br><span class=\"line\">symbolic<span class=\"operator\">-</span>links<span class=\"operator\">=</span><span class=\"number\">0</span></span><br><span class=\"line\">[mysqld_safe]</span><br><span class=\"line\">log<span class=\"operator\">-</span>error<span class=\"operator\">=</span><span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>err.log</span><br><span class=\"line\">pid<span class=\"operator\">-</span>file<span class=\"operator\">=</span><span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql.pid</span><br><span class=\"line\">[client]</span><br><span class=\"line\">port<span class=\"operator\">=</span><span class=\"number\">3306</span>  </span><br><span class=\"line\">socket<span class=\"operator\">=</span><span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql.sock</span><br></pre></td></tr></table></figure></li>\n</ul>\n<img src=\"/2022/04/30/zai-linux-li-an-zhuang-mysql/1.png\" style=\"zoom:80%;\">\n\n<h1 id=\"进入-安装目录mysql-的-bin-目录下，初始化密码\"><a href=\"#进入-安装目录mysql-的-bin-目录下，初始化密码\" class=\"headerlink\" title=\"进入 安装目录mysql 的 bin 目录下，初始化密码\"></a>进入 安装目录mysql 的 bin 目录下，初始化密码</h1><ul>\n<li><blockquote>\n<p><strong>cd &#x2F;opt&#x2F;mysql&#x2F;bin</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>.&#x2F;mysqld –initialize –user&#x3D;mysql</strong></p>\n</blockquote>\n</li>\n</ul>\n<p><code>复制下方图片位置初始密码</code></p>\n<p><img src=\"/2022/04/30/zai-linux-li-an-zhuang-mysql/2.png\"></p>\n<p><code>注意以上图片的密码为初始密码，等下要进入MySQL修改</code></p>\n<h1 id=\"复制-mysql-的服务项至-linux-的服务项目录中\"><a href=\"#复制-mysql-的服务项至-linux-的服务项目录中\" class=\"headerlink\" title=\"复制 mysql 的服务项至 linux 的服务项目录中\"></a>复制 mysql 的服务项至 linux 的服务项目录中</h1><p><code>mysql.server 位于 support-files 目录下</code></p>\n<ul>\n<li><blockquote>\n<p><strong>cd &#x2F;opt&#x2F;mysql</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>cp support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld</strong></p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"设置mysql系统服务-开启开机自启动\"><a href=\"#设置mysql系统服务-开启开机自启动\" class=\"headerlink\" title=\"设置mysql系统服务 开启开机自启动\"></a>设置mysql系统服务 开启开机自启动</h1><ol>\n<li>进入系统服务文件修改 <code>vim /etc/init.d/mysqld</code> ，(这个位置为上面步骤复制创建的路径)  进入文件修改其 <code>basedir</code> 和 <code>datadir</code> 为实际对应⽬录：</li>\n</ol>\n<ul>\n<li><blockquote>\n<p><strong>basedir&#x3D;&#x2F;opt&#x2F;mysql</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"2\">\n<li>设置MYSQL系统服务并开启⾃启</li>\n</ol>\n<ul>\n<li><blockquote>\n<p><strong>chmod +x &#x2F;etc&#x2F;init.d&#x2F;mysqld</strong>  —- 增加 mysqld 服务控制脚本执⾏权限</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>chkconfig –add mysqld</strong>  —- 将 mysqld 服务加⼊到系统服务</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"启动，登录-输入初始密码\"><a href=\"#启动，登录-输入初始密码\" class=\"headerlink\" title=\"启动，登录 输入初始密码\"></a>启动，登录 输入初始密码</h1><ul>\n<li><blockquote>\n<p><strong>service mysql start</strong>  —- 启动MySql服务</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>mysql -uroot -p</strong>    —-  如果未设置全局变量  就<code>cd /opt/mysql/bin</code>   再次输入 mysql -uroot -p即可</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"成功进入MySQL后，修改mysql-默认的ROOT初始账户密x’x’x’x’x’x码\"><a href=\"#成功进入MySQL后，修改mysql-默认的ROOT初始账户密x’x’x’x’x’x码\" class=\"headerlink\" title=\"成功进入MySQL后，修改mysql 默认的ROOT初始账户密x’x’x’x’x’x码\"></a>成功进入MySQL后，修改mysql 默认的ROOT初始账户密x’x’x’x’x’x码</h1><ul>\n<li><blockquote>\n<p><strong>mysql&gt;alter user user() identified by “123456”;</strong> —-123456为修改后的密码</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"MySQL设置远程主机连接\"><a href=\"#MySQL设置远程主机连接\" class=\"headerlink\" title=\"MySQL设置远程主机连接\"></a>MySQL设置远程主机连接</h1><p>1. </p>\n<ul>\n<li><blockquote>\n<p><strong>mysql&gt;alter user user() identified by “123456”;</strong>  </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>mysql&gt;flush privileges;</strong> —-刷新权限 使修改生效</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>mysql&gt;set password for “root”@”%” &#x3D; ‘123456’;</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"2\">\n<li>退出mysql</li>\n</ol>\n<ul>\n<li><blockquote>\n<p><strong>exit</strong></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>systemctl stop firewalld.service</strong> —- 关闭防火墙</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"查看主机信息更改情况\"><a href=\"#查看主机信息更改情况\" class=\"headerlink\" title=\"查看主机信息更改情况\"></a>查看主机信息更改情况</h1><ul>\n<li><blockquote>\n<p><strong>mysql&gt; use mysql”;</strong> </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>select user,host from user;”</strong></p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/2022/04/30/zai-linux-li-an-zhuang-mysql/3.png\"><br>小提示：<br><code>Host列指定了允许用户登录所使用的IP，比如user=root Host=192.168.1.1。这里的意思就是说root用户只能通过192.168.1.1的客户端去访问。而%是个通配符，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果Host=%，表示所有IP都有连接权限。</code></p>\n<h1 id=\"远程连接错误情况\"><a href=\"#远程连接错误情况\" class=\"headerlink\" title=\"远程连接错误情况\"></a>远程连接错误情况</h1><ol>\n<li>2002的话就是没有开机后没有开启 mysql系统服务，开启即可</li>\n</ol>\n<ul>\n<li><blockquote>\n<p><strong>&#x2F;etc&#x2F;init.d&#x2F;mysql start   或    server mysql start   开启服务”</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"2\">\n<li>1130 没有开远程连接</li>\n</ol>\n<ul>\n<li><blockquote>\n<p><strong>更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从“localhost”改成”%” “</strong></p>\n</blockquote>\n<hr>\n</li>\n</ul>\n<h1 id=\"防火墙的开启、关闭、禁用命令\"><a href=\"#防火墙的开启、关闭、禁用命令\" class=\"headerlink\" title=\"防火墙的开启、关闭、禁用命令\"></a>防火墙的开启、关闭、禁用命令</h1><p>（1）设置开机启用防火墙：<strong>systemctl enable firewalld.service</strong></p>\n<p>（2）设置开机禁用防火墙：<strong>systemctl disable firewalld.service</strong></p>\n<p>（3）启动防火墙：<strong>systemctl start firewalld</strong></p>\n<p>（4）关闭防火墙：<strong>systemctl stop firewalld</strong></p>\n<p>（5）检查防火墙状态：<strong>systemctl status firewalld</strong> </p>\n<p>（6）重启防火墙：<strong>systemctl restart firewalld.service</strong></p>\n<p>3306进行防火墙配置：<code>firewall-cmd --zone=public --add-port=3306/tcp --permanent</code></p>\n<p>开放3306端口：<code>-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT</code></p>\n<p>查看开放端口：<code>firewall-cmd --list-ports</code></p>\n","categories":["Linux"],"tags":["在Linux里安装mysql"]},{"title":"爬虫笔记","url":"/2022/04/03/pa-chong/","content":"<h3 id=\"pip指令\"><a href=\"#pip指令\" class=\"headerlink\" title=\"pip指令:\"></a>pip指令:</h3><figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">pip install &lt;包名&gt; 安装指定的包</span><br><span class=\"line\">pip uninstall &lt;包名&gt; 删除指定的包</span><br><span class=\"line\">pip list 显示已安装的包</span><br><span class=\"line\">pip freeze 显示已经安装的包，并且以指定的格式显示</span><br></pre></td></tr></table></figure>\n<p>修改pip下载源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip install 包名 -i 国内源地址</span><br><span class=\"line\">豆瓣源：https://pypi.mirrors.ustc.edu.cn/simple</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>常用请求头信息</p>\n<ul>\n<li>User-Agent: 请求载体的身份标识</li>\n<li>Connection: 请求完毕后，是断开连接还是不保持连接<h4 id=\"常用响应头信息\"><a href=\"#常用响应头信息\" class=\"headerlink\" title=\"常用响应头信息\"></a>常用响应头信息</h4></li>\n<li>Content-Tyoe:服务器响应回客户端的数据类型<h4 id=\"https协议：\"><a href=\"#https协议：\" class=\"headerlink\" title=\"https协议：\"></a>https协议：</h4></li>\n<li>安全的超文本传输协议<h4 id=\"加密方式\"><a href=\"#加密方式\" class=\"headerlink\" title=\"加密方式\"></a>加密方式</h4></li>\n<li>对称密钥加密</li>\n<li>非对称密钥加密</li>\n<li>证书密钥加密<br>request模块<h4 id=\"request模块：\"><a href=\"#request模块：\" class=\"headerlink\" title=\"request模块：\"></a>request模块：</h4>是python中原生的一款基于网络请求的模块。功能非常强大，，简单便捷效率极高<h4 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h4>模拟浏览器发出请求<br>如何使用：(requests模块编码流程)</li>\n<li>指定url</li>\n<li>发请求</li>\n<li>获取相应数据</li>\n<li>持久化存储<h4 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装:\"></a>环境安装:</h4><figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip install requests</span><br></pre></td></tr></table></figure>\n<h4 id=\"实战编码：\"><a href=\"#实战编码：\" class=\"headerlink\" title=\"实战编码：\"></a>实战编码：</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">&quot;http://www.bilibili.com&quot;</span>  <span class=\"comment\"># 指定url</span></span><br><span class=\"line\">reponse = requests.get(url=url)  <span class=\"comment\"># 发起请求,get方法回返回一个响应对象</span></span><br><span class=\"line\">page_text = reponse.text  <span class=\"comment\"># 获取响应数据text饭hi i的是字符串形式的响应数据</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(page_text)</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./bilibili.html&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> fp:</span><br><span class=\"line\">    fp.write(page_text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;爬取数据结束！！!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n网页采集器：<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">headers = &#123;  <span class=\"comment\"># UA伪装</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;User-Agent&#x27;</span>: <span class=\"string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">url = <span class=\"string\">&quot;https://www.sogou.com/web?&quot;</span></span><br><span class=\"line\">kw = <span class=\"built_in\">input</span>(<span class=\"string\">&quot;请输入：&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">param = &#123;  <span class=\"comment\"># 处理url携带参数</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;query&#x27;</span>: kw</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#对指定的url发起的请求对应的url是携带参数的</span></span><br><span class=\"line\">response = requests.get(url=url,params=param,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">page_text = response.text</span><br><span class=\"line\">fileName = kw + <span class=\"string\">&#x27;.html&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(fileName, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> fp:</span><br><span class=\"line\">    fp.write(page_text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(fileName, <span class=\"string\">&#x27;保存成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>\n百度翻译：<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">post_url = <span class=\"string\">&#x27;https://fanyi.baidu.com/sug&#x27;</span>  <span class=\"comment\"># 1.指定url</span></span><br><span class=\"line\">headers = &#123;  <span class=\"comment\"># 2.UA伪装</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;User-Agent&#x27;</span>: <span class=\"string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">word = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;请输入:&#x27;</span>)</span><br><span class=\"line\">data = &#123;  <span class=\"comment\"># 3.post请求参数处理(同get请求一致)  参数处理</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;kw&#x27;</span>: word</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">response = requests.post(url=post_url, data=data, headers=headers)  <span class=\"comment\"># 请求发送</span></span><br><span class=\"line\"><span class=\"comment\"># 5.获取响应数据对象：json()方法返回的是obj json类型</span></span><br><span class=\"line\">dic_obj = response.json()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 持久化存储</span></span><br><span class=\"line\">fileName = word + <span class=\"string\">&#x27;.json&#x27;</span></span><br><span class=\"line\">fp = <span class=\"built_in\">open</span>(fileName, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">json.dump(dic_obj, fp=fp, ensure_ascii=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(dic_obj)</span><br></pre></td></tr></table></figure>\n药监总局：<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首页  http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsList</span></span><br><span class=\"line\"><span class=\"comment\"># 页面 http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById</span></span><br><span class=\"line\"><span class=\"comment\"># 页面 http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById</span></span><br><span class=\"line\"><span class=\"comment\">#首页和页面的区别就是在后面加了id，所以先去爬取每个页面的id,存储起来，然后for循环post将结果存进list,然后再格式化存储</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;  <span class=\"comment\"># UA伪装</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;User-Agent&#x27;</span>: <span class=\"string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">url = <span class=\"string\">&#x27;http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsList&#x27;</span></span><br><span class=\"line\">id_list = []  <span class=\"comment\"># 存储企业的id</span></span><br><span class=\"line\">all_data_list = []  <span class=\"comment\"># 存储所有的企业的id</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">20</span>):   <span class=\"comment\">#爬取前20页</span></span><br><span class=\"line\">    page = <span class=\"built_in\">str</span>(page)</span><br><span class=\"line\">    data = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;on&#x27;</span>: <span class=\"string\">&#x27;true&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;page&#x27;</span>: page,</span><br><span class=\"line\">        <span class=\"string\">&#x27;pageSize&#x27;</span>: <span class=\"string\">&#x27;15&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;productName&#x27;</span>: <span class=\"string\">&#x27; &#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;conditionType&#x27;</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;applyname&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;applysn&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    json_ids = requests.post(url=url, headers=headers, data=data).json()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> zw <span class=\"keyword\">in</span> json_ids[<span class=\"string\">&#x27;list&#x27;</span>]:  <span class=\"comment\"># 批量获取ID，储存id</span></span><br><span class=\"line\">        id_list.append(zw[<span class=\"string\">&#x27;ID&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取企业详情数据</span></span><br><span class=\"line\">post_url = <span class=\"string\">&#x27;http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">id</span> <span class=\"keyword\">in</span> id_list:  <span class=\"comment\"># 把储存的id赋值给字典</span></span><br><span class=\"line\">    data = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"built_in\">id</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    detial_json = requests.post(url=post_url, headers=headers, data=data).json()</span><br><span class=\"line\">    all_data_list.append(detial_json)  <span class=\"comment\"># 存进列表</span></span><br><span class=\"line\"><span class=\"comment\"># 持久化存储</span></span><br><span class=\"line\">fp = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./zw,json&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">json.dump(all_data_list, fp=fp, ensure_ascii=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;ovver!!!&#x27;</span>)<span class=\"comment\"># 首页  http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsList</span></span><br><span class=\"line\"><span class=\"comment\"># 页面 http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById</span></span><br><span class=\"line\"><span class=\"comment\"># 页面 http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById</span></span><br><span class=\"line\"><span class=\"comment\">#首页和页面的区别就是在后面加了id，所以先去爬取每个页面的id,存储起来，然后for循环post将结果存进list,然后再格式化存储</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;  <span class=\"comment\"># UA伪装</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;User-Agent&#x27;</span>: <span class=\"string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">url = <span class=\"string\">&#x27;http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsList&#x27;</span></span><br><span class=\"line\">id_list = []  <span class=\"comment\"># 存储企业的id</span></span><br><span class=\"line\">all_data_list = []  <span class=\"comment\"># 存储所有的企业的id</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">20</span>):   <span class=\"comment\">#爬取前20页</span></span><br><span class=\"line\">    page = <span class=\"built_in\">str</span>(page)</span><br><span class=\"line\">    data = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;on&#x27;</span>: <span class=\"string\">&#x27;true&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;page&#x27;</span>: page,</span><br><span class=\"line\">        <span class=\"string\">&#x27;pageSize&#x27;</span>: <span class=\"string\">&#x27;15&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;productName&#x27;</span>: <span class=\"string\">&#x27; &#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;conditionType&#x27;</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;applyname&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;applysn&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    json_ids = requests.post(url=url, headers=headers, data=data).json()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> zw <span class=\"keyword\">in</span> json_ids[<span class=\"string\">&#x27;list&#x27;</span>]:  <span class=\"comment\"># 批量获取ID，储存id</span></span><br><span class=\"line\">        id_list.append(zw[<span class=\"string\">&#x27;ID&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取企业详情数据</span></span><br><span class=\"line\">post_url = <span class=\"string\">&#x27;http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">id</span> <span class=\"keyword\">in</span> id_list:  <span class=\"comment\"># 把储存的id赋值给字典</span></span><br><span class=\"line\">    data = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"built_in\">id</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    detial_json = requests.post(url=post_url, headers=headers, data=data).json()</span><br><span class=\"line\">    all_data_list.append(detial_json)  <span class=\"comment\"># 存进列表</span></span><br><span class=\"line\"><span class=\"comment\"># 持久化存储</span></span><br><span class=\"line\">fp = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./zw,json&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">json.dump(all_data_list, fp=fp, ensure_ascii=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;ovver!!!&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n","categories":["Python"],"tags":["python"]},{"title":"数组的排序","url":"/2022/05/11/shu-zu-de-pai-xu/","content":"<h1 id=\"八大排序：\"><a href=\"#八大排序：\" class=\"headerlink\" title=\"八大排序：\"></a>八大排序：</h1><p><a href=\"https://blog.csdn.net/daocaokafei/article/details/122442020\">https://blog.csdn.net/daocaokafei/article/details/122442020</a></p>\n","categories":["Java"],"tags":["数组的排序"]},{"title":"面向对象 上","url":"/2022/03/31/mian-xiang-dui-xiang-shang/","content":"<h1 id=\"面向过程与面向对象-上\"><a href=\"#面向过程与面向对象-上\" class=\"headerlink\" title=\"面向过程与面向对象 上\"></a><center>面向过程与面向对象 上</center></h1><h3 id=\"面向过程与面向对象\"><a href=\"#面向过程与面向对象\" class=\"headerlink\" title=\"面向过程与面向对象\"></a>面向过程与面向对象</h3><ul>\n<li>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，<font>强调的<br>是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对<br>象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</font></li>\n<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如<br>抽象、分类、继承、聚合、多态等。<h3 id=\"面向过程-POP-与-面向对象-OOP\"><a href=\"#面向过程-POP-与-面向对象-OOP\" class=\"headerlink\" title=\"面向过程(POP) 与 面向对象(OOP)\"></a>面向过程(POP) 与 面向对象(OOP)</h3></li>\n<li>封装 (Encapsulation)</li>\n<li>继承 (Inheritance)</li>\n<li>多态 (Polymorphism)<h3 id=\"面向过程与面向对象-1\"><a href=\"#面向过程与面向对象-1\" class=\"headerlink\" title=\"面向过程与面向对象\"></a>面向过程与面向对象</h3><h4 id=\"面向过程\"><a href=\"#面向过程\" class=\"headerlink\" title=\"面向过程\"></a>面向过程</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 打开冰箱</span><br><span class=\"line\">2. 把大象装进冰箱</span><br><span class=\"line\">3. 把冰箱门关住</span><br></pre></td></tr></table></figure>\n<h3 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">人&#123;</span><br><span class=\"line\">    打开(冰箱)&#123;</span><br><span class=\"line\">        冰箱.开门();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    操作(大象)&#123;</span><br><span class=\"line\">        大象.进入(冰箱);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    关闭(冰箱)&#123;</span><br><span class=\"line\">        冰箱.关门();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">冰箱&#123;</span><br><span class=\"line\">    开门()&#123;&#125;</span><br><span class=\"line\">    关门()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">大象&#123;</span><br><span class=\"line\">    进入(冰箱)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"面向对象的思想概述\"><a href=\"#面向对象的思想概述\" class=\"headerlink\" title=\"面向对象的思想概述\"></a><center>面向对象的思想概述</center></h2></li>\n<li><h5 id=\"类-Class-和对象-Object-是面向对象的核心概念。\"><a href=\"#类-Class-和对象-Object-是面向对象的核心概念。\" class=\"headerlink\" title=\"类(Class)和对象(Object)是面向对象的核心概念。\"></a>类(Class)和对象(Object)是面向对象的核心概念。</h5></li>\n</ul>\n<ul>\n<li><blockquote>\n<p>类是对一类事物的描述，是抽象的、概念上的定义</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><h5 id=\"“万事万物皆对象”\"><a href=\"#“万事万物皆对象”\" class=\"headerlink\" title=\"“万事万物皆对象”\"></a>“万事万物皆对象”</h5></li>\n</ul>\n<ul>\n<li><blockquote>\n<p>可以理解为：类 &#x3D; 抽象概念的人；对象 &#x3D; 实实在在的某个人</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>面向对象程序设计的重点是类的设计</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>类的设计，其实就是类的成员的设计</p>\n</blockquote>\n<h2 id=\"面向对象的思想概述-1\"><a href=\"#面向对象的思想概述-1\" class=\"headerlink\" title=\"面向对象的思想概述\"></a><center>面向对象的思想概述</center></h2></li>\n</ul>\n<ul>\n<li>可以理解为：类 &#x3D; 抽象概念的人；对象 &#x3D; 实实在在的某个人</li>\n<li>面向对象程序设计的重点是类的设计</li>\n<li>类的设计，其实就是类的成员的设计</li>\n</ul>\n<h3 id=\"类的语法格式\"><a href=\"#类的语法格式\" class=\"headerlink\" title=\"类的语法格式\"></a><center>类的语法格式</center></h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">修饰符 class 类名&#123;</span><br><span class=\"line\">    属性声明;</span><br><span class=\"line\">    方法声明;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">说明：修饰符<span class=\"keyword\">public</span>:类可以被任意访问</span><br><span class=\"line\">    类的正文要用&#123; &#125;扩起来</span><br><span class=\"line\"></span><br><span class=\"line\">举例：</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;              <span class=\"comment\">//声明私有变量 age</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">showAge</span><span class=\"params\">(<span class=\"type\">int</span> i)</span>&#123;   <span class=\"comment\">//声明方法showAge()</span></span><br><span class=\"line\">            age=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象的创建和使用\"><a href=\"#对象的创建和使用\" class=\"headerlink\" title=\"对象的创建和使用\"></a>对象的创建和使用</h3><ul>\n<li><blockquote>\n<p>创建对象语法： 类名 对象名 &#x3D; new 类名();</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>说明：如果创建了一个类的多个对象，对于类中定义的属性，每个对象都拥有各自的一套副本，且互不干扰。</li>\n</ul>\n<br>\n空指针异常：就是调用  .参数 如果点之前的结构是不是null,如果是null意味着没指针，没有指针指下面的结构，就是空指针\n\n\n<h2 id=\"对象的创建和使用：匿名对象\"><a href=\"#对象的创建和使用：匿名对象\" class=\"headerlink\" title=\"对象的创建和使用：匿名对象\"></a>对象的创建和使用：匿名对象</h2><pre><code>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。如： new Person().shout();\n1.如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。\n2.我们经常将匿名对象作为实参传递给一个方法调用。\n</code></pre>\n<p>实际使用传入匿名对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">zhangshan</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br><span class=\"line\">        <span class=\"type\">zw</span> <span class=\"variable\">aa</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">zw</span>();</span><br><span class=\"line\">        aa.show(<span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>());    <span class=\"comment\">//创建匿名对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">zw</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(Student Stu)</span>&#123;    <span class=\"comment\">//传入的时候是匿名对象</span></span><br><span class=\"line\">        Stu.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">play</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;打游戏&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Java"],"tags":["java"]},{"title":"面向过程：面向过程性能比面向对象高？？","url":"/2022/04/20/mian-xiang-guo-cheng-mian-xiang-guo-cheng-xing-neng-bi-mian-xiang-dui-xiang-gao/","content":"<p>面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p>\n<p>—-》》<br>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。</p>\n<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p>\n<p>引用：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/431\">https://github.com/Snailclimb/JavaGuide/issues/431</a></p>\n","categories":["Java"],"tags":["java"]}]